<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="5"?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>テスト駆動開発から始めるRuby入門</title>
<date>2020-04-05</date>
</info>
<simpara>これはとあるプログラマがどのような思考を経てテスト駆動開発でアプリケーションを構築していったかを解説した内容である。隣りに座って話を聞きながらコードを追いかけているイメージで読み進めてみてださい。</simpara>
<section xml:id="_エピソード0">
<title>エピソード0</title>
<section xml:id="_環境構築から始めるテスト駆動開発">
<title>環境構築から始めるテスト駆動開発</title>
<section xml:id="_6s">
<title>6S</title>
<simpara>環境構築をするにあたっては <emphasis role="strong">5S</emphasis> + セキュリティの <emphasis role="strong">6S</emphasis> をベースに進めていきます。まず <emphasis role="strong">5S</emphasis> について、それからセキュリティについて解説します。</simpara>
<section xml:id="_5s">
<title>5S</title>
<blockquote>
<attribution>
Wikipedia
<citetitle><link xl:href="https://ja.wikipedia.org/wiki/5S">https://ja.wikipedia.org/wiki/5S</link></citetitle>
</attribution>
<simpara>5S（ごエス、ごーエス）とは、製造業・サービス業などの職場環境の維持改善で用いられるスローガンである。各職場において徹底されるべき事項を5つにまとめたもので、4S運動に「躾」（習慣化の場合もある）を加えた5項。</simpara>
</blockquote>
<simpara>具体的には、</simpara>
<itemizedlist>
<listitem>
<simpara>整理（せいり、Seiri）
いらないものを捨てる</simpara>
</listitem>
<listitem>
<simpara>整頓（せいとん、Seiton）
決められた物を決められた場所に置き、いつでも取り出せる状態にしておく</simpara>
</listitem>
<listitem>
<simpara>清掃（せいそう、Seisou）
常に掃除をする</simpara>
</listitem>
<listitem>
<simpara>清潔（せいけつ、Seiketsu）
3S（上の整理・整頓・清掃）を維持し職場の衛生を保つ</simpara>
</listitem>
<listitem>
<simpara>躾（しつけ、Shitsuke）
決められたルール・手順を正しく守る習慣をつける</simpara>
</listitem>
</itemizedlist>
<simpara>これがプログラミング環境構築とどのように関係していくのでしょうか？まずは、いらないものを捨てるのが <emphasis role="strong">整理</emphasis> ですがそもそもいらないものが何なのかを決めなければなりません。プログラミングで扱う対象はモノではなく情報です。ではどうやって情報を扱っていけばよいでしょう？ここは、 <emphasis role="strong">分類するな。ひたすら並べよ</emphasis> の考えに従い一箇所に記録をまとめていきましょう。そのためのテクニックとして <emphasis role="strong">エンジニアリングデイブックス</emphasis> があります。これは何をやったか何を学んだかをノートに時系列に記録していくことです。</simpara>
<simpara>Engineering Dayboks</simpara>
<blockquote>
<attribution>
Pragmatic Programmer: your journey to mastery
<citetitle>20th Anniversary Edition</citetitle>
</attribution>
<simpara>Eventually Dave asked the obvious question. It turned out that they’d been trained to keep an engineering daybook, a kind of journal in which they recorded what they did, things they’d learned, sketches of ideas, readings from meters: basically anything to do with their work. When the notebook became full, they’d write the date range on the spine, then stick it on the shelf next to previous daybooks. &#8230;&#8203;</simpara>
</blockquote>
<simpara>ノートは市販のものならどれでも構いませんがおすすめは <link xl:href="https://www.kokuyo-st.co.jp/stationery/softring-note/">ソフトリングノード</link> のB5サイズが手元に置いてもかさばらず使いやすいです。情報を一箇所に集めて必要なものと不要なものを分ける準備が出来ました。次は必要なものをすぐに取り出せるようにする <emphasis role="strong">整頓</emphasis> をどのように実践していくかを解説します。</simpara>
<simpara><emphasis role="strong">整頓</emphasis> の基本は <emphasis role="strong">分類するな。ひたすら並べよ</emphasis> です。デジタルデータも一箇所に保存していきましょう。具体的に保存する場所は後で解説します。また、分類するなといっても分類をする必要は当然発生します。分類にあたっては一貫したネーミングルールを適用していきます。具体的な方法は都度解説していきます。</simpara>
<blockquote>
<attribution>
Pragmatic Programmer: your journey to mastery
<citetitle>20th Anniversary Edition</citetitle>
</attribution>
<simpara>Name Well; Rename When Needed.</simpara>
<simpara>Name to express your intent to readers, and rename as soon as that intent shifts.</simpara>
</blockquote>
<simpara>基本は実践しなければ意味がありません。そして習慣にすることで初めてものにできるものです。そのためには自ら躾けて習慣化していかなければなりません。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>私がかつて発見した、そして多くの人に気づいてもらいたい効果とは、反復可能な振る舞いを規則にまで還元することで、規則の適用は機会的に反復可能になるということだ。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>ここで、Kent Beckが自ら語ったセリフを思い出しました。「僕は、偉大なプログラマなんかじゃない。偉大な習慣を身につけた少しましなプログラマなんだ」。</simpara>
</blockquote>
</section>
<section xml:id="_セキュリティ_security">
<title>セキュリティ(Security)</title>
<simpara><emphasis role="strong">5S</emphasis> に続いてセキュリティに関してですがここで扱う内容は <emphasis role="strong">情報セキュリティ</emphasis> に関する内容です。</simpara>
<blockquote>
<attribution>
Wikipedia
<citetitle><link xl:href="https://ja.wikipedia.org/wiki/%E6%83%85%E5%A0%B1%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3">https://ja.wikipedia.org/wiki/%E6%83%85%E5%A0%B1%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3</link></citetitle>
</attribution>
<simpara>情報セキュリティ（じょうほうセキュリティ、英: information security）とは、情報の機密性、完全性、可用性を維持すること。</simpara>
</blockquote>
<simpara>ここではパスワードに関する基本だけ抑えておいてください。</simpara>
<blockquote>
<attribution>
子どもに「パスワード」の付け方を教えられますか？
<citetitle><link xl:href="https://www.itmedia.co.jp/pcuser/articles/1808/09/news035.html">子どもを守るITリテラシー学</link></citetitle>
</attribution>
<itemizedlist>
<listitem>
<simpara>誕生日や電話番号など、親が見てパッと理解できる文字列はダメ</simpara>
</listitem>
<listitem>
<simpara>1単語で“読めてしまう”文字列はダメ</simpara>
</listitem>
<listitem>
<simpara>8文字以下の文字列は短すぎるからダメ</simpara>
</listitem>
</itemizedlist>
</blockquote>
<simpara>実際にパスワードを設定するときは</simpara>
<blockquote>
<attribution>
子どもに「パスワード」の付け方を教えられますか？
<citetitle><link xl:href="https://www.itmedia.co.jp/pcuser/articles/1808/09/news035.html">子どもを守るITリテラシー学</link></citetitle>
</attribution>
<itemizedlist>
<listitem>
<simpara>サービスごとに、3単語以上の英文字を並べる（例：pekinese-optimal-start）</simpara>
</listitem>
<listitem>
<simpara>なるべく長いパスワードを用意する（例：nagai-pasuwa-do-wo-youi-suru-amari-iirei-deha-naiga）</simpara>
</listitem>
<listitem>
<simpara>辞書に載っていないような文字列を用意する（例：Itags80vZyMp）</simpara>
</listitem>
</itemizedlist>
</blockquote>
<simpara>を参考にしてください。</simpara>
</section>
<section xml:id="_itリテラシ">
<title>ITリテラシ</title>
<simpara>以上がプログラミング環境構築にあたっての基本となる考えです。この記事では6Sを軸としたソフトウェア開発のための <emphasis role="strong">ITリテラシ</emphasis> 習得のベースとなる環境構築をすることを目的としています。</simpara>
<blockquote>
<attribution>
https://t-wada.hatenablog.jp/entry/clean-code-that-works
</attribution>
<simpara>今日のソフトウェア開発の世界において絶対になければならない3つの技術的な柱があります。 三本柱と言ったり、三種の神器と言ったりしていますが、それらは</simpara>
<itemizedlist>
<listitem>
<simpara>バージョン管理</simpara>
</listitem>
<listitem>
<simpara>テスティング</simpara>
</listitem>
<listitem>
<simpara>自動化</simpara>
</listitem>
</itemizedlist>
<simpara>の3つです。</simpara>
</blockquote>
</section>
</section>
<section xml:id="_アカウントの登録">
<title>アカウントの登録</title>
<simpara>まず各種サービスのアカウントを登録します。ここでは以下のアカウント設定で作業を進めていきますが各自作業の際は読み替えてください。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Microsft</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="mailto:newbie4649@outlook.jp">newbie4649@outlook.jp</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Google</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="mailto:newbie4649@gmail.com">newbie4649@gmail.com</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GitHub</simpara></entry>
<entry align="left" valign="top"><simpara>newbie4649</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="mailto:newbie4649@outlook.jp">newbie4649@outlook.jp</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WSL</simpara></entry>
<entry align="left" valign="top"><simpara>newbie4649</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>また、パスワードに関しては <emphasis role="strong">セキュリティ</emphasis> を参考に設定してください。アカウントIDに関しては可能な限り共通のID名を設定すると管理しやすくなります。登録アカウントとパスワードは一箇所に記録していつでも確認できるようにして置いてください。理想はパスワードマネージャーの使用ですがクラウドストレージでもいいです。他人にみられることがないように注意して管理しましょう。クラウドストレージで安全に保存する自身が無い場合は <emphasis role="strong">エンジニアリングデイブックス</emphasis> に記録しておきましょう。その際、もし落として他人にみられてもわからないような工夫をしておきましょう。手段はどうあれ <emphasis role="strong">保存する場所は一箇所</emphasis> が原則です。</simpara>
<section xml:id="_microsoftアカウントを作成する">
<title>Microsoftアカウントを作成する</title>
<simpara><link xl:href="https://signup.live.com/signup?wa=wsignin1.0&amp;rpsnv=13&amp;rver=7.3.6963.0&amp;wp=MBI_SSL&amp;wreply=https%3a%2f%2fwww.microsoft.com%2fja-jp%2f&amp;id=74335&amp;aadredir=1&amp;contextid=E56866F842F4E143&amp;bk=1584685585&amp;uiflavor=web&amp;lic=1&amp;mkt=JA-JP&amp;lc=1041&amp;uaid=491fc017de0f48c5c67a3833e7aca9ee">アカウントの作成</link> から新しいメールアドレスを取得を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ms-001.png"/>
</imageobject>
<textobject><phrase>ms 001</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ms-002.png"/>
</imageobject>
<textobject><phrase>ms 002</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ms-003.png"/>
</imageobject>
<textobject><phrase>ms 003</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ms-004.png"/>
</imageobject>
<textobject><phrase>ms 004</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ms-005.png"/>
</imageobject>
<textobject><phrase>ms 005</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ms-006.png"/>
</imageobject>
<textobject><phrase>ms 006</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_googleアカウントを作成する">
<title>Googleアカウントを作成する</title>
<simpara><link xl:href="https://support.google.com/accounts/answer/27441?hl=ja">Google アカウントの作成</link> から <literal>Googleアカウントを作成する</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ggl-001.png"/>
</imageobject>
<textobject><phrase>ggl 001</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ggl-002.png"/>
</imageobject>
<textobject><phrase>ggl 002</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ggl-003.png"/>
</imageobject>
<textobject><phrase>ggl 003</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_githubアカウントを作成する">
<title>GitHubアカウントを作成する</title>
<simpara><link xl:href="https://github.co.jp/">GitHubに登録する</link> から <literal>GitHubに登録する</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ghb-001.png"/>
</imageobject>
<textobject><phrase>ghb 001</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ghb-002.png"/>
</imageobject>
<textobject><phrase>ghb 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Freeプランを選択します</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ghb-003.png"/>
</imageobject>
<textobject><phrase>ghb 003</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_アカウントにサインインする">
<title>アカウントにサインインする</title>
<simpara><link xl:href="https://support.microsoft.com/ja-jp/help/4028195">Microsoft アカウントにサインインする方法</link> を参考にしてローカルアカウントからMicrosoftアカウントに切り替えます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/login-001.png"/>
</imageobject>
<textobject><phrase>login 001</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/login-002.png"/>
</imageobject>
<textobject><phrase>login 002</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/login-003.png"/>
</imageobject>
<textobject><phrase>login 003</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/login-004.png"/>
</imageobject>
<textobject><phrase>login 004</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/login-005.png"/>
</imageobject>
<textobject><phrase>login 005</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/login-006.png"/>
</imageobject>
<textobject><phrase>login 006</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/login-007.png"/>
</imageobject>
<textobject><phrase>login 007</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="_クラウドストレージのセットアップ">
<title>クラウドストレージのセットアップ</title>
<blockquote>
<attribution>
Pragmatic Programmer: your journey to mastery
<citetitle>20th Anniversary Edition</citetitle>
</attribution>
<simpara>Keep Knowledge in Plain Text</simpara>
<simpara>Plain text won&#8217;t become obsolete.It helps leverage your work and simplifies debugging and testing.</simpara>
</blockquote>
<simpara><link xl:href="https://products.office.com/ja-jp/home?SilentAuth=1">Office365</link> からOneDriveの設定を確認します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/drive-001.png"/>
</imageobject>
<textobject><phrase>drive 001</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/drive-002.png"/>
</imageobject>
<textobject><phrase>drive 002</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/drive-003.png"/>
</imageobject>
<textobject><phrase>drive 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>アカウントのパスワードなど機密情報は <link xl:href="https://support.office.com/ja-jp/article/personal-vault-で-onedrive-ファイルを保護する-6540ef37-e9bf-4121-a773-56f98dce78c4">Personal Vault で OneDrive ファイルを保護する</link> を使って管理すると良いでしょう。もしくは <link xl:href="https://1password.com/jp/">1Password</link> などパスワード管理ツールの導入を検討してください。</simpara>
<simpara><link xl:href="https://support.microsoft.com/ja-jp/help/17184/windows-10-onedrive">PCのOneDrive</link> にあるようにデータはローカルとクラウドの両方にあるので破損・紛失をしても復旧することが出来ます。</simpara>
</section>
<section xml:id="_開発環境のセットアップ">
<title>開発環境のセットアップ</title>
<section xml:id="_パッケージ管理ツールのインストール">
<title>パッケージ管理ツールのインストール</title>
<simpara>アプリケーションの管理にはパッケージ管理ツール <link xl:href="https://chocolatey.org/">The Package Manager for Windows</link> を使います。インストールの方法は <link xl:href="https://qiita.com/konta220/items/95b40b4647a737cb51aa">Chocolateyを使った環境構築の時のメモ</link> を参照してください。</simpara>
<simpara><literal>Get Started</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/pkg-001.png"/>
</imageobject>
<textobject><phrase>pkg 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>コードをコピーします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/pkg-002.png"/>
</imageobject>
<textobject><phrase>pkg 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>画面左下のスタートボタンを右クリックして <literal>Windows PowerSHell(管理者)(A)</literal> を起動してコピーしたコードを貼り付け実行します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/pkg-003.png"/>
</imageobject>
<textobject><phrase>pkg 003</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/pkg-004.png"/>
</imageobject>
<textobject><phrase>pkg 004</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/pkg-005.png"/>
</imageobject>
<textobject><phrase>pkg 005</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/pkg-006.png"/>
</imageobject>
<textobject><phrase>pkg 006</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_gitのインストール">
<title>gitのインストール</title>
<blockquote>
<attribution>
Pragmatic Programmer: your journey to mastery
<citetitle>20th Anniversary Edition</citetitle>
</attribution>
<simpara>Always Use Version Control</simpara>
<simpara>Vsersion control is a time machine for your work;you can go back.</simpara>
</blockquote>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/git-001.png"/>
</imageobject>
<textobject><phrase>git 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>画面左下のスタートボタンを右クリックして <literal>Windows PowerSHell(管理者)(A)</literal> を起動して以下のコマンドを入力します。質問には全てYを入力してください。</simpara>
<screen>choco install git</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/git-002.png"/>
</imageobject>
<textobject><phrase>git 002</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_powershellcoreのインストール">
<title>PowerShellCoreのインストール</title>
<simpara>続いて、以下のコマンドを入力します。質問には全てYを入力してください。</simpara>
<screen>choco install powershell-core</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/pwsh-001.png"/>
</imageobject>
<textobject><phrase>pwsh 001</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_windows_terminalのインストール">
<title>Windows Terminalのインストール</title>
<blockquote>
<attribution>
Pragmatic Programmer: your journey to mastery
<citetitle>20th Anniversary Edition</citetitle>
</attribution>
<simpara>Use the Power of Command Shells</simpara>
<simpara>Use the shell when graphical user interfaces don&#8217;t cut it.</simpara>
</blockquote>
<simpara>画面左下のスタートメニューから <literal>Microsft Store</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/terminal-001.png"/>
</imageobject>
<textobject><phrase>terminal 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>検索欄に <literal>terminal</literal> と入力したら表示されられる候補の中から <literal>Windows Terminal</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/terminal-002.png"/>
</imageobject>
<textobject><phrase>terminal 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>入手</literal> を押してアプリケーションをインストールします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/terminal-003.png"/>
</imageobject>
<textobject><phrase>terminal 003</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_wslのインストール">
<title>WSLのインストール</title>
<simpara>続いて、検索欄に <literal>ubuntu</literal> と入力して候補の中から <literal>Ubuntu</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-001.png"/>
</imageobject>
<textobject><phrase>wsl 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>入手を押してアプリケーションをインストールします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-002.png"/>
</imageobject>
<textobject><phrase>wsl 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>インストール後に起動を実行しても必要な設定があるため実行できません。一旦アプリケーションを閉じます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-003.png"/>
</imageobject>
<textobject><phrase>wsl 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>画面左下のスタートメニューから歯車のアイコンを選択してWindowsの設定画面を表示します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-004.png"/>
</imageobject>
<textobject><phrase>wsl 004</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>アプリ</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-005.png"/>
</imageobject>
<textobject><phrase>wsl 005</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>アプリと機能</literal> から <literal>プログラミングと機能</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-006.png"/>
</imageobject>
<textobject><phrase>wsl 006</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>Windows Subsystem for Linux</literal> にチェックを入れてOKボタンを押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-007.png"/>
</imageobject>
<textobject><phrase>wsl 007</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>今すぐ再起動</literal> を押してWindowsを再起動します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-008-1.png"/>
</imageobject>
<textobject><phrase>wsl 008 1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>画面左下のスタートメニューから <literal>Ubuntu</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-008-2.png"/>
</imageobject>
<textobject><phrase>wsl 008 2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>セットアップが始まるのでユーザーIDとパスワードを設定してください。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-009.png"/>
</imageobject>
<textobject><phrase>wsl 009</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/wsl-010.png"/>
</imageobject>
<textobject><phrase>wsl 010</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="_エディタのセットアップ">
<title>エディタのセットアップ</title>
<blockquote>
<attribution>
Pragmatic Programmer: your journey to mastery
<citetitle>20th Anniversary Edition</citetitle>
</attribution>
<simpara>Achieve Editor Fluency</simpara>
<simpara>An editor is your most important tool. Know how to make it do what you need, quickly and accurately.</simpara>
</blockquote>
<section xml:id="_インストール">
<title>インストール</title>
<simpara><link xl:href="https://aka.ms/vscode-java-installer-win">Download Visual Studio Code Java Pack Installer</link> からVSCodeをダウンロードしてセットアッププログラムを実行します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/vscode-001.png"/>
</imageobject>
<textobject><phrase>vscode 001</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/vscode-002.png"/>
</imageobject>
<textobject><phrase>vscode 002</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/vscode-003.png"/>
</imageobject>
<textobject><phrase>vscode 003</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_設定">
<title>設定</title>
<simpara>エディタが起動すると画面右下にWSL拡張機能インストールのポップアップが表示されるので <literal>Install</literal> を押して拡張機能をインストールします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/setting-001.png"/>
</imageobject>
<textobject><phrase>setting 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>続いて画面左下の歯車を選択してメニューから <literal>Settings</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/setting-002.png"/>
</imageobject>
<textobject><phrase>setting 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>検索欄に <literal>trim</literal> と入力します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/setting-003.png"/>
</imageobject>
<textobject><phrase>setting 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>チェックをオンにします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/setting-004.png"/>
</imageobject>
<textobject><phrase>setting 004</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>同様に検索欄に <literal>format on save</literal> と入力してチェックをオンにします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/setting-005.png"/>
</imageobject>
<textobject><phrase>setting 005</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>必要に応じてキーバインドなども自分が使いやすいようにカスタマイズします。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://qiita.com/kinchiki/items/dabb5c890d9c57907503">Visual Studio Codeで簡単にショートカットキーを変更する方法</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://loumo.jp/wp/archive/20191125120000/">VSCode 内蔵ターミナルで ctrl-p などのショートカットキーを利用する方法</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_拡張機能の追加">
<title>拡張機能の追加</title>
<simpara>エディタのメニューが英語なので日本語に変更する拡張機能をインストールします。</simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-ja">Japanese Language Pack for Visual Studio Code</link></simpara>
<simpara>画面左のExtensionアイコンを選択して検索欄に <literal>japanese</literal> と入力したら日本語拡張パッケージが表示されるので <literal>Install</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/package-001.png"/>
</imageobject>
<textobject><phrase>package 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>Restart Now</literal> を押してエディタを再起動します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/package-002.png"/>
</imageobject>
<textobject><phrase>package 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>メニューが日本語になりました。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/package-003.png"/>
</imageobject>
<textobject><phrase>package 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>同様の手順で以下の拡張機能をインストールします。</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=vscode-icons-team.vscode-icons">vscode-icons</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">GitLens</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory">Git History</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer">Bracket Pair Colorizer</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks">Bookmarks</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight">TODO Highlight</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=ionutvmi.path-autocomplete">Path Autocomplete</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=mechatroner.rainbow-csv">Rainbow CSV</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=ryu1kn.partial-diff">Partial Diff</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=mrmlnc.vscode-duplicate">Duplicate action</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github">GitHub Pull Requests</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=codezombiech.gitignore">gitignore</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=fabiospampinato.vscode-todo-plus">Todo+</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=IBM.output-colorizer">Output Colorizer</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=shardulm94.trailing-spaces">Trailing Spaces</link></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_設定の同期">
<title>設定の同期</title>
<simpara>エディタの設定をして拡張機能をインストールしました。再インストールなどでエディタを再インストールする場合に上記の作業を再度するのは手間なので設定をオンライに保存してすぐにセットアップできるようにしておきます。</simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync">Settings Sync</link> をインストールすると以下の画面が表示されるので <literal>LOGIN WITH GITHUB</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-001.png"/>
</imageobject>
<textobject><phrase>sync 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>アクセスを許可する</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-002.png"/>
</imageobject>
<textobject><phrase>sync 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>開く</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-003.png"/>
</imageobject>
<textobject><phrase>sync 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ブラウザが起動するので <literal>Authorize</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-004.png"/>
</imageobject>
<textobject><phrase>sync 004</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-005.png"/>
</imageobject>
<textobject><phrase>sync 005</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>SKIP</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-006.png"/>
</imageobject>
<textobject><phrase>sync 006</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>エディタメニューの <literal>表示</literal> から <literal>コマンドパレット</literal> を選択して <literal>Sync</literal> と入力して入力候補の中から <literal>アップデート・アップロードの設定</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-007.png"/>
</imageobject>
<textobject><phrase>sync 007</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>はい</literal> を押して設定をアップロードします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-008.png"/>
</imageobject>
<textobject><phrase>sync 008</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>エディタの設定を変更した際はアップロードすることで最新の設定を保存することができます。保存した設定を読み込む場合はコマンドパレットから <literal>Sync: 設定をダウンロード</literal> を選択します。</simpara>
<simpara>もし、GitHub連携で以下のような画面になった場合は登録メールアドレスに認証コードが送られているので確認してください。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-009.png"/>
</imageobject>
<textobject><phrase>sync 009</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/sync-010.png"/>
</imageobject>
<textobject><phrase>sync 010</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_hello_world">
<title>Hello world</title>
<section xml:id="_プログラムを作成する">
<title>プログラムを作成する</title>
<simpara>エディタのセットアップが出来たのでかんたんなプログラムを作ってみましょう。
お題は <link xl:href="https://ja.wikipedia.org/wiki/Hello_world">Hello world</link> です。
まず、プログラムを作成する場所ですが今回はディスクトップの直下に <literal>Projects</literal> というフォルダを作成してその中に配置したいと思います。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-001.png"/>
</imageobject>
<textobject><phrase>hello 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>Projects</literal> フォルダの中に <literal>PowerShell</literal> フォルダを作成します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-002.png"/>
</imageobject>
<textobject><phrase>hello 002</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-003.png"/>
</imageobject>
<textobject><phrase>hello 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>エディタを起動します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-004.png"/>
</imageobject>
<textobject><phrase>hello 004</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>エディタを起動したらエクスプローラアイコンから <literal>フォルダを開く</literal> を選択して作成したフォルダを開きます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-005.png"/>
</imageobject>
<textobject><phrase>hello 005</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-007.png"/>
</imageobject>
<textobject><phrase>hello 007</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>フォルダを開いたらファイルアイコンを選択して <literal>HelloWorld.ps1</literal> ファイルを作成します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-008.png"/>
</imageobject>
<textobject><phrase>hello 008</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-009.png"/>
</imageobject>
<textobject><phrase>hello 009</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>まず、以下のコードを入力してキーボードのF5を押します。</simpara>
<programlisting language="powershell" linenumbering="unnumbered">Describe "HelloWorld" {
    It "何か便利なものだ" {
        $true | Should Be $false
    }
}</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-010.png"/>
</imageobject>
<textobject><phrase>hello 010</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>プログラムの実行と一緒にテストの実行結果が表示されます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-011.png"/>
</imageobject>
<textobject><phrase>hello 011</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>テストが通るように修正します。</simpara>
<programlisting language="powershell" linenumbering="unnumbered">Describe "HelloWorld" {
    It "何か便利なものだ" {
        $true | Should Be $true
    }
}</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-012.png"/>
</imageobject>
<textobject><phrase>hello 012</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>テスティングフレームワークの動作が確認できたのでプログラム作成に入ります。</simpara>
<programlisting language="powershell" linenumbering="unnumbered">Describe "HelloWorld" {
    It "何か便利なものだ" {
        $true | Should Be $true
    }
    It "簡単な挨拶を返す" {
        HelloWorld | Should Be "Hello from PowerShell"
    }
}</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-013.png"/>
</imageobject>
<textobject><phrase>hello 013</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>HelloWorld</literal> 関数を追加します。</simpara>
<programlisting language="powershell" linenumbering="unnumbered">Describe "HelloWorld" {
    It "何か便利なものだ" {
        $true | Should Be $true
    }
    It "簡単な挨拶を返す" {
        HelloWorld | Should Be "Hello from PowerShell"
    }
}

function HelloWorld {
    return "Hello from PowerShell"
}</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-014.png"/>
</imageobject>
<textobject><phrase>hello 014</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>F5キーを押してテストが通ったことを確認したらテストケースを追加します。もしテストが失敗するようなら保存のタイミングあっていない場合があるので再度F5キーを押して実行してみてください。</simpara>
<programlisting language="powershell" linenumbering="unnumbered">Describe "HelloWorld" {
    It "何か便利なものだ" {
        $true | Should Be $true
    }
    It "簡単な挨拶を返す" {
        HelloWorld | Should Be "Hello from PowerShell"
    }
    It "指定された名前で挨拶を返す" {
        HelloWorld "VSCode" | Should Be "Hello from VSCode"
    }
}

function HelloWorld {
    return "Hello from PowerShell"
}</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-015.png"/>
</imageobject>
<textobject><phrase>hello 015</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>HelloWorld</literal> 関数は既定の挨拶しか返さないのでテストが失敗します。</simpara>
<screen>...
Describing HelloWorld
 [+] 何か便利なものだ 41ms
 [+] 簡単な挨拶を返す 12ms
 [-] 指定された名前で挨拶を返す 56ms
   Expected string length 17 but was 21. Strings differ at index 11.
   Expected: {Hello from VSCode}
   But was:  {Hello from PowerShell}
   ----------------------^
...</screen>
<simpara><literal>HelloWorld</literal> 関数に引数を追加して表示できるように変更します。</simpara>
<programlisting language="powershell" linenumbering="unnumbered">Describe "HelloWorld" {
    It "何か便利なものだ" {
        $true | Should Be $true
    }
    It "簡単な挨拶を返す" {
        HelloWorld | Should Be "Hello from PowerShell"
    }
    It "指定された名前で挨拶を返す" {
        HelloWorld "VSCode" | Should Be "Hello from VSCode"
    }
}

function HelloWorld($name) {
    return "Hello from $name"
}</programlisting>
<simpara>F5を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-016.png"/>
</imageobject>
<textobject><phrase>hello 016</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>指定された名前で挨拶を返す</literal> テストは通りましたが今度は <literal>簡単な挨拶を返す</literal> テストが失敗してしまいました。</simpara>
<screen>Describing HelloWorld
 [+] 何か便利なものだ 39ms
 [-] 簡単な挨拶を返す 23ms
   Expected string length 21 but was 11. Strings differ at index 11.
   Expected: {Hello from PowerShell}
   But was:  {Hello from }
   ----------------------^
...
 [+] 指定された名前で挨拶を返す 29ms
...</screen>
<simpara><literal>HelloWorld</literal> 関数にデフォルト引数を設定してテストを通るようにします。</simpara>
<screen>Describe "HelloWorld" {
    It "何か便利なものだ" {
        $true | Should Be $true
    }
    It "簡単な挨拶を返す" {
        HelloWorld | Should Be "Hello from PowerShell"
    }
    It "指定された名前で挨拶を返す" {
        HelloWorld "VSCode" | Should Be "Hello from VSCode"
    }
}

function HelloWorld($name = "PowerShell") {
    return "Hello from $name"
}</screen>
<simpara>F5を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-017.png"/>
</imageobject>
<textobject><phrase>hello 017</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>仕上げに不要なテストを削除してテストケースの文言をわかりやすくしておきます。</simpara>
<screen>Describe "HelloWorld" {
    It "何も指定されていない場合は既定の挨拶を返す" {
        HelloWorld | Should Be "Hello from PowerShell"
    }
    It "指定された名前で挨拶を返す" {
        HelloWorld "VSCode" | Should Be "Hello from VSCode"
    }
}

function HelloWorld($name = "PowerShell") {
    return "Hello from $name"
}</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-018.png"/>
</imageobject>
<textobject><phrase>hello 018</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>HelloWorld</literal> プログラムの完成です。</simpara>
</section>
<section xml:id="_プログラムをデバッグする">
<title>プログラムをデバッグする</title>
<simpara>プログラムを作成していると思った通りに動かないことが多々あります。そのようなときにプログラムの動作を確認するにはエディタのデバッグ機能を使います。</simpara>
<simpara>まず確認したいプログラムの行を左部分を押してブレークポイント（赤丸）を設定します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-019.png"/>
</imageobject>
<textobject><phrase>hello 019</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ブレークポイントを設定したらF5を押してプログラムの実行します。そうするとブレークポイント部分でプログラムが停止して変数などの情報が確認できるようになります。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-020.png"/>
</imageobject>
<textobject><phrase>hello 020</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>画面上の実行ボタンを押すと次のブレークポイントに移動します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-021.png"/>
</imageobject>
<textobject><phrase>hello 021</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-022.png"/>
</imageobject>
<textobject><phrase>hello 022</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-023.png"/>
</imageobject>
<textobject><phrase>hello 023</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>デバッガを終了するには終了ボタンを押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-024.png"/>
</imageobject>
<textobject><phrase>hello 024</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ブレークポイントを再度押すことで解除ができます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-025.png"/>
</imageobject>
<textobject><phrase>hello 025</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_プログラムをレポジトリに保存する">
<title>プログラムをレポジトリに保存する</title>
<simpara>作成したプログラムをレポジトリに保存します。まずソース管理アイコンを選択して <literal>リポジトリを初期化する</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-026.png"/>
</imageobject>
<textobject><phrase>hello 026</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-027.png"/>
</imageobject>
<textobject><phrase>hello 027</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>変更をステージ</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-028.png"/>
</imageobject>
<textobject><phrase>hello 028</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>変更内容を入力します。ここでは <literal>feat: HelloWorld</literal> を入力しておきます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-029.png"/>
</imageobject>
<textobject><phrase>hello 029</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>コミット</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-030.png"/>
</imageobject>
<textobject><phrase>hello 030</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>初回登録時は以下の警告が表示されるので追加作業が必要になります。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-031-1.png"/>
</imageobject>
<textobject><phrase>hello 031 1</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-031-2.png"/>
</imageobject>
<textobject><phrase>hello 031 2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>以下のコマンドをターミナルに入力します。</simpara>
<screen>git config --global user.name "newbie4649"
git config --global user.email newbie4649@outlook.jp</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-032.png"/>
</imageobject>
<textobject><phrase>hello 032</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>再度 <literal>コミット</literal> を押してレポジトリに保存します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-033.png"/>
</imageobject>
<textobject><phrase>hello 033</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>レポジトリの記録内容は <literal>GitLens</literal> から確認することが出来ます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/hello-034.png"/>
</imageobject>
<textobject><phrase>hello 034</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</section>
<section xml:id="_開発言語のセットアップ">
<title>開発言語のセットアップ</title>
<section xml:id="_ruby環境のセットアップ_windows版">
<title>Ruby環境のセットアップ(Windows版)</title>

</section>
<section xml:id="_インストール_2">
<title>インストール</title>
<simpara><link xl:href="https://rubyinstaller.org/downloads/">RubyInstaller</link>からWITH DEVKITをインストールします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-install-001.png"/>
</imageobject>
<textobject><phrase>ruby win install 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>インストラーの指示に従います。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-install-002.png"/>
</imageobject>
<textobject><phrase>ruby win install 002</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-install-003.png"/>
</imageobject>
<textobject><phrase>ruby win install 003</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-install-004.png"/>
</imageobject>
<textobject><phrase>ruby win install 004</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-install-005.png"/>
</imageobject>
<textobject><phrase>ruby win install 005</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>3を入力してエンターキーを押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-install-006.png"/>
</imageobject>
<textobject><phrase>ruby win install 006</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_追加パッケージのインストール">
<title>追加パッケージのインストール</title>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=rebornix.Ruby">Ruby for Visual Studio Code</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=castwide.solargraph">Ruby Solargraph</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=kaiwood.endwise">vscode-endwise</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=misogi.ruby-rubocop">ruby-rubocop</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-test-explorer">Test Explorer UI</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=connorshea.vscode-ruby-test-adapter">Ruby Test Explorer</link></simpara>
</section>
<section xml:id="_設定_2">
<title>設定</title>
<simpara>既定のシェルをPowerShell Coreに変更します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-vscode-001.png"/>
</imageobject>
<textobject><phrase>ruby win vscode 001</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-vscode-002.png"/>
</imageobject>
<textobject><phrase>ruby win vscode 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>新しいターミナルを開いて以下のコマンドを入力します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">gem install rubocop
gem install debase
gem install ruby-debug-ide
gem install solargraph</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-vscode-003.png"/>
</imageobject>
<textobject><phrase>ruby win vscode 003</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-vscode-004.png"/>
</imageobject>
<textobject><phrase>ruby win vscode 004</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_hello_world_2">
<title>Hello world</title>
<section xml:id="_プログラムを作成する_2">
<title>プログラムを作成する</title>
<simpara><literal>Projects</literal> フォルダ内に <literal>Ruby</literal> フォルダを作成してエディタからフォルダを開きます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-001.png"/>
</imageobject>
<textobject><phrase>ruby win hello 001</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-002.png"/>
</imageobject>
<textobject><phrase>ruby win hello 002</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-003.png"/>
</imageobject>
<textobject><phrase>ruby win hello 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>新しいファイル</literal> 作成アイコンを押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-004.png"/>
</imageobject>
<textobject><phrase>ruby win hello 004</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ファイル名は <literal>main.rb</literal> とします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-005.png"/>
</imageobject>
<textobject><phrase>ruby win hello 005</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ファイルに以下のコードを入力したらRunアイコンを選択して <literal>create a launch.json file</literal> を押してメニューからRubyを選択します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, false)
  end
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-006.png"/>
</imageobject>
<textobject><phrase>ruby win hello 006</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>Debug Local File</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-007.png"/>
</imageobject>
<textobject><phrase>ruby win hello 007</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>launch.json</literal> ファイルが作成されたら <literal>main.rb</literal> タブに戻ってF5キーを押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-008.png"/>
</imageobject>
<textobject><phrase>ruby win hello 008</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>デバッグコンソールに実行結果が表示されれば準備完了です。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-009.png"/>
</imageobject>
<textobject><phrase>ruby win hello 009</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>テストをパスするようにコードを修正してF5キーを押します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-010.png"/>
</imageobject>
<textobject><phrase>ruby win hello 010</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>テスティングフレームワークの動作が確認できたので <literal>hello_world</literal> 関数の作成に入ります。まず以下のコードを追加してF5キーを押してテストが失敗することを確認します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-011.png"/>
</imageobject>
<textobject><phrase>ruby win hello 011</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>hello_world</literal> 関数を追加してテストをパスさせます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end
end

def hello_world
  'Hello from Ruby'
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-012.png"/>
</imageobject>
<textobject><phrase>ruby win hello 012</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>指定された名前で挨拶を返すようにします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end

  def test_指定された名前で挨拶を返す
    assert_equal('Hello from VSCode', hello_world('VSCode'))
  end
end

def hello_world
  "Hello from Ruby"
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-013.png"/>
</imageobject>
<textobject><phrase>ruby win hello 013</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>関数に引数を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end

  def test_指定された名前で挨拶を返す
    assert_equal('Hello from VSCode', hello_world('VSCode'))
  end
end

def hello_world(name)
  "Hello from #{name}"
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-014.png"/>
</imageobject>
<textobject><phrase>ruby win hello 014</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>指定された名前で挨拶を返す</literal> テストはパスしましたが今度は <literal>簡単な挨拶を返す</literal> テストが失敗するようになりましたのでデフォルト引数を設定してテストをパスするようにします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end

  def test_指定された名前で挨拶を返す
    assert_equal('Hello from VSCode', hello_world('VSCode'))
  end
end

def hello_world(name = 'Ruby')
  "Hello from #{name}"
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-015.png"/>
</imageobject>
<textobject><phrase>ruby win hello 015</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>仕上げに不要なテストを削除してテストケースの文言をわかりやすくしておきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何も指定されていない場合は既定の挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end

  def test_指定された名前で挨拶を返す
    assert_equal('Hello from VSCode', hello_world('VSCode'))
  end
end

def hello_world(name = 'Ruby')
  "Hello from #{name}"
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-hello-016.png"/>
</imageobject>
<textobject><phrase>ruby win hello 016</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_プログラムをデバッグする_2">
<title>プログラムをデバッグする</title>
<simpara>まず確認したいプログラムの行を左部分を押してブレークポイント（赤丸）を設定します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-debug-001.png"/>
</imageobject>
<textobject><phrase>ruby win debug 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ブレークポイントを設定したらF5を押してプログラムの実行します。そうするとブレークポイント部分でプログラムが停止して変数などの情報が確認できるようになります。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-debug-002.png"/>
</imageobject>
<textobject><phrase>ruby win debug 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>画面上の実行ボタンを押すと次のブレークポイントに移動します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-debug-003.png"/>
</imageobject>
<textobject><phrase>ruby win debug 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>デバッガを終了するには終了ボタンを押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-debug-004.png"/>
</imageobject>
<textobject><phrase>ruby win debug 004</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ブレークポイントを再度押すことで解除ができます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-debug-005.png"/>
</imageobject>
<textobject><phrase>ruby win debug 005</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_プログラムをレポジトリに保存する_2">
<title>プログラムをレポジトリに保存する</title>
<simpara>ソース管理を選択して <literal>リポジトリを初期化する</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-git-001.png"/>
</imageobject>
<textobject><phrase>ruby win git 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>全ての変更をステージ</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-git-002.png"/>
</imageobject>
<textobject><phrase>ruby win git 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>変更内容に <literal>feat: HelloWorld</literal> と入力して <literal>コミット</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-git-003.png"/>
</imageobject>
<textobject><phrase>ruby win git 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>変更内容は <literal>GitLens</literal> から確認できます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-win-git-004.png"/>
</imageobject>
<textobject><phrase>ruby win git 004</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="_ruby環境のセットアップ_wsl版">
<title>Ruby環境のセットアップ(WSL版)</title>
<simpara>画面左下の <literal>&gt;&lt;</literal> を押してメニューから <literal>Remote-WSL: New Window</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-001.png"/>
</imageobject>
<textobject><phrase>ruby 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>アクセスを許可する</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-002.png"/>
</imageobject>
<textobject><phrase>ruby 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>新しいウィンドウが立ち上がったらExtensionメニューから <literal>Install Local Extensions in "WSL: Ubuntu'&#8230;&#8203;"</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-003.png"/>
</imageobject>
<textobject><phrase>ruby 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>全てにチェックをしてインストールします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-004.png"/>
</imageobject>
<textobject><phrase>ruby 004</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>拡張機能のインストールが終わったら <literal>Reload Window</literal> を押して拡張機能を読み込みます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-005.png"/>
</imageobject>
<textobject><phrase>ruby 005</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_プロビジョニングの実行">
<title>プロビジョニングの実行</title>
<simpara>Ruby開発環境の自動構築をするため以下のレポジトリを自分のレポジトリにフォークします。</simpara>
<simpara><link xl:href="https://github.com/hiroshima-arc/tdd_rb">テスト駆動開発から始めるRuby入門</link></simpara>
<simpara><literal>Fork</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-001.png"/>
</imageobject>
<textobject><phrase>provision 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>Fork</literal> が完了して自分のレポジトリにコピーされたら <literal>Clone or download</literal> を押してレポジトリのURLをコピーします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-002.png"/>
</imageobject>
<textobject><phrase>provision 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>エクスプローラアイコンメニューから <literal>レポジトリをクローンする</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-003.png"/>
</imageobject>
<textobject><phrase>provision 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>先程コピーしたレポジトリのURLを貼り付けます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-004.png"/>
</imageobject>
<textobject><phrase>provision 004</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>保存先はそのままで <literal>OK</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-005.png"/>
</imageobject>
<textobject><phrase>provision 005</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>開く</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-006.png"/>
</imageobject>
<textobject><phrase>provision 006</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>メニューから <literal>ターミナル</literal> <literal>新しいターミナル</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-007-1.png"/>
</imageobject>
<textobject><phrase>provision 007 1</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-007-2.png"/>
</imageobject>
<textobject><phrase>provision 007 2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ターミナルに以下のコマンドを入力します。実行時にパスワード入力が求められるのでWSLで設定したパスワードを入力してください。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ sudo apt-get update -y
[sudo] password for newbie4649:</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-008.png"/>
</imageobject>
<textobject><phrase>provision 008</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>続いて、ターミナルに以下のコマンドを入力します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ sudo apt install ansible -y</programlisting>
<simpara>続いて、エクスプローラから　<literal>provisioning/vars/site.yml</literal> をファイルを開いて <literal>user:</literal> の名前をWSLで設定したユーザーIDに変更します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-009.png"/>
</imageobject>
<textobject><phrase>provision 009</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>変更を保存したらターミナルに以下のコマンドを入力します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd provisioning/tasks/
$ sudo ansible-playbook --inventory=localhost, --connection=local site.yml</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-010.png"/>
</imageobject>
<textobject><phrase>provision 010</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>セットアップが完了したらエディタを再起動してプロジェクトを開きます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-010-2.png"/>
</imageobject>
<textobject><phrase>provision 010 2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>以下のコマンドを入力してRubyがセットアップされていることを確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby -v</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-011.png"/>
</imageobject>
<textobject><phrase>provision 011</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>続いて、ターミナルに以下のコマンドを入力します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ code ~/.bashrc</programlisting>
<simpara>表示されたファイルの一番最後に以下のコードを追加して保存します。</simpara>
<screen>...
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion" # This loads nvm bash_compl</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-012.png"/>
</imageobject>
<textobject><phrase>provision 012</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>保存したら以下のコマンドを実行してNode.jsのバージョンが表示されたらセットアップ完了です。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ source ~/.bashrc
$ nvm install --lts
$ node -v</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/provision-013.png"/>
</imageobject>
<textobject><phrase>provision 013</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_追加パッケージのインストール_2">
<title>追加パッケージのインストール</title>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=rebornix.Ruby">Ruby for Visual Studio Code</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=castwide.solargraph">Ruby Solargraph</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=kaiwood.endwise">vscode-endwise</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=misogi.ruby-rubocop">ruby-rubocop</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-test-explorer">Test Explorer UI</link></simpara>
<simpara><link xl:href="https://marketplace.visualstudio.com/items?itemName=connorshea.vscode-ruby-test-adapter">Ruby Test Explorer</link></simpara>
<simpara>ターミナルに以下のコマンドを入力します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">gem install rubocop
gem install debase
gem install ruby-debug-ide
gem install solargraph</programlisting>
</section>
<section xml:id="_hello_world_3">
<title>Hello world</title>
<section xml:id="_プログラムを作成する_3">
<title>プログラムを作成する</title>
<simpara><literal>REAMD.md</literal> を選択してから <literal>新しいファイル</literal> 作成アイコンを押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-001.png"/>
</imageobject>
<textobject><phrase>ruby hello 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ファイル名は <literal>main.rb</literal> とします。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-002.png"/>
</imageobject>
<textobject><phrase>ruby hello 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ファイルに以下のコードを入力したらRunアイコンを選択して <literal>create a launch.json file</literal> を押してメニューからRubyを選択します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, false)
  end
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-003.png"/>
</imageobject>
<textobject><phrase>ruby hello 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>Debug Local File</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-004.png"/>
</imageobject>
<textobject><phrase>ruby hello 004</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>launch.json</literal> ファイルが作成されたら <literal>main.rb</literal> タブに戻ってF5キーを押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-005.png"/>
</imageobject>
<textobject><phrase>ruby hello 005</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>デバッグコンソールに実行結果が表示されれば準備完了です。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-006.png"/>
</imageobject>
<textobject><phrase>ruby hello 006</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>テストをパスするようにコードを修正してF5キーを押します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-007.png"/>
</imageobject>
<textobject><phrase>ruby hello 007</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>テスティングフレームワークの動作が確認できたので <literal>hello_world</literal> 関数の作成に入ります。まず以下のコードを追加してF5キーを押してテストが失敗することを確認します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-008.png"/>
</imageobject>
<textobject><phrase>ruby hello 008</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>hello_world</literal> 関数を追加してテストをパスさせます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end
end

def hello_world
  'Hello from Ruby'
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-009.png"/>
</imageobject>
<textobject><phrase>ruby hello 009</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>指定された名前で挨拶を返すようにします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end

  def test_指定された名前で挨拶を返す
    assert_equal('Hello from VSCode', hello_world('VSCode'))
  end
end

def hello_world
  "Hello from Ruby"
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-010.png"/>
</imageobject>
<textobject><phrase>ruby hello 010</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>関数に引数を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end

  def test_指定された名前で挨拶を返す
    assert_equal('Hello from VSCode', hello_world('VSCode'))
  end
end

def hello_world(name)
  "Hello from #{name}"
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-011.png"/>
</imageobject>
<textobject><phrase>ruby hello 011</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><literal>指定された名前で挨拶を返す</literal> テストはパスしましたが今度は <literal>簡単な挨拶を返す</literal> テストが失敗するようになりましたのでデフォルト引数を設定してテストをパスするようにします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何か便利なもの
    assert_equal(true, true)
  end

  def test_簡単な挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end

  def test_指定された名前で挨拶を返す
    assert_equal('Hello from VSCode', hello_world('VSCode'))
  end
end

def hello_world(name = 'Ruby')
  "Hello from #{name}"
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-012.png"/>
</imageobject>
<textobject><phrase>ruby hello 012</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>仕上げに不要なテストを削除してテストケースの文言をわかりやすくしておきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/autorun'

class TestHelloWorld &lt; Minitest::Test
  def test_何も指定されていない場合は既定の挨拶を返す
    assert_equal('Hello from Ruby', hello_world)
  end

  def test_指定された名前で挨拶を返す
    assert_equal('Hello from VSCode', hello_world('VSCode'))
  end
end

def hello_world(name = 'Ruby')
  "Hello from #{name}"
end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-hello-013.png"/>
</imageobject>
<textobject><phrase>ruby hello 013</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_プログラムをデバッグする_3">
<title>プログラムをデバッグする</title>
<simpara>まず確認したいプログラムの行を左部分を押してブレークポイント（赤丸）を設定します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-debug-001.png"/>
</imageobject>
<textobject><phrase>ruby debug 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ブレークポイントを設定したらF5を押してプログラムの実行します。そうするとブレークポイント部分でプログラムが停止して変数などの情報が確認できるようになります。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-debug-002.png"/>
</imageobject>
<textobject><phrase>ruby debug 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>画面上の実行ボタンを押すと次のブレークポイントに移動します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-debug-003.png"/>
</imageobject>
<textobject><phrase>ruby debug 003</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>デバッガを終了するには終了ボタンを押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-debug-004.png"/>
</imageobject>
<textobject><phrase>ruby debug 004</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>ブレークポイントを再度押すことで解除ができます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-debug-005.png"/>
</imageobject>
<textobject><phrase>ruby debug 005</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_プログラムをレポジトリに保存する_3">
<title>プログラムをレポジトリに保存する</title>
<simpara><literal>全ての変更をステージ</literal> を選択します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-git-001.png"/>
</imageobject>
<textobject><phrase>ruby git 001</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>変更内容に <literal>feat: HelloWorld</literal> と入力して <literal>コミット</literal> を押します。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-git-002.png"/>
</imageobject>
<textobject><phrase>ruby git 002</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>変更内容は <literal>GitLens</literal> から確認できます。</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="../../images/article/episode_0/ruby-git-003.png"/>
</imageobject>
<textobject><phrase>ruby git 003</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</section>
<section xml:id="_参照">
<title>参照</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://roadmap.sh/">Developer Roadmaps</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/kamranahmedse/developer-roadmap">WEB DEVELOPER ROADMAP - 2020</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://note.com/yukionoguchi/n/n6fa36e6aff86">「超」整理法の思想</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://at-jinji.jp/work/007">効率的な文書管理方法とは。保管方法、運用ルール作りの3ステップを紹介</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://at-jinji.jp/blog/11259/">書類整理の基本は書類をためないこと！ 「『超』整理術」を簡単解説</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.oreilly.com/library/view/the-pragmatic-programmer/9780135956977/">The Pragmatic Programmer: your journey to mastery, 20th Anniversary Edition, 2nd Edition</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.itmedia.co.jp/pcuser/articles/1808/09/news035.html">子どもを守るITリテラシー学</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://jaminlifelog.com/notes/work/clean-desktop-files">フォルダ管理の基本ルール5選！整理されていないデスクトップにさよならバイバイ！</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://support.microsoft.com/ja-jp/help/4026324/microsoft-account-how-to-create">新しい Microsoft アカウントを作成する方法</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/kikutaro/items/0e5deb36047d0137a767">Java開発環境がすぐに作れる「Visual Studio Code Installer for Java」を試してみた</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://code.visualstudio.com/docs/languages/java">Java in Visual Studio Code</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/rubytomato@github/items/fdfc0a76e848442f374e">WSL (Windows Subsystem for Linux)の基本メモ</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.red-gate.com/simple-talk/sysadmin/powershell/practical-powershell-unit-testing-getting-started/">Practical PowerShell Unit-Testing: Getting Started</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/y-tsutsu/items/179717ecbdcc27509e5a">日頃お世話になっているElectronのアプリ開発に入門してみる</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/kai_kou/items/ceeee47996339e5eecc4">VSCodeの拡張機能「GIST」が便利すぎてHackMDを使うのをやめた</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/sensuikan1973/items/74cf5383c02dbcd82234">VSCodeのオススメ拡張機能 24 選 (とTipsをいくつか)</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/n_oshiumi/items/1ad3f55d58f2d9d48d1e">VScodeで保存時に自動で空白を削除しよう！</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/mitashun/items/e2f118a9ca7b96b97840">Visual Studio Codeで保存時自動整形の設定方法</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/code2545Light/items/ca61673c42fb26fc2d28">VisualStudioCode でRubyの開発環境を作る</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="_エピソード1">
<title>エピソード1</title>
<section xml:id="_todoリストから始めるテスト駆動開発">
<title>TODOリストから始めるテスト駆動開発</title>
<section xml:id="_todoリスト">
<title>TODOリスト</title>
<simpara>プログラムを作成するにあたってまず何をすればよいだろうか？私は、まず仕様の確認をして <emphasis role="strong">TODOリスト</emphasis> を作るところから始めます。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TODOリスト</simpara>
<simpara>何をテストすべきだろうか----着手する前に、必要になりそうなテストをリストに書き出しておこう。</simpara>
</blockquote>
<simpara>仕様</simpara>
<literallayout class="monospaced">1 から 100 までの数をプリントするプログラムを書け。
ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、
3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。</literallayout>
<simpara>仕様の内容をそのままプログラムに落とし込むには少しサイズが大きいようですね。なので最初の作業は仕様を <emphasis role="strong">TODOリスト</emphasis> に分解する作業から着手することにしましょう。仕様をどのようにTODOに分解していくかは <link xl:href="https://channel9.msdn.com/Events/de-code/2017/DO03?ocid=player">50 分でわかるテスト駆動開発</link> の26分あたりを参考にしてください。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
</listitem>
<listitem>
<simpara>3 の倍数のときは数の代わりに｢Fizz｣と返す</simpara>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<simpara>まず <literal>数を文字列にして返す</literal> 作業に取り掛かりたいのですがまだプログラミング対象としてはサイズが大きいようですね。もう少し具体的に分割しましょう。</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>これならプログラムの対象として実装できそうですね。</simpara>
</section>
</section>
<section xml:id="_テストファーストから始めるテスト駆動開発">
<title>テストファーストから始めるテスト駆動開発</title>
<section xml:id="_テストファースト">
<title>テストファースト</title>
<simpara>最初にプログラムする対象を決めたので早速プロダクトコードを実装・・・ではなく <emphasis role="strong">テストファースト</emphasis> で作業を進めていきましょう。まずはプログラムを実行するための準備作業を進める必要がありますね。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>テストファースト</simpara>
<simpara>いつテストを書くべきだろうか----それはテスト対象のコードを書く前だ。</simpara>
</blockquote>
<simpara>では、どうやってテストすればいいでしょうか？テスティングフレームワークを使って自動テストを書きましょう。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>テスト（名詞）
どうやってソフトウェアをテストすればよいだろか----自動テストを書こう。</simpara>
</blockquote>
<simpara>今回Rubyのテスティングフレームワークには <link xl:href="http://docs.seattlerb.org/minitest/">Minitest</link> を利用します。Minitestの詳しい使い方に関しては <emphasis>Minitestの基本</emphasis> <xref linkend="pruby"/>を参照してください。
では、まず以下の内容のテキストファイルを作成して <literal>main.rb</literal> で保存します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'

class HelloTest &lt; Minitest::Test
  def test_greeting
    assert_equal 'hello world', greeting
  end
end

def greeting
  'hello world'
end</programlisting>
<simpara>テストを実行します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Traceback (most recent call last):
        2: from main.rb:2:in `&lt;main&gt;'
        1: from /home/gitpod/.rvm/rubies/ruby-2.5.5/lib/ruby/site_ruby/2.5.0/rubygems/core_ext/kernel_require.rb:54:in `require'
/home/gitpod/.rvm/rubies/ruby-2.5.5/lib/ruby/site_ruby/2.5.0/rubygems/core_ext/kernel_require.rb:54:in `require': cannot load such file -- minitest/reporters (LoadError)</programlisting>
<simpara>おおっと！いきなりエラーが出てきましたね。でも落ち着いてください。まず最初にやることはエラーメッセージの内容を読むことです。ここでは <literal>require': cannot load such file&#8201;&#8212;&#8201;minitest/reporters (LoadError)</literal> と表示されています。取っ掛かりとしては <link xl:href="https://www.google.com/search?sxsrf=ACYBGNTd6_rVoXXOBo2CHgs5vysIRIJaCQ%3A1579765868950&amp;source=hp&amp;ei=bFApXrCCN4Pg-Aa8v6vABw&amp;q=%60require%27%3A+cannot+load+such+file&amp;oq=%60require%27%3A+cannot+load+such+file&amp;gs_l=psy-ab.3..0l2j0i30l6.1644.1644..2069&#8230;&#8203;2.0..0.116.116.0j1&#8230;&#8203;&#8230;&#8203;0&#8230;&#8203;.2j1..gws-wiz&#8230;&#8203;..10..35i362i39.-RXoHriCPZQ&amp;ved=0ahUKEwiw6Ma7npnnAhUDMN4KHbzfCngQ4dUDCAg&amp;uact=5">エラーメッセージをキーワードに検索をする</link> というのがあります。ちなみにここでは <link xl:href="https://github.com/kern/minitest-reporters">minitest/reporters</link> というGemがインストールされていなかったため読み込みエラーが発生していたようです。サイトのInstallationを参考にGemをインストールしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ gem install minitest-reporters
Fetching minitest-reporters-1.4.2.gem
Fetching ansi-1.5.0.gem
Fetching builder-3.2.4.gem
Successfully installed ansi-1.5.0
Successfully installed builder-3.2.4
Successfully installed minitest-reporters-1.4.2
Parsing documentation for ansi-1.5.0
Installing ri documentation for ansi-1.5.0
Parsing documentation for builder-3.2.4
Installing ri documentation for builder-3.2.4
Parsing documentation for minitest-reporters-1.4.2
Installing ri documentation for minitest-reporters-1.4.2
Done installing documentation for ansi, builder, minitest-reporters after 3 seconds
3 gems installed</programlisting>
<simpara>Gemのインストールが完了したので再度実行してみましょう。今度はうまくいったようですね。Gemって何？と思ったかもしれませんがここではRubyの外部プログラム部品のようなものだと思っておいてください。<literal>minitest-reporters</literal> というのはテスト結果の見栄えを良くするための追加外部プログラムです。先程の作業ではそれを <literal>gem install</literal> コマンドでインストールしたのです。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 9701

  1/1: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00090s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストは成功しましたね。では続いてテストを失敗させてみましょう。<literal>hello world</literal> を <literal>hello world!!!</literal> に書き換えてテストを実行してみるとどうなるでしょうか。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class HelloTest &lt; Minitest::Test
  def test_greeting
    assert_equal 'hello world!!!', greeting
  end
end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 18217

 FAIL["test_greeting", #&lt;Minitest::Reporters::Suite:0x00007f98a59194f8 @name="HelloTest"&gt;, 0.0007280000027094502]
 test_greeting#HelloTest (0.00s)
        Expected: "hello world!!!"
          Actual: "hello world"
        main.rb:11:in `test_greeting'

  1/1: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00101s
1 tests, 1 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>オッケー、テスティングフレームワークが正常に読み込まれて動作することが確認できました。テストが正常に通るように戻しておきましょう。続いてバージョン管理システムのセットアップをしておきましょう。バージョン管理システム何それ？だって！？君はセーブしないでロールプレイングゲームをクリアできるのか？できないならまず <link xl:href="https://backlog.com/ja/git-tutorial/intro/01/">ここ</link> でGitを使ったバージョン管理の基本を学んでおきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git init
$ git add .
$ git commit -m 'test: セットアップ'</programlisting>
<simpara>これで <link xl:href="https://t-wada.hatenablog.jp/entry/clean-code-that-works">ソフトウェア開発の三種の神器</link>のうち <emphasis role="strong">バージョン管理</emphasis> と <emphasis role="strong">テスティング</emphasis> の準備が整いましたので <emphasis role="strong">TODOリスト</emphasis> の最初の作業に取り掛かかるとしましょう。</simpara>
</section>
<section xml:id="_仮実装">
<title>仮実装</title>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">1を渡したら文字列"1"を返す</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数の代わりに｢Fizz｣と返す</simpara>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">1を渡したら文字列"1"を返す</emphasis> プログラムを <literal>main.rb</literal> に書きましょう。最初に何を書くのかって？ アサーションを最初に書きましょう。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>アサートファースト</simpara>
<simpara>いつアサーションを書くべきだろうか----最初に書こう</simpara>
<itemizedlist>
<listitem>
<simpara>システム構築はどこから始めるべきだろうか。システム構築が終わったらこうなる、というストーリーを語るところからだ。</simpara>
</listitem>
<listitem>
<simpara>機能はどこから書き始めるべきだろうか。コードが書き終わったらこのように動く、というテストを書くところからだ。</simpara>
</listitem>
<listitem>
<simpara>ではテストはどこから書き始めるべきだろうか。それはテストの終わりにパスすべきアサーションを書くところからだ。</simpara>
</listitem>
</itemizedlist>
</blockquote>
<simpara>まず、セットアッププログラムは不要なので削除しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'</programlisting>
<simpara>テストコードを書きます。え？日本語でテストケースを書くの？ですかって。開発体制にもよりますが日本人が開発するのであれば無理に英語で書くよりドキュメントとしての可読性が上がるのでテストコードであれば問題は無いと思います。</simpara>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>テストコードを読みやすくするのは、テスト以外のコードを読みやすくするのと同じくらい大切なことだ。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'

class FizzBuzzTest &lt; Minitest::Test
  def test_1を渡したら文字列1を返す
    assert_equal '1', FizzBuzz.generate(1)
  end
end</programlisting>
<simpara>テストを実行します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 678

ERROR["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00007f956d8b6870 @name="FizzBuzzTest"&gt;, 0.0006979999998293351]
 test_1を渡したら文字列1を返す#FizzBuzzTest (0.00s)
NameError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
        Did you mean?  FizzBuzzTest
            main.rb:10:in `test_1を渡したら文字列1を返す'

  1/1: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00201s
1 tests, 0 assertions, 0 failures, 1 errors, 0 skips</programlisting>
<simpara><literal>NameError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz</literal> &#8230;&#8203;FizzBuzzが定義されていない。そうですねまだ作ってないのだから当然ですよね。では <literal>FizzBuzz::generate</literal> メソッドを作りましょう。どんな振る舞いを書けばいいのでしょうか？とりあえず最初のテストを通すために <emphasis role="strong">仮実装</emphasis> から始めるとしましょう。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>仮実装を経て本実装へ</simpara>
<simpara>失敗するテストを書いてから、最初に行う実装はどのようなものだろうか----ベタ書きの値を返そう。</simpara>
</blockquote>
<simpara><literal>FizzBuzz</literal> <emphasis role="strong">クラス</emphasis> を定義して <emphasis role="strong">文字列リテラル</emphasis> を返す <literal>FizzBuzz::generate</literal> <emphasis role="strong">クラスメソッド</emphasis> を作成しましょう。ちょっと何言ってるかわからないかもしれませんがとりあえずそんなものだと思って書いてみてください。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  def self.generate(n)
    '1'
  end
end</programlisting>
<simpara>テストが通ることを確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 60122

  1/1: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00094s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>オッケー、これでTODOリストを片付けることができました。え？こんなベタ書きのプログラムでいいの？他に考えないといけないことたくさんあるんじゃない？ばかじゃないの？と思われるかもしませんが、この細かいステップに今しばらくお付き合いいただきたい。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数の代わりに｢Fizz｣と返す</simpara>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_三角測量">
<title>三角測量</title>
<simpara>1を渡したら文字列1を返すようにできました。では、2を渡したらどうなるでしょうか？</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">2を渡したら文字列"2"を返す</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数の代わりに｢Fizz｣と返す</simpara>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  def test_1を渡したら文字列1を返す
    assert_equal '1', FizzBuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', FizzBuzz.generate(2)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 62350

 FAIL["test_2を渡したら文字列2を返す", #&lt;Minitest::Reporters::Suite:0x00007fa4968938d8 @name="FizzBuzzTest"&gt;, 0.0009390000013809185]
 test_2を渡したら文字列2を返す#FizzBuzzTest (0.00s)
        Expected: "2"
          Actual: "1"
        main.rb:17:in `test_2を渡したら文字列2を返す'

  2/2: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00179s
2 tests, 2 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが失敗しました。それは文字列1しか返さないプログラムなのだから当然ですよね。では1が渡されたら文字列1を返し、2を渡したら文字列2を返すようにプログラムを修正しましょう。 <emphasis role="strong">数値リテラル</emphasis> を <emphasis role="strong">文字列リテラル</emphasis>　に変換する必要があります。公式リファレンスで調べてみましょう。</simpara>
<simpara>Rubyの公式リファレンスは <link xl:href="https://docs.ruby-lang.org/">https://docs.ruby-lang.org/</link> です。 <link xl:href="https://docs.ruby-lang.org/ja/">日本語リファレンス</link> から <link xl:href="https://docs.ruby-lang.org/ja/search/">るりまサーチ</link>を選択してキーワード検索してみましょう。 <link xl:href="https://docs.ruby-lang.org/ja/search/query:%E6%96%87%E5%AD%97%E5%88%97%E3%80%80%E5%A4%89%E6%8F%9B/">文字列 変換</link>キーワードで検索すると <literal>to_s</literal> というキーワードが出てきました。今度は <link xl:href="https://docs.ruby-lang.org/ja/search/query:to_s/">to_s</link> で検索すると色々出てきました、どうやら <literal>to_s</literal> を使えばいいみたいですね。</simpara>
<simpara>ちなみに検索エンジンから <link xl:href="https://www.google.com/search?hl=ja&amp;sxsrf=ACYBGNRISq_mMHcQ1nGzgT3k_igW82f1Sg%3A1579494685196&amp;source=hp&amp;ei=HS0lXqnSCeeumAXN5ZigCg&amp;q=Ruby+%E6%96%87%E5%AD%97%E5%88%97%E3%80%80%E5%A4%89%E6%8F%9B&amp;oq=Ruby+%E6%96%87%E5%AD%97%E5%88%97%E3%80%80%E5%A4%89%E6%8F%9B&amp;gs_l=psy-ab.3..0i4i37l2j0i8i30l6.1386.6456..6820&#8230;&#8203;2.0..0.139.2322.1j20&#8230;&#8203;&#8230;&#8203;0&#8230;&#8203;.1..gws-wiz&#8230;&#8203;&#8230;&#8203;.0i131i4j0i4j0i131j35i39j0j0i8i4i30.FfEPbOjPZcw&amp;ved=0ahUKEwjp1IidrJHnAhVnF6YKHc0yBqQQ4dUDCAg&amp;uact=5">Ruby 文字列 変換</link>で検索してもいろいろ出てくるのですがすべてのサイトが必ずしも正確な説明をしているまたは最新のバージョンに対応しているとは限らないので始めは公式リファレンスや市販の書籍から調べる癖をつけておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  def self.generate(n)
    n.to_s
  end
end</programlisting>
<simpara>テストを実行します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 42479

  2/2: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00098s
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが無事通りました。このように２つ目のテストによって <literal>FizzBuzz::generate</literal> メソッドの一般化を実現することができました。このようなアプローチを <emphasis role="strong">三角測量</emphasis> と言います。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>三角測量</simpara>
<simpara>テストから最も慎重に一般化を引き出すやり方はどのようなものだろうか----２つ以上の例があるときだけ、一般化を行うようにしよう。</simpara>
</blockquote>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><phrase role="line-through">数を文字列にして返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら文字列"2"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数の代わりに｢Fizz｣と返す</simpara>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<simpara>たかが <emphasis role="strong">数を文字列にして返す</emphasis> プログラムを書くのにこんなに細かいステップを踏んでいくの？と思ったかもしれません。プログラムを書くということは細かいステップを踏んで行くことなのです。そして、細かいステップを踏み続けることが大切なことなのです。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TDDで大事なのは、細かいステップを踏むことではなく、細かいステップを踏み続けられるようになることだ。</simpara>
</blockquote>
<simpara>あと、テストケースの内容がアサーション一行ですがもっと検証するべきことがあるんじゃない？と思うでしょう。検証したいことがあれば独立したテストケースを追加しましょう。このような書き方はよろしくありません。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def test_数字を渡したら文字列を返す
    assert_equal '1', FizzBuzz.generate(1)
    assert_equal '2', FizzBuzz.generate(2)
    assert_equal '3', FizzBuzz.generate(3)
    assert_equal '4', FizzBuzz.generate(4)
    assert_equal '5', FizzBuzz.generate(5)
  end
...</programlisting>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>テストの本質というのは、「こういう状況と入力から、こういう振る舞いと出力を期待する」のレベルまで要約できる。</simpara>
</blockquote>
<simpara>ここで一段落ついたので、これまでの作業内容をバージョン管理システムにコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'test: 数を文字列にして返す'</programlisting>
</section>
</section>
<section xml:id="_リファクタリングから始めるテスト駆動開発">
<title>リファクタリングから始めるテスト駆動開発</title>
<section xml:id="_リファクタリング">
<title>リファクタリング</title>
<simpara>ここでテスト駆動開発の流れを確認しておきましょう。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<orderedlist numeration="arabic">
<listitem>
<simpara>レッド：動作しない、おそらく最初のうちはコンパイルも通らないテストを１つ書く。</simpara>
</listitem>
<listitem>
<simpara>グリーン:そのテストを迅速に動作させる。このステップでは罪を犯してもよい。</simpara>
</listitem>
<listitem>
<simpara>リファクタリング:テストを通すために発生した重複をすべて除去する。</simpara>
</listitem>
</orderedlist>
<simpara>レッド・グリーン・リファクタリング。それがTDDのマントラだ。</simpara>
</blockquote>
<simpara>コードはグリーンの状態ですが <emphasis role="strong">リファクタリング</emphasis> を実施していませんね。重複を除去しましょう。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>リファクタリング(名詞) 外部から見たときの振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版
</attribution>
<simpara>リファクタリングする(動詞) 一連のリファクタリングを適用して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること。</simpara>
</blockquote>
<section xml:id="_メソッドの抽出">
<title>メソッドの抽出</title>
<simpara>テストコードを見てください。テストを実行するにあたって毎回前準備を実行する必要があります。こうした処理は往々にして同じ処理を実行するものなので <emphasis role="strong">メソッドの抽出</emphasis> を適用して重複を除去しましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>メソッドの抽出</simpara>
<simpara>ひとまとめにできるコードの断片がある。</simpara>
<simpara>コードの断片をメソッドにして、それを目的を表すような名前をつける。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  def test_1を渡したら文字列1を返す
    assert_equal '1', FizzBuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', FizzBuzz.generate(2)
  end
end</programlisting>
<simpara>テストフレームワークでは前処理にあたる部分を実行する機能がサポートされています。Minitestでは <literal>setup</literal> メソッドがそれに当たるので <literal>FizzBuzz</literal> オブジェクトを共有して共通利用できるようにしてみましょう。ここでは <emphasis role="strong">インスタンス変数</emphasis> に <literal>FizzBuzz</literal> <emphasis role="strong">クラス</emphasis> の参照を <emphasis role="strong">代入</emphasis> して各テストメソッドで共有できるようにしました。ちょっと何言ってるかわからないかもしれませんがここではそんなことをやってるぐらいのイメージで大丈夫です。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  def setup
    @fizzbuzz = FizzBuzz
  end

  def test_1を渡したら文字列1を返す
    assert_equal '1', @fizzbuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', @fizzbuzz.generate(2)
  end
end</programlisting>
<simpara>テストプログラムを変更してしまいましたが壊れていないでしょうか？確認するにはどうすればいいでしょう？
テストを実行して確認すればいいですよね。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 33356

  2/2: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00083s
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>オッケー、前回コミットした時と同じグリーンの状態のままですよね。区切りが良いのでここでコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor: メソッドの抽出'</programlisting>
</section>
<section xml:id="_変数名の変更">
<title>変数名の変更</title>
<simpara>もう一つ気になるところがあります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  def self.generate(n)
    n.to_s
  end
end</programlisting>
<simpara>引数の名前が <literal>n</literal> ですね。コンピュータにはわかるかもしれませんが人間が読むコードとして少し不親切です。特にRubyのような動的言語では型が明確に定義されないのでなおさらです。ここは <emphasis role="strong">変数名の変更</emphasis> を適用して人間にとって読みやすいコードにリファクタリングしましょう。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>コンパイラがわかるコードは誰にでも書ける。すぐれたプログラマは人間にとってわかりやすいコードを書く。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>名前は短いコメントだと思えばいい。短くてもいい名前をつければ、それだけ多くの情報を伝えることができる。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  def self.generate(number)
    number.to_s
  end
end</programlisting>
<simpara>続いて、変更で壊れていないかを確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 33356

  2/2: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00083s
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>オッケー、この時点でテストコードとプロダクトコードを変更しましたがその変更はすでに作成した自動テストによって壊れていないことを簡単に確認することができました。え、こんな簡単な変更でプログラムが壊れるわけないじゃん、ドジっ子なの？ですって。残念ながら私は絶対ミスしない完璧な人間ではないし、どちらかといえば注意力の足りないプログラマなのでこんな間違いも普通にやらかします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  def self.generate(number)
    numbr.to_s
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 59453

ERROR["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x0000564f6b1dfc70 @name="FizzBuzzTest"&gt;, 0.001019135997921694]
 test_1を渡したら文字列1を返す#FizzBuzzTest (0.00s)
NameError:         NameError: undefined local variable or method `numbr' for FizzBuzz:Class
        Did you mean?  number
            main.rb:21:in `generate'
            main.rb:11:in `test_1を渡したら文字列1を返す'

ERROR["test_2を渡したら文字列2を返す", #&lt;Minitest::Reporters::Suite:0x0000564f6b1985f0 @name="FizzBuzzTest"&gt;, 0.003952859999117209]
 test_2を渡したら文字列2を返す#FizzBuzzTest (0.00s)
NameError:         NameError: undefined local variable or method `numbr' for FizzBuzz:Class
        Did you mean?  number
            main.rb:21:in `generate'
            main.rb:15:in `test_2を渡したら文字列2を返す'

  2/2: [====================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00746s
2 tests, 0 assertions, 0 failures, 2 errors, 0 skips</programlisting>
<simpara>最初にプロダクトコードを書いて一通りの機能を作ってから動作を確認する進め方だとこの手の間違いはいつどこで作り込んだのかわからなくなるため原因の調査に時間がかかり残念な経験をしたドジっ子プログラマは変更なんてするもんじゃないと思いコードを変更することに不安を持つようになるでしょう。でも、テスト駆動開発ならそんなドジっ子プログラマでも自動テストと小さなステップのおかげで上記のようなしょうもない間違いもすぐに見つけてすぐに対応することができるのでコードを変更する勇気を持つことができるのです。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>テスト駆動開発は、プログラミング中の不安をコントロールする手法だ。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>リファクタリングでは小さなステップでプログラムを変更していく。そのため間違ってもバグを見つけるのは簡単である。</simpara>
</blockquote>
<simpara>このグリーンの状態にいつでも戻れるようにコミットして次の <emphasis role="strong">TODOリスト</emphasis> の内容に取り掛かるとしましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor: 変数名の変更'</programlisting>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>リファクタリングが成功するたびにコミットしておけば、たとえ壊してしまったとしても、動いていた状態に戻すことができます。変更をコミットしておき、意味のある単位としてまとまってから、共有のリポジトリに変更をプッシュすればよいのです。</simpara>
</blockquote>
</section>
</section>
<section xml:id="_明白な実装">
<title>明白な実装</title>
<simpara>次は <emphasis role="strong">3を渡したら文字列"Fizz"</emphasis> を返すプログラムに取り組むとしましょう。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">数を文字列にして返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら文字列"2"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数の代わりに｢Fizz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">3を渡したら文字列"Fizz"を返す</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<simpara>まずは、<emphasis role="strong">テストファースト</emphasis> <emphasis role="strong">アサートファースト</emphasis> で小さなステップで進めていくんでしたよね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def test_3を渡したら文字列Fizzを返す
    assert_equal 'Fizz', @fizzbuzz.generate(3)
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 7095

 FAIL["test_3を渡したら文字列Fizzを返す", #&lt;Minitest::Reporters::Suite:0x00007fbadf865f50 @name="FizzBuzzTest"&gt;, 0.017029999995429534]
 test_3を渡したら文字列Fizzを返す#FizzBuzzTest (0.02s)
        --- expected
        +++ actual
        @@ -1 +1,3 @@
        -"Fizz"
        +# encoding: US-ASCII
        +#    valid: true
        +"3"
        main.rb:19:in `test_3を渡したら文字列Fizzを返す'

  3/3: [======================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.05129s
3 tests, 3 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>さて、失敗するテストを書いたので次はテストを通すためのプロダクトコードを書くわけですがどうしましょうか？　<emphasis role="strong">仮実装</emphasis>　でベタなコードを書きますか？実現したい振る舞いは <literal>もし3を渡したらならば文字列Fizzを返す</literal> です。英語なら <literal>If number is 3, result is Fizz</literal> といったところでしょうか。ここは <emphasis role="strong">明白な実装</emphasis> で片付けた方が早いでしょう。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>明白な実装</simpara>
<simpara>シンプルな操作を実現するにはどうすればいいだろうか----そのまま実装しよう。</simpara>
<simpara>仮実装や三角測量は、細かく細かく刻んだ小さなステップだ。だが、ときには実装をどうすべきか既に見えていることが。
そのまま進もう。例えば先ほどのplusメソッドくらいシンプルなものを仮実装する必要が本当にあるだろうか。
普通は、その必要はない。頭に浮かんだ明白な実装をただ単にコードに落とすだけだ。もしもレッドバーが出て驚いたら、あらためてもう少し歩幅を小さくしよう。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    number.to_s
  end
end</programlisting>
<simpara>ここでは <emphasis role="strong">if式</emphasis> と <emphasis role="strong">演算子</emphasis> を使ってみましょう。なんかプログラムっぽくなってきましたね。
3で割で割り切れる場合はFizzを返すということは <emphasis role="strong">数値リテラル</emphasis> 3で割った余りが0の場合は <emphasis role="strong">文字列リテラル</emphasis> Fizzを返すということなので余りを求める <emphasis role="strong">演算子</emphasis> を調べる必要がありますね。公式リファレンスで <emphasis role="strong">算術演算子</emphasis> をキーワードで検索したところ <link xl:href="https://docs.ruby-lang.org/ja/search/query:%E7%AE%97%E8%A1%93%E6%BC%94%E7%AE%97%E5%AD%90/">いろいろ</link>出てきました。 <link xl:href="https://docs.ruby-lang.org/ja/search/query:%E7%AE%97%E8%A1%93%E6%BC%94%E7%AE%97%E5%AD%90/query:%25/">%</link>を使えばいいみたいですね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number % 3 == 0
       result = 'Fizz'
    end
    result
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 37722

  3/3: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00256s
3 tests, 3 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストがグリーンになったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'test: 3を渡したら文字列Fizzを返す'</programlisting>
<section xml:id="_アルゴリズムの置き換え">
<title>アルゴリズムの置き換え</title>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">数を文字列にして返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><phrase role="line-through">2を渡したら文字列"2"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3 の倍数のときは数の代わりに｢Fizz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"Fizz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"Buzz"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number % 3 == 0
       result = 'Fizz'
    end
    result
  end
end</programlisting>
<simpara>レッド・グリーンときたので次はリファクタリングですね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
       result = 'Fizz'
    end
    result
  end
end</programlisting>
<simpara>ここでは <emphasis role="strong">アルゴリズムの置き換え</emphasis> を適用します。 <emphasis role="strong">メソッドチェーンと述語メソッド</emphasis> を使ってRubyらしい書き方にリファクタリングしてみました。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>アルゴリズムの取り替え</simpara>
<simpara>アルゴリズムをよりわかりやすいものに置き換えたい。</simpara>
<simpara>メソッドの本体を新たなアルゴリズムで置き換える。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>メソッドチェーンは言葉の通り、メソッドを繋げて呼び出す方法です。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>述語メソッドとはメソッド名の末尾に「？」をつけたメソッドのことを指します。</simpara>
</blockquote>
<simpara>リファクタリングによりコードが壊れていないかを確認したらコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 42180

  3/3: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00501s
3 tests, 3 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor: アルゴリズムの置き換え'</programlisting>
<simpara>だんだんとリズムに乗ってきました。ここはギアを上げて <emphasis role="strong">明白な実装</emphasis> で引き続き <emphasis role="strong">TODOリスト</emphasis> の内容を片付けていきましょう。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">数を文字列にして返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら文字列"2"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3の倍数のときは数の代わりに｢Fizz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"Fizz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">5を渡したら文字列"Buzz"を返す</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">テストファースト</emphasis> <emphasis role="strong">アサートファースト</emphasis> で最初に失敗するテストを書いて</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def test_5を渡したら文字列Buzzを返す
    assert_equal 'Buzz', @fizzbuzz.generate(5)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 46876

 FAIL["test_5を渡したら文字列Buzzを返す", #&lt;Minitest::Reporters::Suite:0x0000560f86b93700 @name="FizzBuzzTest"&gt;, 0.007562776008853689]
 test_5を渡したら文字列Buzzを返す#FizzBuzzTest (0.01s)
        --- expected
        +++ actual
        @@ -1 +1,2 @@
        -"Buzz"
        +# encoding: US-ASCII
        +"5"
        main.rb:23:in `test_5を渡したら文字列Buzzを返す'

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00849s
4 tests, 4 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara><emphasis role="strong">if/elsif/else式</emphasis> を使って条件分岐を追加しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
       result = 'Fizz'
    end
    result
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 31468

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00158s
4 tests, 4 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが通ったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'test: 5を渡したら文字列Buzzを返す'</programlisting>
</section>
<section xml:id="_メソッドのインライン化">
<title>メソッドのインライン化</title>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">数を文字列にして返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら文字列"2"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3の倍数のときは数の代わりに｢Fizz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"Fizz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><phrase role="line-through">5を渡したら文字列"Buzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  def setup
    @fizzbuzz = FizzBuzz
  end

  def test_1を渡したら文字列1を返す
    assert_equal '1', @fizzbuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', @fizzbuzz.generate(2)
  end

  def test_3を渡したら文字列Fizzを返す
    assert_equal 'Fizz', @fizzbuzz.generate(3)
  end

  def test_5を渡したら文字列Buzzを返す
    assert_equal 'Buzz', @fizzbuzz.generate(5)
  end
end</programlisting>
<simpara>まずグループのアウトラインを作ってテストが壊れないかを確認します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  describe 'FizzBuzz' do
    describe '三の倍数の場合' do
    end

    describe '五の倍数の場合' do
    end

    describe 'その他の場合' do
    end
  end

  def setup
    @fizzbuzz = FizzBuzz
  end

  def test_1を渡したら文字列1を返す
    assert_equal '1', @fizzbuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', @fizzbuzz.generate(2)
  end

  def test_3を渡したら文字列Fizzを返す
    assert_equal 'Fizz', @fizzbuzz.generate(3)
  end

  def test_5を渡したら文字列Buzzを返す
    assert_equal 'Buzz', @fizzbuzz.generate(5)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 39239

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00195s
4 tests, 4 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>壊れいないことを確認したらセットアップメソッドをまず移動してテストします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  describe 'FizzBuzz' do
    def setup
      @fizzbuzz = FizzBuzz
    end

    describe '三の倍数の場合' do
    end

    describe '五の倍数の場合' do
    end

    describe 'その他の場合' do
    end
  end

  def test_1を渡したら文字列1を返す
    assert_equal '1', @fizzbuzz.generate(1)
  end

  def test_2を渡したら文字列2を返す
    assert_equal '2', @fizzbuzz.generate(2)
  end

  def test_3を渡したら文字列Fizzを返す
    assert_equal 'Fizz', @fizzbuzz.generate(3)
  end

  def test_5を渡したら文字列Buzzを返す
    assert_equal 'Buzz', @fizzbuzz.generate(5)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 53111

ERROR["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00005603cac658f8 @name="FizzBuzzTest"&gt;, 0.0027922230074182153]
 test_1を渡したら文字列1を返す#FizzBuzzTest (0.00s)
NoMethodError:         NoMethodError: undefined method `generate' for nil:NilClass
            main.rb:22:in `test_1を渡したら文字列1を返す'

ERROR["test_3を渡したら文字列Fizzを返す", #&lt;Minitest::Reporters::Suite:0x00005603cac83e98 @name="FizzBuzzTest"&gt;, 0.00590475500212051]
 test_3を渡したら文字列Fizzを返す#FizzBuzzTest (0.01s)
NoMethodError:         NoMethodError: undefined method `generate' for nil:NilClass
            main.rb:30:in `test_3を渡したら文字列Fizzを返す'

ERROR["test_5を渡したら文字列Buzzを返す", #&lt;Minitest::Reporters::Suite:0x00005603cac85ec8 @name="FizzBuzzTest"&gt;, 0.008002811024198309]
 test_5を渡したら文字列Buzzを返す#FizzBuzzTest (0.01s)
NoMethodError:         NoMethodError: undefined method `generate' for nil:NilClass
            main.rb:34:in `test_5を渡したら文字列Buzzを返す'

ERROR["test_2を渡したら文字列2を返す", #&lt;Minitest::Reporters::Suite:0x00005603cac97e20 @name="FizzBuzzTest"&gt;, 0.010200971009908244]
 test_2を渡したら文字列2を返す#FizzBuzzTest (0.01s)
NoMethodError:         NoMethodError: undefined method `generate' for nil:NilClass
            main.rb:26:in `test_2を渡したら文字列2を返す'

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01247s
4 tests, 0 assertions, 0 failures, 4 errors, 0 skips</programlisting>
<simpara>テストが失敗しました。これは <emphasis role="strong">インスタンス変数</emphasis> <literal>@fizzbuzz</literal> のスコープから外れたため <literal>FizzBuzz::generate</literal> メソッド呼び出しに失敗したようです。テストメソッドを移動して変数のスコープ範囲に入れましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  describe 'FizzBuzz' do
    def setup
      @fizzbuzz = FizzBuzz
    end

    describe '三の倍数の場合' do
      def test_3を渡したら文字列Fizzを返す
        assert_equal 'Fizz', @fizzbuzz.generate(3)
      end
    end

    describe '五の倍数の場合' do
      def test_5を渡したら文字列Buzzを返す
        assert_equal 'Buzz', @fizzbuzz.generate(5)
      end
    end

    describe 'その他の場合' do
      def test_1を渡したら文字列1を返す
        assert_equal '1', @fizzbuzz.generate(1)
      end

      def test_2を渡したら文字列2を返す
        assert_equal '2', @fizzbuzz.generate(2)
      end
    end
  end
end</programlisting>
<simpara>すべてのメソッドを移動したら確認しましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 20627

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00212s
4 tests, 4 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>ここでは、<emphasis role="strong">メソッドのインライン化</emphasis> を適用してしてテストコードを読みやすくすることにしました。テストコードの <emphasis role="strong">自己文書化</emphasis> により動作する仕様書にすることができました。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>メソッドのインライン化</simpara>
<simpara>メソッドの本体が、名前をつけて呼ぶまでもなく明らかである。</simpara>
<simpara>メソッド本体の呼び出し元にインライン化して、メソッドを除去する</simpara>
</blockquote>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>混乱せずに読めるテストコードを目指すなら（コンピュータではなく人のためにテストを書いていることを忘れてはならない）、テストメソッドの長さは３行を目指そう。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>この関数名は「自己文書化」されている。関数名はいろんなところで使用されるのだから、優れたコメントよりも名前のほうが大切だ。</simpara>
</blockquote>
<simpara>テストも無事通るようになったのでコミットしておきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor: メソッドのインライン化'</programlisting>
<simpara>さあ、<emphasis role="strong">TODOリスト</emphasis> もだいぶ消化されてきましたね。もうひと踏ん張りです。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">数を文字列にして返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら文字列"2"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3の倍数のときは数の代わりに｢Fizz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"Fizz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">5 の倍数のときは｢Buzz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"Buzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">15を渡したら文字列FizzBuzzを返す</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>1 から 100 までの数</simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<simpara>初めに失敗するテストを書きます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '三と五の倍数の場合' do
      def test_15を渡したら文字列FizzBuzzを返す
        assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
      end
    end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 16335

 FAIL["test_15を渡したら文字列FizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x000056344a3be2a8 @name="FizzBuzz::三と五の倍数の場合"&gt;, 0.006737435003742576]
 test_15を渡したら文字列FizzBuzzを返す#FizzBuzz::三と五の倍数の場合 (0.01s)
        Expected: "FizzBuzz"
          Actual: "Fizz"
        main.rb:25:in `test_15を渡したら文字列FizzBuzzを返す'

  5/5: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01347s
5 tests, 5 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>続いて先程と同様に条件分岐を追加しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    elsif number.modulo(15).zero?
      result = 'FizzBuzz'
    end
    result
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 45982

 FAIL["test_15を渡したら文字列FizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x00007f822c00b2b0 @name="FizzBuzz::三と五の倍数の場合"&gt;, 0.00231200000
0529224]
 test_15を渡したら文字列FizzBuzzを返す#FizzBuzz::三と五の倍数の場合 (0.00s)
        Expected: "FizzBuzz"
          Actual: "Fizz"
        main.rb:25:in `test_15を渡したら文字列FizzBuzzを返す'

  4/4: [======================================================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00964s
4 tests, 4 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>おっと、調子に乗って <emphasis role="strong">明白な実装</emphasis> をしていたら怒られてしまいました。ここは一旦ギアを下げて小さなステップで何が問題かを調べることにしましょう。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>明白な実装はセカンドギアだ。頭で考えていることがうまくコードに落とせないときは、ギアを下げる用意をしよう。</simpara>
</blockquote>
<simpara>調べるにあたってコードを頭から読んでもいいのですが、問題が発生したのは <literal>15を渡したら文字列FizzBuzzを返す</literal> テストを追加したあとですよね？ということは原因は追加したコードにあるはずですよね？よって、追加部分をデバッグすれば原因をすぐ発見できると思いませんか？</simpara>
<simpara>今回はRubyのデバッガとしてByebugをインストールして使うことにしましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ gem install byebug</programlisting>
<simpara>インストールが完了したら早速Byebugからプログラムを起動して動作を確認してみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ byebug main.rb

[1, 10] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
=&gt;  1: require 'minitest/reporters'
    2: Minitest::Reporters.use!
    3: require 'minitest/autorun'
    4:
    5: class FizzBuzzTest &lt; Minitest::Test
    6:   describe 'FizzBuzz' do
    7:     def setup
    8:       @fizzbuzz = FizzBuzz
    9:     end
   10:
(byebug)</programlisting>
<simpara>詳しい操作に関しては <link xl:href="https://qiita.com/jnchito/items/5aaf323ab4f24b526a61">printデバッグにさようなら！Ruby初心者のためのByebugチュートリアル</link> を参照してください。</simpara>
<simpara>では、問題の原因を調査するためbyebugメソッドでコード内にブレークポイントを埋め込んでデバッガを実行してみましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '三と五の倍数の場合' do
      def test_15を渡したら文字列FizzBuzzを返す
        require 'byebug'
        byebug
        assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
      end
    end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ byebug main.rb

[1, 10] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
=&gt;  1: require 'minitest/reporters'
    2: Minitest::Reporters.use!
    3: require 'minitest/autorun'
    4:
    5: class FizzBuzzTest &lt; Minitest::Test
    6:   describe 'FizzBuzz' do
    7:     def setup
    8:       @fizzbuzz = FizzBuzz
    9:     end
   10:</programlisting>
<simpara>ブレークポイントまで <literal>continue</literal> コマンドで処理を進めます。<literal>continue</literal> コマンドは <literal>c</literal> でもいけます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) c
   22:
   23:     describe '三と五の倍数の場合' do
   24:       def test_15を渡したら文字列FizzBuzzを返す
   25:         require 'byebug'
   26:         byebug
=&gt; 27:         assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
   28:       end
   29:     end
   30:
   31:     describe 'その他の場合' do</programlisting>
<simpara>続いて問題が発生した <literal>@fizzbuzz.generate(15)</literal> メソッド内にステップインします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) s
   36:   end
   37: end
   38:
   39: class FizzBuzz
   40:   def self.generate(number)
=&gt; 41:     result = number.to_s
   42:     if number.modulo(3).zero?
   43:       result = 'Fizz'
   44:     elsif number.modulo(5).zero?
   45:       result = 'Buzz'</programlisting>
<simpara>引数の <literal>number</literal> は <literal>15</literal> だから <literal>elsif number.modulo(15).zero?</literal> の行で判定されるはず・・・</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) s
   37: end
   38:
   39: class FizzBuzz
   40:   def self.generate(number)
   41:     result = number.to_s
=&gt; 42:     if number.modulo(3).zero?
   43:       result = 'Fizz'
   44:     elsif number.modulo(5).zero?
   45:       result = 'Buzz'
   46:     elsif number.modulo(15).zero?
(byebug) s
   38:
   39: class FizzBuzz
   40:   def self.generate(number)
   41:     result = number.to_s
   42:     if number.modulo(3).zero?
=&gt; 43:       result = 'Fizz'</programlisting>
<simpara>ファッ！？</simpara>
<programlisting language="bash" linenumbering="unnumbered">   44:     elsif number.modulo(5).zero?
   45:       result = 'Buzz'
   46:     elsif number.modulo(15).zero?
   47:       result = 'FizzBuzz'
(byebug) result
"15"
(byebug) q!</programlisting>
<simpara>15は3で割り切れるから最初の判定で処理されますよね。まあ、常にコードに注意を払って頭の中で処理しながらコードを書いていればこんなミスすることは無いのでしょうが私はドジっ子プログラマなので計算機ができることは計算機にやらせて間違いがあれば原因を調べて解決するようにしています。とりあえず、テストを通るようにしておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
      if number.modulo(15).zero?
        result = 'FizzBuzz'
      end
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 24862

  5/5: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00279s
5 tests, 5 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが通ったのでコミットしておきます。コミットログにバグは残らないのですが作業の合間ではバグを作り込んでいましたよね。でも、テストがすぐに教えてくれるのですぐに修正することができました。結果として私のようなドジっ子プログラマでもバグの無いコードを書いているかのように見えるんですよ。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'test: 15を渡したら文字列FizzBuzzを返す'</programlisting>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>私はテスト駆動開発を長年行っているので、他人にミスを気づかれる前に、自分の誤りを修正できるだけなのだ。</simpara>
</blockquote>
<simpara>先程のコードですが・・・</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero?
      result = 'Fizz'
      if number.modulo(15).zero?
        result = 'FizzBuzz'
      end
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end</programlisting>
<simpara><emphasis role="strong">if式</emphasis> の中でさらに <emphasis role="strong">if式</emphasis> をネストしています。いわゆる <emphasis role="strong">コードの不吉な臭い</emphasis> がしますね。ここは仕様の文言にある <literal>3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。</literal> に沿った記述にするとともにネストした部分をわかりやすくするために <emphasis role="strong">アルゴリズムの置き換え</emphasis> を適用してリファクタリングをしましょう。</simpara>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>ネストの深いコードは理解しにくい。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end
end</programlisting>
<simpara>テストして、</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 48529

  5/5: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00329s
5 tests, 5 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>コミットです。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor: アルゴリズムの置き換え'</programlisting>
</section>
</section>
<section xml:id="_休憩">
<title>休憩</title>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">数を文字列にして返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら文字列"2"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3の倍数のときは数の代わりに｢Fizz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"Fizz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">5 の倍数のときは｢Buzz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"Buzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">15を渡したら文字列FizzBuzzを返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">1 から 100 までの数</emphasis></simpara>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<simpara>数を引数にして文字列を返す <literal>FizzBuzz::generate</literal> メソッドはできたみたいですね。次のやることは・・・新しいメソッドを追加する必要がありそうです。気分を切り替えるため少し休憩を取りましょう。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>疲れたり手詰まりになったりしたときはどうすればいいだろうか----休憩を取ろう。</simpara>
</blockquote>
<simpara>引き続き <emphasis role="strong">TODOリスト</emphasis> を片付けたいのですが <literal>1から100までの数</literal> を返すプログラムを書かないといけません。3を渡したらFizzのような <emphasis role="strong">リテラル</emphasis> を返すプログラムではなく 1から100までの <emphasis role="strong">配列オブジェクト</emphasis> を返すようなプログラムにする必要がありそうです。<emphasis role="strong">TODOリスト</emphasis> にするとこんな感じでしょうか。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>1 から 100 までの数の配列を返す</simpara>
<itemizedlist>
<listitem>
<simpara>配列の初めは文字列の1を返す</simpara>
</listitem>
<listitem>
<simpara>配列の最後は文字列の100を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<simpara>どうやら <emphasis role="strong">配列オブジェクト</emphasis> を返すプログラムを書かないといけないようですね。え？ <emphasis role="strong">明白な実装</emphasis> の実装イメージがわかない。そんな時はステップを小さくして <emphasis role="strong">仮実装</emphasis> から始めるとしましょう。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>何を書くべきかわかっているときは、明白な実装を行う。わからないときには仮実装を行う。まだ正しい実装が見えてこないなら、三角測量を行う。それでもまだわからないなら、シャワーを浴びに行こう。</simpara>
</blockquote>
</section>
<section xml:id="_学習用テスト">
<title>学習用テスト</title>
<section xml:id="_配列">
<title>配列</title>
<simpara><emphasis role="strong">テストファースト</emphasis> でまずRubyの <emphasis role="strong">配列</emphasis> の振る舞いを確認していきましょう。公式リファレンスによるとRubyでは <link xl:href="https://docs.ruby-lang.org/ja/latest/class/Array.html">Arrayクラスとして定義されている</link>ようですね。空の配列を作るには <literal>[]</literal> (配列リテラル)を使えばいいみたいですね。こんな感じかな？</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = []
        assert_equal '1', result
      end
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 54004

 FAIL["test_配列の初めは文字列の1を返す", #&lt;Minitest::Reporters::Suite:0x00007fd0fb93d540 @name="FizzBuzz::1から
100までの数の配列を返す"&gt;, 0.0016740000028221402]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "1"
          Actual: []
        main.rb:37:in `test_配列の初めは文字列の1を返す'

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00602s
5 tests, 5 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>これは同値ではないのはわかりますね。ではこうしたらどうなるでしょうか？</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = ['1']
        assert_equal '1', result
      end
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 32701

 FAIL["test_配列の初めは文字列の1を返す", #&lt;Minitest::Reporters::Suite:0x00007fb36f096030 @name="FizzBuzz::1から100までの数の配列を返す"&gt;, 0.0018850000014936086]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "1"
          Actual: ["1"]
        main.rb:38:in `test_配列の初めは文字列の1を返す'

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04383s
5 tests, 5 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara><emphasis role="strong">配列</emphasis> には <link xl:href="https://docs.ruby-lang.org/ja/latest/class/Array.html">要素を操作するメソッドが用意されており</link>内容を色々操作できそうですね。でも、いちいちテストコードを編集してテストを実行させるのも面倒なのでここはデバッガを使ってみましょう。まずブレークポイントを設定して・・・</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        require 'byebug'
        byebug
        result = ['1']
        assert_equal '1', result
      end
    end
  end
end</programlisting>
<simpara>デバッガを起動します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ byebug main.rb

[1, 10] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
=&gt;  1: require 'minitest/reporters'
    2: Minitest::Reporters.use!
    3: require 'minitest/autorun'
    4:
    5: class FizzBuzzTest &lt; Minitest::Test
    6:   describe 'FizzBuzz' do
    7:     def setup
    8:       @fizzbuzz = FizzBuzz
    9:     end
   10:
(byebug)</programlisting>
<simpara>continueでブレークポイントまで進めます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) c
Started with run options --seed 15764

  /0: [=---=---=---=---=---=---=---=---=---=---=---=---=---=---=---=---=---=-] 0% Time: 00:00:00,  ETA: ??:??:??
[34, 43] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
   34:
   35:     describe '1から100までの数の配列を返す' do
   36:       def test_配列の初めは文字列の1を返す
   37:         require 'byebug'
   38:         byebug
=&gt; 39:         result = ['1']
   40:         assert_equal '1', result
   41:       end
   42:     end
   43:   end</programlisting>
<simpara>ステップインして <literal>result</literal> の中身を確認してみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) s

[35, 44] in /Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/main.rb
   35:     describe '1から100までの数の配列を返す' do
   36:       def test_配列の初めは文字列の1を返す
   37:         require 'byebug'
   38:         byebug
   39:         result = ['1']
=&gt; 40:         assert_equal '1', result
   41:       end
   42:     end
   43:   end
   44: end
(byebug) result
["1"]</programlisting>
<simpara>添字を指定して <emphasis role="strong">配列</emphasis> の最初の文字列を確認してみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) result
["1"]
(byebug) result[1]
nil</programlisting>
<simpara>おや？１番目は"1"では無いようですね。<emphasis role="strong">配列</emphasis> は0から始まるので1番目を指定するにはこうします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) result
["1"]
(byebug) result[1]
nil
(byebug) result[0]
"1"</programlisting>
<simpara>続いて、複数の文字列から構成される <emphasis role="strong">配列</emphasis> を作ってみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) result = ['1','2','3']
["1", "2", "3"]
(byebug) result[0]
"1"
(byebug) result[2]
"3"</programlisting>
<simpara>ちなみにRubyだとこのように表記することができます。直感的でわかりやすくないですか？</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) result
["1", "2", "3"]
(byebug) result.first
"1"
(byebug) result.last
"3"</programlisting>
<simpara>最後に追加、削除、変更をやってみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) result = ['1','2','3']
["1", "2", "3"]
(byebug) result &lt;&lt; '4'
["1", "2", "3", "4"]
(byebug) result.push('4')
["1", "2", "3", "4", "4"]
(byebug) result.delete_at(3)
"4"
(byebug) result
["1", "2", "3", "4"]
(byebug) result[2] = '30'
"30"
(byebug) result
["1", "2", "30", "4"]</programlisting>
<simpara><emphasis role="strong">配列</emphasis> の振る舞いもだいぶイメージできたのでデバッガを終了させてテストコードを少し変えてみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">(byebug) q
Really quit? (y/n) y</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = ['1', '2', '3']
        assert_equal '1', result.first
        assert_equal '2', result[1]
        assert_equal '3', result.last
      end
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 39118

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00186s
5 tests, 7 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara><emphasis role="strong">変数</emphasis> <literal>result</literal> に配列を返すメソッドを作れば良さそうですね。とりあえずメソッド名は今の時点ではあまり考えずに・・・</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = FizzBuzz.print_1_to_100
        assert_equal '1', result.first
      end
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 19247

ERROR["test_配列の初めは文字列の1を返す", #&lt;Minitest::Reporters::Suite:0x00007faaea925058 @name="FizzBuzz::1から
100までの数の配列を返す"&gt;, 0.0017889999980980065]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `test_配列の初めは文字列の1を返す'

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00454s
5 tests, 4 assertions, 0 failures, 1 errors, 0 skips</programlisting>
<simpara>ここまでくれば <emphasis role="strong">仮実装</emphasis> はできますね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end

  def self.print_1_to_100
    [1, 2, 3]
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 24564

 FAIL["test_配列の初めは文字列の1を返す", #&lt;Minitest::Reporters::Suite:0x00007fefd8917060 @name="FizzBuzz::1から
100までの数の配列を返す"&gt;, 0.0011969999977736734]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "1"
          Actual: 1
        main.rb:38:in `test_配列の初めは文字列の1を返す'

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00209s
5 tests, 5 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>ファッ！？、ああ、数字ではなく文字列で返すのだからこうですね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.print_1_to_100
    ['1', '2', '3']
  end
end</programlisting>
<simpara><emphasis role="strong">%記法</emphasis> を使うとよりRubyらしく書けます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.print_1_to_100
    %w[1 2 3]
  end
end</programlisting>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>%記法とは、文字列や正規表現などを定義する際に、%を使った特別な書き方をすることでエスケープ文字を省略するなど、可読性を高めることができる記法です。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 42995

  5/5: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00195s
5 tests, 5 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara><emphasis role="strong">TODOリスト</emphasis> の１つ目を <emphasis role="strong">仮実装</emphasis> で片づけことができました。ちなみにテストコードを使ってソフトウェアの振る舞いを検証するテクニックを <emphasis role="strong">学習用テスト</emphasis> と言います。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>学習用テスト</simpara>
<simpara>チーム外の誰かが書いたソフトウェアのテストを書くのはどのようなときか----そのソフトウェアの新機能を初めて使う際に書いてみよう。</simpara>
</blockquote>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>1 から 100 までの数の配列を返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><phrase role="line-through">配列の初めは文字列の1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>配列の最後は文字列の100を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_繰り返し処理">
<title>繰り返し処理</title>
<simpara><literal>FizzBuzz::print_1_to_100</literal> メソッドはまだ最後の要素が検証されていませんね。<emphasis role="strong">三角測量</emphasis> を使って小さなステップで進めていくことにしましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までの数の配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = FizzBuzz.print_1_to_100
        assert_equal '1', result.first
      end

      def test_配列の最後は文字列の100を返す
        result = FizzBuzz.print_1_to_100
        assert_equal '100', result.last
      end
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 12031

 FAIL["test_配列の最後は文字列の100を返す", #&lt;Minitest::Reporters::Suite:0x00007fccc9828500 @name="FizzBuzz::1から100までの数の配列を返す"&gt;, 0.0018540000019129366]
 test_配列の最後は文字列の100を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "100"
          Actual: "3"
        main.rb:43:in `test_配列の最後は文字列の100を返す'

  6/6: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.02936s</programlisting>
<simpara>配列は3までなので想定通りテストは失敗します。さて、1から100までの文字列で構成される配列をどうやって作りましょうか？ 先程は <emphasis role="strong">if式</emphasis> を使って <emphasis role="strong">条件分岐</emphasis> をプログラムで実行しました。今回は <emphasis role="strong">繰り返し処理</emphasis> をプログラムで実行する必要がありそうですね。Rubyの繰り返し処理には <emphasis role="strong">for式</emphasis> <emphasis role="strong">while/until/loop</emphasis> などがありますが実際のところ <emphasis role="strong">eachメソッド</emphasis> を使った繰り返し処理が主流です。とはいえ、実際に動かして振る舞いを確認しないとイメージは難しいですよね。 <emphasis role="strong">学習用テスト</emphasis> を書いてもいいのですが今回は <emphasis>irb上で簡単なコードを動かしてみる</emphasis><xref linkend="pruby"/>ことで振る舞いを検証してみましょう。まずコマンドラインで <literal>irb</literal> を起動します。</simpara>
<blockquote>
<attribution>
プロを目指す人のためのRuby入門
</attribution>
<simpara>Rubyにはfor文はあります。ですが、ほとんどのRubyプログラマはfor文を使いません。筆者も5〜6年Rubyを使っていますが、for文を書いたことは一度もありません。Rubyの場合はforのような構文で繰り返し処理をさせるのではなく、配列自身に対して「繰り返せ」という命令を送ります。ここで登場するのがeachメソッドです。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ irb
irb(main):001:0&gt;</programlisting>
<simpara>まず先程デバッガで検証した配列の作成をやってみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">irb(main):001:0&gt; result = %w[1 2 3]
=&gt; ["1", "2", "3"]</programlisting>
<simpara>配列のeachメソッドをつかって配列の中身を繰り返し処理で表示させてみましょう。<literal>p</literal> はプリントメソッドです。</simpara>
<programlisting language="bash" linenumbering="unnumbered">irb(main):003:0&gt; result.each do |n| p n end
"1"
"2"
"3"
=&gt; ["1", "2", "3"]</programlisting>
<simpara>配列の中身を繰り返し処理で取り出す方法はわかりました。あとは100までの配列をどうやって作ればよいのでしょうか？ <literal>['1','2','3'&#8230;&#8203;'100']</literal> と手書きで作りますか？100件ぐらいならまあできなくもないでしょうが1000件,10000件ならどうでしょうか？無理ですね。計算機にやってもらいましょう、調べてみるとRubyには <emphasis role="strong">レンジオブジェクト(Range)</emphasis> というもの用意されいるそうです。説明を読んでもピンと来ないので実際に動作を確認してみましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>レンジオブジェクト（範囲オブジェクトとも呼ばれます）はRangeクラスのオブジェクトのことで、「..」や「&#8230;&#8203;」演算子を使って定義します。「1..3」のように定義し、主に整数値や文字列を使って範囲を表現します。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">irb(main):008:0&gt; (1..5).each do |n| p n end
1
2
3
4
5
=&gt; 1..5
irb(main):009:0&gt; (1...5).each do |n| p n end
1
2
3
4</programlisting>
<simpara>100まで表示したいのでこうですね。</simpara>
<programlisting language="bash" linenumbering="unnumbered">irb(main):010:0&gt; (1..100).each do |n| p n end
1
2
3
..
99
100
=&gt; 1..100</programlisting>
<simpara><literal>FizzBuzz::print_1_to_100</literal> <emphasis role="strong">メソッド</emphasis> の <emphasis role="strong">明白な実装</emphasis> イメージができましたか？ <literal>irb</literal> を終了させてプロダクトコードを変更しましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">irb(main):011:0&gt; exit</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.print_1_to_100
    result = []
    (1..100).each do |n|
      result &lt;&lt; n
    end
    result
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 38412

 FAIL["test_配列の初めは文字列の1を返す", #&lt;Minitest::Reporters::Suite:0x00007f858480edf8 @name="FizzBuzz::1から
100までの数の配列を返す"&gt;, 0.0012219999989611097]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "1"
          Actual: 1
        main.rb:38:in `test_配列の初めは文字列の1を返す'

 FAIL["test_配列の最後は文字列の100を返す", #&lt;Minitest::Reporters::Suite:0x00007f858480c8f0 @name="FizzBuzz::1から100までの数の配列を返す"&gt;, 0.0014040000023669563]
 test_配列の最後は文字列の100を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "100"
          Actual: 100
        main.rb:43:in `test_配列の最後は文字列の100を返す'

  6/6: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00218s
6 tests, 6 assertions, 2 failures, 0 errors, 0 skips</programlisting>
<simpara>ファッ！？また、やらかしました。文字列に変換しなといけませんね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.print_1_to_100
    result = []
    (1..100).each do |n|
      result &lt;&lt; n.to_s
    end
    result
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 40179

  6/6: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00196s
6 tests, 6 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>ちなみに、<emphasis>do &#8230;&#8203; endを使う代わりに、{}で囲んでもブロックを作れる</emphasis><xref linkend="pruby"/>のでこのように書き換えることができます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.print_1_to_100
    result = []
    (1..100).each { |n| result &lt;&lt; n.to_s }
    result
  end
end</programlisting>
<simpara>変更したらテストして確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 59102

  7/7: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00236s
7 tests, 7 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>ここで、一旦コミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'test: 1から100までの数を返す'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>1 から 100 までの数の配列を返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の初めは文字列の1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><phrase role="line-through">配列の最後は文字列の100を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_メソッド呼び出し">
<title>メソッド呼び出し</title>
<simpara>1から100までの数の配列を返すメソッドはできました。しかし、このプログラムは1から100までの数を <literal>FizzBuzz::generate</literal> した結果を返すのが正しい振る舞いですよね。 <emphasis role="strong">TODOリスト</emphasis> を追加してテストも追加します。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>1 から 100 までの数の配列を返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の初めは文字列の1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の最後は文字列の100を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">配列の2番めは文字列のFizzを返す</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<programlisting language="ruby" linenumbering="unnumbered">...
      def test_配列の2番目は文字列のFizzを返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Fizz', result[2]
      end
    end
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 50411

 FAIL["test_配列の2番目は文字列のFizzを返す", #&lt;Minitest::Reporters::Suite:0x00007fe8a1917dc8 @name="FizzBuzz::1から100までの数の配列を返す"&gt;, 0.01608900000428548]
 test_配列の2番目は文字列のをFizz返す#FizzBuzz::1から100までの数の配列を返す (0.02s)
        --- expected
        +++ actual
        @@ -1 +1,3 @@
        -"Fizz"
        +# encoding: US-ASCII
        +#    valid: true
        +"3"
        main.rb:48:in `test_配列の2番目は文字列のFizzを返す'

  7/7: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.03112s
7 tests, 7 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>ですよね、ここは <emphasis role="strong">繰り返し処理</emphasis> の中で <literal>FizzBuzz::generate</literal> を呼び出すように変更しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.print_1_to_100
    result = []
    (1..100).each { |n| result &lt;&lt; generate(n) }
    result
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 15549

 FAIL["test_配列の最後は文字列の100を返す", #&lt;Minitest::Reporters::Suite:0x00007ff80a907e28 @name="FizzBuzz::1から100までの数の配列を返す"&gt;, 0.001347000004898291]
 test_配列の最後は文字列の100を返す#FizzBuzz::1から100までの数の配列を返す (0.00s)
        Expected: "100"
          Actual: "Buzz"
        main.rb:43:in `test_配列の最後は文字列の100を返す'

  7/7: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00218s
7 tests, 7 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>新規に追加したテストはパスしたのですが２つ目のテストが失敗しています。これはテストケースが間違っていますね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
      def test_配列の最後は文字列のBuzzを返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Buzz', result.last
      end

      def test_配列の2番目は文字列のFizzを返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Fizz', result[2]
      end
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 21247

  7/7: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00217s
7 tests, 7 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>他のパターンも明記しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までのFizzBuzzの配列を返す' do
      def test_配列の初めは文字列の1を返す
        result = FizzBuzz.print_1_to_100
        assert_equal '1', result.first
      end

      def test_配列の最後は文字列のBuzzを返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Buzz', result.last
      end

      def test_配列の2番目は文字列のFizzを返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Fizz', result[2]
      end

      def test_配列の4番目は文字列のBuzzを返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'Buzz', result[4]
      end

      def test_配列の14番目は文字列のFizzBuzzを返す
        result = FizzBuzz.print_1_to_100
        assert_equal 'FizzBuzz', result[14]
      end
    end
  end
end</programlisting>
<simpara><emphasis role="strong">説明変数</emphasis> への代入が重複しています。ついでに <emphasis role="strong">メソッドの抽出</emphasis> をして重複をなくしておきましょう。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>最初のステップ「準備(Arrange)」は、テスト間で重複しがちだ。それとは対象的に「実行(Act)」「アサート(Assert)」は重複しないことが多い。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までのFizzBuzzの配列を返す' do
      def setup
        @result = FizzBuzz.print_1_to_100
      end

      def test_配列の初めは文字列の1を返す
        assert_equal '1', @result.first
      end

      def test_配列の最後は文字列のBuzzを返す
        assert_equal 'Buzz', @result.last
      end

      def test_配列の2番目は文字列のFizzを返す
        assert_equal 'Fizz', @result[2]
      end

      def test_配列の4番目は文字列のBuzzを返す
        assert_equal 'Buzz', @result[4]
      end

      def test_配列の14番目は文字列のFizzBuzzを返す
        assert_equal 'FizzBuzz', @result[14]
      end
    end
  end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 17460

  9/9: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00207s
9 tests, 9 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>とりあえず、現時点で仕様を満たすプログラムにはなったみたいですね。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'test: 1から100までのFizzBuzzの配列を返す'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><phrase role="line-through">1 から 100 までのFizzBuzzの配列を返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の初めは文字列の1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の最後は文字列の100を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の2番めは文字列のFizzを返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の4番目は文字列のBuzzを返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の14番目は文字列のFizzBuzzを返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_配列や繰り返し処理の理解">
<title>配列や繰り返し処理の理解</title>
<simpara>まだリファクタリングが残っているのですがその前にRubyの配列メソッドの理解をもう少し深めたいので <emphasis role="strong">学習用テスト</emphasis> を追加しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  describe 'FizzBuzz' do
...
  end

  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&amp;:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&amp;:size)
      assert_equal 'apple', result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&amp;:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      assert_equal %w[1 10 13 2 3 4], %w[2 4 13 3 1 10].sort
      assert_equal %w[1 2 3 4 10 13],
                   %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
      assert_equal %w[13 10 4 3 2 1],
                   %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item &lt; 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item &lt; 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 18136

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00307s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'test: 学習用テスト'</programlisting>
</section>
</section>
<section xml:id="_コードの不吉な臭い">
<title>コードの不吉な臭い</title>
<simpara>終わりが見えてきましたがまだリファクタリングの必要がありそうです。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>開発を終えるまでに考えつくまでに考えつく限りのテストを書き、テストに支えられたリファクタリングが、網羅性のあるテストに支えられてたリファクタリングになるようにしなければならない。</simpara>
</blockquote>
<simpara>ここでプロダクトコードを眺めてみましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end

  def self.print_1_to_100
    result = []
    (1..100).each { |n| result &lt;&lt; generate(n) }
    result
  end
end</programlisting>
<simpara><emphasis role="strong">コードの不吉な臭い</emphasis> が漂ってきませんか？私が感じた部分を解説していきますね。</simpara>
<section xml:id="_不思議な名前">
<title>不思議な名前</title>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>不思議な名前</simpara>
<simpara>明快なコードにするために最も重要なのは、適切な名前付けです。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>変数や関数などの構成要素の名前は、抽象的ではなく具体的なものにしよう。</simpara>
</blockquote>
<simpara>まず、気になったのが <literal>print_1_to_100</literal> メソッドです。このメソッドはFizzBuzzの配列を返すメソッドであって1から100までを表示するメソッドではありませんよね。ここは <emphasis role="strong">メソッド名の変更</emphasis> を適用して処理の内容に沿った名前に変更しましょう。え？動いている処理をわざわざ変更してプログラムを壊す危険を犯す必要があるのかですって。確かに自動テストのない状況でドジっ子プログラマがそんなことをすればいずれ残念なことになるでしょうね。でも、すでに自動テストが用意されている今なら自信をもって動いている処理でも変更できますよね。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>リファクタリングに入る前に、しっかりとした一連のテスト群を用意しておくこと。これらのテストには自己診断機能が不可欠である。</simpara>
</blockquote>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>テストは不安を退屈に変える賢者の石だ。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.print_1_to_100
    result = []
    (1..100).each { |n| result &lt;&lt; generate(n) }
    result
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.generate_list
    result = []
    (1..100).each { |n| result &lt;&lt; generate(n) }
    result
  end
end</programlisting>
<simpara>変更で壊れていないか確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 47414

ERROR["test_配列の初めは文字列の1を返す", #&lt;Minitest::Reporters::Suite:0x00007fe9e6858108 @name="FizzBuzz::1から
100までのFizzBuzzの配列を返す"&gt;, 0.0023099999998521525]
 test_配列の初めは文字列の1を返す#FizzBuzz::1から100までのFizzBuzzの配列を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'
...

ERROR["test_配列の最後は文字列のBuzzを返す", #&lt;Minitest::Reporters::Suite:0x00007fe9f7097160 @name="FizzBuzz::1から100までのFizzBuzzの配列を返す"&gt;, 0.011574000000109663]
 test_配列の最後は文字列のBuzzを返す#FizzBuzz::1から100までのFizzBuzzの配列を返す (0.01s)
NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class
            main.rb:37:in `setup'

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01479s
19 tests, 16 assertions, 0 failures, 5 errors, 0 skips</programlisting>
<simpara>いきなり失敗しちゃいました。でも、焦らずエラーメッセージを読みましょう。
<literal>NoMethodError:         NoMethodError: undefined method `print_1_to_100' for FizzBuzz:Class</literal> メソッド名の変更したけどテストは以前のままでしたね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までのFizzBuzzの配列を返す' do
      def setup
        @result = FizzBuzz.print_1_to_100
      end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe '1から100までのFizzBuzzの配列を返す' do
      def setup
        @result = FizzBuzz.generate_list
      end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 54699

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00351s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>プロダクトコードは壊れていなことが確認できたので自信を持ってコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor:　メソッド名の変更'</programlisting>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TDDにおけるテストの考え方は実用主義に貫かれている。TDDにおいてテストは目的を達成するための手段であり、その目的は、大きなる自信を伴うコードだ。</simpara>
</blockquote>
</section>
<section xml:id="_長い関数">
<title>長い関数</title>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>長い関数</simpara>
<simpara>経験上、長く充実した人生を送るのは、短い関数を持ったプログラムです。</simpara>
</blockquote>
<simpara>次に気になったのが <literal>FizzBuzz::generate</literal> メソッド内のif分岐処理ですね。こうした条件分岐には仕様変更の際に追加ロジックが新たなif分岐として追加されてどんどん長くなって読みづらいコードに成長する危険性があります。そういうコードは早めに対策を打っておくのが賢明です。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s
    if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end
    result
  end

  def self.generate_list
    result = []
    (1..100).each { |n| result &lt;&lt; generate(n) }
    result
  end
end</programlisting>
<simpara>まずコードをもう少し読みやすくしましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s

    if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end

    result
  end

  def self.generate_list
    result = []

    (1..100).each { |n| result &lt;&lt; generate(n) }

    result
  end
end</programlisting>
<simpara><literal>FizzBuzz</literal> の <emphasis role="strong">メソッド</emphasis> は大きく分けて <emphasis role="strong">変数</emphasis> の初期化 <emphasis role="strong">条件分岐</emphasis> <emphasis role="strong">繰り返し処理</emphasis> による判断、計算そして結果の <emphasis role="strong">代入</emphasis> を行い最後に <emphasis role="strong">代入</emphasis> された <emphasis role="strong">変数</emphasis> を返す流れになっています。
そこで各単位ごとにスペースを挿入してコードの可読性を上げておきましょう。</simpara>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>人間の脳はグループや階層を１つの単位として考える。コードの概要をすばやく把握してもらうには、このような「単位」を作ればいい。</simpara>
</blockquote>
<simpara>処理の単位ごとに区切りをつけました。次はif分岐ですがこうします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s

    if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
      result = 'FizzBuzz'
    elsif number.modulo(3).zero?
      result = 'Fizz'
    elsif number.modulo(5).zero?
      result = 'Buzz'
    end

    result
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s

    return 'FizzBuzz' if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?

    result
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 62095

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00296s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>条件に該当した場合は処理を最後まで進めずその場で終了させる書き方を <emphasis role="strong">ガード節</emphasis> と言います。このように書くことで追加ロジックが発生しても既存のコードを編集することなく追加することができるので安全に簡単に変更できるコードにすることができます。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>ガード節による入れ子条件記述の置き換え</simpara>
<simpara>メソッド内に正常ルートが不明確な条件つき振る舞いがある。</simpara>
<simpara>特殊ケースすべてに対してガード節を使う。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>関数で複数のreturn文を使ってはいけないと思っている人がいる。アホくさ。関数から早く返すのはいいことだ。むしろ望ましいときもある。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor: ガード節による入れ子条件の置き換え'</programlisting>
<simpara>どの条件にも該当しない場合は数字を文字列してかえすのですが <emphasis role="strong">一時変数</emphasis> の <literal>result</literal> は最後でしか使われていませんね。このような場合は <emphasis role="strong">変数のインライン化</emphasis> を適用しましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>一時変数のインライン化</simpara>
<simpara>簡単な式によって一度だけ代入される一時変数があり、それが他のリファクタリングの障害となっている。</simpara>
<simpara>その一時変数への参照をすべて式で置き換える。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    result = number.to_s

    return 'FizzBuzz' if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?

    result
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    return 'FizzBuzz' if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?

    number.to_s
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 2528

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00255s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>変更によって壊れていないことが確認できたのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor:　変数のインライン化'</programlisting>
<simpara>続いて、FizzBuzzを判定する部分ですがもう少しわかりやすくするため <emphasis role="strong">説明用変数の導入</emphasis> を適用します。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>説明用変数の導入</simpara>
<simpara>複雑な式がある。</simpara>
<simpara>その式の結果または部分的な結果を、その目的を説明する名前をつけた一時変数に代入する。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    return 'FizzBuzz' if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
    return 'Fizz' if number.modulo(3).zero?
    return 'Buzz' if number.modulo(5).zero?

    number.to_s
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if number.modulo(3).zero? &amp;&amp; number.modulo(5).zero?
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
...</programlisting>
<simpara>３で割り切れる場合の結果を <literal>isFizz</literal> 変数に 5で割り切れる場合の結果 <literal>isBuzz</literal> 変数に代入して使えるようにしました。このような変数を <emphasis role="strong">説明変数</emphasis> と呼びます。また似たようなパターンに <emphasis role="strong">要約変数</emphasis> というものがあります。FizzBuzzを返す判定部分にこの <emphasis role="strong">説明変数</emphasis> を適用しました。壊れていないか確認しておきましょう。</simpara>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>説明変数</simpara>
<simpara>式を簡単に分割するには、式を表す変数を使えばいい。この変数を「説明変数」と呼ぶこともある。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>要約変数</simpara>
<simpara>大きなコードの塊を小さな名前に置き換えて、管理や把握を簡単にする変数のことを要約変数と呼ぶ。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  def self.generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 4314

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00262s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>壊れていませんね。ではコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor:　変数の抽出'</programlisting>
</section>
<section xml:id="_ループと変更可能なデータ">
<title>ループと変更可能なデータ</title>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>ループ</simpara>
<simpara>プログラミング言語の黎明期から、ループは中心的な存在でした。しかし今ではベルボトムのジーンズやペナントのお土産のように、あまり重要でなくなりつつあります。</simpara>
</blockquote>
<simpara><literal>FizzBuzz::generate</literal> メソッドのリファクタリングはできたので続いて <literal>FizzBuzz::generate_list</literal> メソッドを見ていきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.generate_list
    result = []

    (1..100).each { |n| result &lt;&lt; generate(n) }

    result
  end
end</programlisting>
<simpara>空の <emphasis role="strong">配列</emphasis> を変数に代入してその変数に <literal>FizzBuzz::generate</literal> メソッドの結果を追加して返す処理ですがもしこのような変更をしてしまったらどうなるでしょうか？</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.generate_list
    result = []

    (1..100).each { |n| result &lt;&lt; generate(n) }

    result = []
    result
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 19180

 FAIL["test_配列の14番目は文字列のをFizzBuzz返す", #&lt;Minitest::Reporters::Suite:0x00007fa72805c018 @name="FizzBuzz::1から100までのFizzBuzzの配列を返す"&gt;, 0.0021289999967848416]
 test_配列の14番目は文字列のをFizzBuzz返す#FizzBuzz::1から100までのFizzBuzzの配列を返す (0.00s)
        Expected: "FizzBuzz"
          Actual: nil
        main.rb:57:in `test_配列の14番目は文字列のをFizzBuzz返す'
...

Finished in 0.03063s
19 tests, 21 assertions, 5 failures, 0 errors, 0 sk</programlisting>
<simpara>せっかく作った配列を初期化して返してしまいましたね。このようにミュータブルな変数はバグを作り込む原因となる傾向があります。まず一時変数を使わないように変更しましょう。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>変更可能なデータ</simpara>
<simpara>データの変更はしばしば予期せぬ結果や、厄介なバグを引き起こします。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>「永続的に変更されない」変数は扱いやすい。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.generate_list
    return (1..100).each { |n| result &lt;&lt; generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 56578

ERROR["test_配列の4番目は文字列のをBuzz返す", #&lt;Minitest::Reporters::Suite:0x00007fe705854af0 @name="FizzBuzz::1から100までのFizzBuzzの配列を返す"&gt;, 0.001975000002857996]
 test_配列の4番目は文字列のをBuzz返す#FizzBuzz::1から100までのFizzBuzzの配列を返す (0.00s)
NameError:         NameError: undefined local variable or method `result' for FizzBuzz:Class
            main.rb:153:in `block in generate_list'
            main.rb:153:in `each'
            main.rb:153:in `generate_list'
            main.rb:37:in `setup'
...
  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01032s
19 tests, 16 assertions, 0 failures, 5 errors, 0 skips</programlisting>
<simpara>一時変数 <literal>result</literal> は使わないので</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.generate_list
    return (1..100).each { |n| generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 35137

ERROR["test_配列の4番目は文字列のをBuzz返す", #&lt;Minitest::Reporters::Suite:0x00007f7f1384ff78 @name="FizzBuzz::1から100までのFizzBuzzの配列を返す"&gt;, 0.0014560000017809216]
 test_配列の4番目は文字列のをBuzz返す#FizzBuzz::1から100までのFizzBuzzの配列を返す (0.00s)
NoMethodError:         NoMethodError: undefined method `[]' for 1..100:Range
            main.rb:53:in `test_配列の4番目は文字列のをBuzz返す'
...
  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.03285s
19 tests, 18 assertions, 2 failures, 3 errors, 0 skips</programlisting>
<simpara>結果を配列にして返したいのですが <emphasis role="strong">eachメソッド</emphasis> ではうまくできませんね。Rubyには新しい配列を作成する <emphasis role="strong">mapメソッド</emphasis> が用意されいるのでそちらを使いましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>mapは配列の要素を画する際によく利用されるメソッドで、ブロックの最後の要素（メモ）で新しい配列を作ります。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.generate_list
    return (1..100).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered"> $ ruby main.rb
Started with run options --seed 44043

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00261s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>うまくいきましたね。あと、Rubyではreturnを省略できるので</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.generate_list
    (1..100).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 7994

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00238s</programlisting>
<simpara><emphasis role="strong">パイプラインによるループの置き換え</emphasis> の適用により <emphasis role="strong">eachメソッド</emphasis> による繰り返し処理を <emphasis role="strong">mapメソッド</emphasis> を使ったイミュータブルなコレクションパイプライン処理に変えることができました。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>パイプラインによるループの置き換え</simpara>
<simpara>多くのプログラマと同様に、私もオブジェクトの集合の反復処理にはループを使うように教えられました。しかし言語環境は、よりすぐれた仕組みとしてコレクションのパイプラインを提供するようになりました。</simpara>
</blockquote>
<blockquote>
<attribution>
プロを目指す人のためのRuby入門
</attribution>
<simpara>Rubyに限らず、プログラミングの世界ではしばしばミュータブル（mutable)とイミュータブル（imutable）と言う言葉が登場します。ミュータブルは「変更可能な」という意味で、反対にイミュータブルは「変更できない、不変の」という意味です。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor: パイプラインによるループの置き換え'</programlisting>
</section>
<section xml:id="_マジックナンバー">
<title>マジックナンバー</title>
<simpara>最大値は100にしていますが変更することもあるので <emphasis role="strong">マジックナンバーの置き換え</emphasis> を適用してわかりやすくしておきましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>シンボル定数によるマジックナンバーの置き換え</simpara>
<simpara>特別な意味を持った数字のリテラルがある。</simpara>
<simpara>定数を作り、それにふさわしい名前をつけて、そのリテラルを置き換える。</simpara>
</blockquote>
<simpara>Rubyでは定数は英字の大文字で始まる名前をつけると自動的に定数として扱われます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

...

  def self.generate_list
    (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<simpara>意味のわかる定数として宣言しました。コードに直接記述された <literal>100</literal> をといった <emphasis role="strong">数値:リテラル</emphasis> はマジックナンバーと呼ばれ往々にして後で何を意味するものかわからなくなり変更を難しくする原因となります。早めに意味を表す定数にしておきましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>名前付けされずにプログラム内に直接記述されている数値をマジックナンバーと呼び、一般的には極力避けるようにします。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>いい名前というのは、変数の目的や値を表すものだ。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Started with run options --seed 32408

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00241s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストは通りました。でもこのコードは初見の人には分かりづらいのでコメントを入れておきましょう。Rubyの <emphasis role="strong">単一行コメントアウト</emphasis> のやり方は行頭に <literal>#</literal> を使います。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def self.generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<simpara>ここではなぜこのような処理を選択したかをコメントしましたが何でもコメントすればよいというわけではありません。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>コメント</simpara>
<simpara>ここでコメントについて言及しているのは、コメントが消臭剤として使われることがあるからです。コメントが非常に丁寧に書かれているのは、実はわかりにくいコードを補うためだったとうことがよくあるのです。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>コメントを書くのであれば、正確に書くべきだ（できるだけ明確で詳細に）。また、コメントには画面の領域を取られるし、読むのにも時間がかかるので、簡潔なものでなければいけない。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ git add main.rb
$ git commit -m 'refactor: マジックナンバーの置き換え'</programlisting>
</section>
</section>
<section xml:id="_動作するきれいなコード">
<title>動作するきれいなコード</title>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">数を文字列にして返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら文字列"2"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3の倍数のときは数の代わりに｢Fizz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"Fizz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">5 の倍数のときは｢Buzz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"Buzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">13 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">15を渡したら文字列FizzBuzzを返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1 から 100 までのFizzBuzzの配列を返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の初めは文字列の1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の最後は文字列の100を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の2番めは文字列のFizzを返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の4番目は文字列のBuzzを返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の14番目は文字列のFizzBuzzを返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>プリントする</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">TODOリスト</emphasis> も残すところあと１つとなりました。これまで <literal>main.rb</literal> ファイル１つだけで開発を行ってきましたがリリースするにはもうひと手間かけたほうがいいでしょうね。libディレクトリを作成したあと <literal>main.rb</literal> ファイルを <literal>fizz_buzz.rb</literal> ファイルに名前を変更してlibディレクトリに移動します。</simpara>
<literallayout class="monospaced">/
|--lib/
    |
     -- fizz_buzz.rb</literallayout>
<simpara>続いてテストコードをテストディレクトリに保存してプログラム本体とテストコードを分離します</simpara>
<literallayout class="monospaced">/
|--lib/
    |
     -- fizz_buzz.rb
|--test/
    |
     -- fizz_buzz_test.rb</literallayout>
<simpara>分離したテストが動くか確認しておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fizz_buzz_test.rb
Started with run options --seed 17134

ERROR["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00007fc07a085060 @name="FizzBuzz::その他の場合"&gt;, 0.001282999997783918]
 test_1を渡したら文字列1を返す#FizzBuzz::その他の場合 (0.00s)
NameError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
        Did you mean?  FizzBuzzTest
            test/fizz_buzz_test.rb:8:in `setup'
...
  19/19: [===============================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.03717s
19 tests, 12 assertions, 0 failures, 9 errors, 0 skips</programlisting>
<simpara>テストファイルからFizzBuzzクラスを読み込めるようにする必要があります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzTest &lt; Minitest::Test
...</programlisting>
<simpara>Rubyで別のファイルを読み込むには <emphasis role="strong">require</emphasis> を使います。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>requireを使う用途は主に三つあります。</simpara>
<itemizedlist>
<listitem>
<simpara>標準添付ライブラリを読み込む</simpara>
</listitem>
<listitem>
<simpara>第三者が作成しているライブラリを読み込む</simpara>
</listitem>
<listitem>
<simpara>別ファイルに定義した自分のファイルを読み込む</simpara>
</listitem>
</itemizedlist>
</blockquote>
<simpara>また、<emphasis role="strong">require_relative</emphasis> という方法も用意されています。どう違うのでしょうか？</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>require_relativeは$LOAD_PATHの参照は行わず「relative」という名称の通り相対的なパスでファイルの読み込みを行います。</simpara>
</blockquote>
<simpara>ちょっと何言ってるかわからないうちは <emphasis role="strong">require</emphasis> を上記のフォルダ構成で使っていてください。一応以下の使い分けがありますが今は頭の隅に留めるだけでいいと思います。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>requireは標準添付ライブラリなどの自分が書いていないコードを読み込む時に使い、こちらのrequire_relativeは自分の書いたコードを読み込む時に使うように使い分けるのが良いでしょう。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fizz_buzz_test.rb
Started with run options --seed 44438

  19/19: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00279s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>では最後に <literal>main.rb</literal> ファイルを追加して <literal>FizzBuzz:generate_list</literal> を呼び出すようにします。</simpara>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<programlisting language="ruby" linenumbering="unnumbered">require './lib/fizz_buzz.rb'

puts FizzBuzz.generate_list</programlisting>
<simpara><emphasis role="strong">puts</emphasis> は結果を画面に出力するメソッドです。
先程は <emphasis role="strong">p</emphasis> メソッドを使って画面に <emphasis role="strong">配列</emphasis> の中身を１件ずつ表示していましたが今回は <emphasis role="strong">配列</emphasis> 自体を改行して画面に出力するため <emphasis role="strong">puts</emphasis> メソッドを使います。機能的にはほどんど変わらないのですが以下の様に使い分けるそうです。</simpara>
<blockquote>
<attribution>
プロを目指す人のためのRuby入門
</attribution>
<simpara>まず、用途としてはputsメソッドとprintメソッドは一般ユーザ向け、pメソッドは開発者向け、というふうに別かれます。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
...
Buzz</programlisting>
<simpara>ちなみに <emphasis role="strong">print</emphasis> メソッドを使った場合はこのように出力されます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
["1", "2", "Fizz", "4", "Buzz", "Fizz", "7", "8", "Fizz", "Buzz", "11", "Fizz", "13", "14", "FizzBuzz", "16", "17", "Fizz", "19", "Buzz", "Fizz", "22", "23", "Fizz", "Buzz", "26", "Fizz", "28", "29", "FizzBuzz", "31", "32", "Fizz", "34", "Buzz", "Fizz", "37", "38", "Fizz", "Buzz", "41", "Fizz", "43", "44", "FizzBuzz", "46", "47", "Fizz", "49", "Buzz", "Fizz", "52", "53", "Fizz", "Buzz", "56", "Fizz", "58", "59", "FizzBuzz", "61", "62", "Fizz", "64", "Buzz", "Fizz", "67", "68", "Fizz", "Buzz", "71", "Fizz", "73", "74", "FizzBuzz", "76", "77", "Fizz", "79", "Buzz", "Fizz", "82", "83", "Fizz", "Buzz", "86", "Fizz", "88", "89", "FizzBuzz", "91", "92", "Fizz", "94", "Buzz", "Fizz", "97", "98", "Fizz", "Buzz"] $</programlisting>
<simpara>プログラムの完成です。コミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git commit -m 'feat: プリントする'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">数を文字列にして返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら文字列"2"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3の倍数のときは数の代わりに｢Fizz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"Fizz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">5 の倍数のときは｢Buzz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"Buzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">13 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">15を渡したら文字列FizzBuzzを返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1 から 100 までのFizzBuzzの配列を返す</phrase></emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の初めは文字列の1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の最後は文字列の100を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の2番めは文字列のFizzを返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の4番目は文字列のBuzzを返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">配列の14番目は文字列のFizzBuzzを返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">プリントする</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
<section xml:id="_ふりかえり">
<title>ふりかえり</title>
<simpara><literal>FizzBuzz</literal> プログラムの最初のバージョンをリリースすることができたのでこれまでのふりかえりをしておきましょう。</simpara>
<simpara>まず <emphasis role="strong">TODOリスト</emphasis> を作成して <emphasis role="strong">テストファースト</emphasis> で１つずつ小さなステップで開発を進めていきました。
<emphasis role="strong">仮実装を経て本実装へ</emphasis> の過程で Rubyの <emphasis role="strong">クラス</emphasis> を定義して <emphasis role="strong">文字列リテラル</emphasis> を返す <emphasis role="strong">メソッド</emphasis> を作成しました。この時点でRubyの <emphasis role="strong">オブジェクトとメソッド</emphasis> という概念に触れています。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>Rubyの世界では、ほぼどのような値もオブジェクトという概念で表されます。オブジェクトという表現はかなり範囲の広い表現方法で、クラスやインスタンスを含めてオブジェクトと称します。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>プログラミング言語においてメソッド、あるいは関数と呼ばれるものを簡単に説明すると処理をひとかたまりにまとめたものと言って良いでしょう。</simpara>
</blockquote>
<simpara>ちょっと何言ってるかわからないかもしれませんが、今はそういう概念があってこうやって書くのねという程度の理解で十分です。</simpara>
<simpara>その後 <emphasis role="strong">リファクタリング</emphasis> を通じて多くの概念に触れることになりました。
まず <emphasis role="strong">変数名の変更</emphasis> でRubyにおける <emphasis role="strong">変数</emphasis> の概念と操作を通じて名前付けの重要性を学びました。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>Rubyでは変数を扱うために特別な宣言やキーワードは必要ありません。「=」 の左辺に任意の変数名を記述するだけで変数宣言となります。</simpara>
</blockquote>
<simpara>続いて <emphasis role="strong">明白な実装</emphasis> を通して <emphasis role="strong">制御構造</emphasis> のうち <emphasis role="strong">条件分岐</emphasis> のための <emphasis role="strong">if式</emphasis> と <emphasis role="strong">演算子</emphasis> を使いプログラムを制御し判定・計算をする方法を学びました。また、<emphasis role="strong">アルゴリズムの置き換え</emphasis> を適用してコードをよりわかりやすくしました。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>Rubyではプログラムを構成する最小の要素を式と呼びます。変数やリテラル、制御構文、演算子などが式として扱われます。</simpara>
</blockquote>
<simpara>そして、 <emphasis role="strong">学習用テスト</emphasis> を通して新しい問題を解決するために <emphasis role="strong">配列オブジェクト</emphasis> <emphasis role="strong">レンジオブジェクト</emphasis> といった <emphasis role="strong">文字列リテラル</emphasis> <emphasis role="strong">数値リテラル</emphasis> 以外の <emphasis role="strong">データ構造</emphasis> の使い方を学習して、<emphasis role="strong">配列</emphasis> を操作するための <emphasis role="strong">制御構造</emphasis> として <emphasis role="strong">繰り返し処理</emphasis> を <emphasis role="strong">eachメソッド</emphasis> を使って実現しました。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>これら「100」や「3.14」といった部分を数値リテラルと呼びます。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>このように文字列をシングルクオートやダブルクオートで括っている表記を文字列リテラルと呼びます。</simpara>
</blockquote>
<simpara>仕上げは、<emphasis role="strong">コードの不吉な臭い</emphasis> からさらなる改善を実施しました。 <emphasis role="strong">不思議な名前</emphasis> の <emphasis role="strong">メソッド</emphasis> を <emphasis role="strong">自動的テスト</emphasis> を用意することで自信を持って <emphasis role="strong">リファクタリング</emphasis> を実施し、<emphasis role="strong">長い関数</emphasis> に対して <emphasis role="strong">ガード節</emphasis> を導入し <emphasis role="strong">一時変数</emphasis> <emphasis role="strong">説明変数</emphasis> など <emphasis role="strong">変数</emphasis> バリエーションの取り扱いを学びました。そして、<emphasis role="strong">ループ</emphasis> と <emphasis role="strong">変更可能なデータ</emphasis> から <emphasis role="strong">コレクションパイプライン</emphasis> の使い方と <emphasis role="strong">ミュータブル</emphasis> <emphasis role="strong">イミュータブル</emphasis> の概念を学び、<emphasis role="strong">コメント</emphasis> のやり方と <emphasis role="strong">定数</emphasis> と <emphasis role="strong">マジックナンバー</emphasis> の問題を学びました。</simpara>
<simpara>最後に、<emphasis role="strong">require</emphasis> の使い方を通してファイルの分割方法を学ぶことができました。</simpara>
<simpara>ちょっと何言ってるかわからない単語ばかり出てきたかもしれませんがこれでRubyの基本の半分は抑えています。自分でFizzBuzzコードが書けて用語の意味が説明できるようになれば技能・学科第一段階の半分ぐらいといったところでしょうか。仮免許取得にはまだ習得しなければならない技術と知識がありますので。</simpara>
</section>
<section xml:id="_良いコード">
<title>良いコード</title>
<simpara>以下のコードを作成しました。</simpara>
<formalpara>
<title>/main.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './lib/fizz_buzz.rb'

puts FizzBuzz.generate_list</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/fizz_buzz.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end

  def self.generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/fizz_buzz_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzTest &lt; Minitest::Test
  describe 'FizzBuzz' do
    def setup
      @fizzbuzz = FizzBuzz
    end

    describe '三の倍数の場合' do
      def test_3を渡したら文字列Fizzを返す
        assert_equal 'Fizz', @fizzbuzz.generate(3)
      end
    end

    describe '五の倍数の場合' do
      def test_5を渡したら文字列Buzzを返す
        assert_equal 'Buzz', @fizzbuzz.generate(5)
      end
    end

    describe '三と五の倍数の場合' do
      def test_15を渡したら文字列FizzBuzzを返す
        assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
      end
    end

    describe 'その他の場合' do
      def test_1を渡したら文字列1を返す
        assert_equal '1', @fizzbuzz.generate(1)
      end

      def test_2を渡したら文字列2を返す
        assert_equal '2', @fizzbuzz.generate(2)
      end
    end

    describe '1から100までのFizzBuzzの配列を返す' do
      def setup
        @result = FizzBuzz.generate_list
      end

      def test_配列の初めは文字列の1を返す
        assert_equal '1', @result.first
      end

      def test_配列の最後は文字列のBuzzを返す
        assert_equal 'Buzz', @result.last
      end

      def test_配列の2番目は文字列のFizzを返す
        assert_equal 'Fizz', @result[2]
      end

      def test_配列の4番目は文字列のBuzzを返す
        assert_equal 'Buzz', @result[4]
      end

      def test_配列の14番目は文字列のFizzBuzzを返す
        assert_equal 'FizzBuzz', @result[14]
      end
    end
  end

  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&amp;:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&amp;:size)
      assert_equal 'apple', result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&amp;:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      assert_equal %w[1 10 13 2 3 4], %w[2 4 13 3 1 10].sort
      assert_equal %w[1 2 3 4 10 13],
                   %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
      assert_equal %w[13 10 4 3 2 1],
                   %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item &lt; 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item &lt; 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
end</programlisting>
</para>
</formalpara>
<simpara>どうでしょう、学習用テストは除くとしてプロダクトコードに対して倍以上のテストコードを作っていますよね。テストコードを作らず一発で <literal>fizz_buzz.rb</literal> のようなコードを書くことはできますか？ たしかに <literal><link xl:href="https://www.google.com/search?hl=ja&amp;sxsrf=ACYBGNRC-UwZUT1OMCdicC984bdIxzeG0A%3A1579161119693&amp;source=hp&amp;ei=HxYgXsCsJ4qF0wS3k5e4Ag&amp;q=fizz+buzz+ruby&amp;oq=fizz+buzz+ruby&amp;gs_l=psy-ab.3..0.1369.4308..4714&#8230;&#8203;0.0..0.140.1446.6j8&#8230;&#8203;&#8230;&#8203;0&#8230;&#8203;.1..gws-wiz&#8230;&#8203;&#8230;&#8203;.0i131j0i131i4j0i4j35i39j0i4i3j0i10i203j0i203j0i30j0i10i30j0i8i30.PLE9lL0CGmo&amp;ved=0ahUKEwiAuNHM0YfnAhWKwpQKHbfJBScQ4dUDCAg&amp;uact=5">fizz buzz ruby</link></literal> といったキーワードで検索すればサンプルコードは見つかるのでコピーして同じ振る舞いをするコードをすぐに書くことはできるでしょう。でも仕様が追加された場合はどうしましょう。</simpara>
<simpara>仕様</simpara>
<literallayout class="monospaced">1 から 100 までの数をプリントするプログラムを書け。
ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、
3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。
タイプごとに出力を切り替えることができる。
タイプ１は通常、タイプ２は数字のみ、タイプ３は FizzBuzz の場合のみをプリントする。</literallayout>
<simpara>また同じようなコードサンプルを探しますか？私ならば <emphasis role="strong">TODOリスト</emphasis> に以下の項目を追加することから始めます。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>タイプ1の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>次に何をやるかはもうわかりますよね。テスト駆動開発とはただ失敗するテストを１つずつ書いて通していくことではありません。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TDDは分析技法であり、設計技法であり、実際には開発のすべてのアクティビティを構造化する技法なのだ。</simpara>
</blockquote>
<simpara>ではテストファーストで書けば質の高い良いコードがかけるようになるのでしょうか？以下のコードを見てください。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'

class FizzBuzz
  # fizz_buzzメソッドを実行する
  def self.fizz_buzz(n)
  a = n.to_s
    if n % 3 == 0
      a = 'Fizz'
    if n % 15 == 0
      a = 'FizzBuzz'
    end
        elsif n % 5 == 0
          a = 'Buzz'
        end
           a
  end

# 1から100までをプリントする
  def self.print_1_to_100
              n = []
    (1..100).each do |i|
  n &lt;&lt; fizz_buzz(i)
                        end
  n
  end
end

class FizzBuzzTest &lt; Minitest::Test
  describe 'FizzBuzz' do
    def setup
      @p = FizzBuzz
    end

      def test_15を渡したら文字列pを返す
        assert_equal 'FizzBuzz', FizzBuzz.fizz_buzz(15)
      end
      def test_3を渡したら文字列3を返す
        assert_equal 'Fizz', FizzBuzz.fizz_buzz(3)
      end
      def test_1を渡したら文字列1を返す
        assert_equal '1', @p.fizz_buzz(1)
      end
      def test_5を渡したら文字列Buzzを返す
        assert_equal 'Buzz', FizzBuzz.fizz_buzz(5)
      end

    describe '1から100までプリントする' do
  def setup
    @x = FizzBuzz.print_1_to_100
  end

  def test_配列の4番目は文字列のをBuzz返す
    assert_equal 'Buzz', @x[4]
  end

      def test_配列の初めは文字列の1を返す
        assert_equal '1', @x.first
      end

      def test_配列の最後は文字列のBuzzを返す
        assert_equal 'Buzz', FizzBuzz.print_1_to_100.last
      end

def test_配列の14番目は文字列のFizzBuzz返す
  assert_equal 'FizzBuzz', @x[14]
end
  def test_配列の2番目は文字列の2を返す
    assert_equal 'Fizz', @x[2]
  end

    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fizz_buzz_tfd_test.rb
Started with run options --seed 43131

  9/9: [===================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00135s
9 tests, 9 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>プログラムは動くしテストも通ります。でもこれはテスト駆動開発で作られたと言えるでしょうか？質の高い良いコードでしょうか？何が足りないかはわかりますよね。</simpara>
<blockquote>
<attribution>
テスト駆動開発 付録C 訳者解説
</attribution>
<simpara>テスト駆動開発における質の向上の手段は、リファクタリングによる継続的でインクリメンタルな設計であり、「単なるテストファースト」と「テスト駆動開発」の違いはそこにあります。</simpara>
</blockquote>
<simpara>そもそも良いコードは何なのでしょうか？いくつかの見解があるようです。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TDDは「より良いコードを書けば、よりうまくいく」という素朴で奇妙な仮設によって成り立っている</simpara>
</blockquote>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>「動作するきれいなコード」。RonJeffriesのこの簡潔な言葉が、テスト駆動開発(TDD)のゴールだ。動作するきれいなコードはあらゆる意味で価値がある。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>良いコードかどうかは、変更がどれだけ容易なのかで決まる。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>コードは理解しやすくなければいけない。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>コードは他の人が最短時間で理解できるように書かなければいけない。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>優れたソースコードは「目に優しい」ものでなければいけない。</simpara>
</blockquote>
<simpara>少なくともテスト駆動開発のゴールに良いコードがあるということはいえるでしょう。え？どうやったら良いコードを書けるようになるかって？私が教えてほしいのですがただ言えることは他の分野と同様に規律の習得と絶え間ない練習と実践の積み重ねのむこうにあるのだろうということだけです。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>私がかつて発見した、そして多くの人に気づいてもらいたい効果とは、反復可能な振る舞いを規則にまで還元することで、規則の適用は機会的に反復可能になるということだ。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>ここで、Kent Beckが自ら語ったセリフを思い出しました。「僕は、偉大なプログラマなんかじゃない。偉大な習慣を身につけた少しましなプログラマなんだ」。</simpara>
</blockquote>
</section>
</section>
</section>
</section>
<section xml:id="_エピソード2">
<title>エピソード2</title>
<section xml:id="_自動化から始めるテスト駆動開発">
<title>自動化から始めるテスト駆動開発</title>
<simpara>エピソード1ではテスト駆動開発のゴールが <emphasis role="strong">動作するきれいなコード</emphasis> であることを学びました。
では、良いコードを書き続けるためには何が必要になるでしょうか？それは <link xl:href="https://t-wada.hatenablog.jp/entry/clean-code-that-works">ソフトウェア開発の三種の神器</link> と呼ばれるものです。</simpara>
<blockquote>
<attribution>
https://t-wada.hatenablog.jp/entry/clean-code-that-works
</attribution>
<simpara>今日のソフトウェア開発の世界において絶対になければならない3つの技術的な柱があります。 三本柱と言ったり、三種の神器と言ったりしていますが、それらは</simpara>
<itemizedlist>
<listitem>
<simpara>バージョン管理</simpara>
</listitem>
<listitem>
<simpara>テスティング</simpara>
</listitem>
<listitem>
<simpara>自動化</simpara>
</listitem>
</itemizedlist>
<simpara>の3つです。</simpara>
</blockquote>
<simpara><emphasis role="strong">バージョン管理</emphasis> と <emphasis role="strong">テスティング</emphasis> に関してはエピソード1で触れました。本エピソードでは最後の <emphasis role="strong">自動化</emphasis> に関しての解説と次のエピソードに備えたセットアップ作業を実施しておきたいと思います。ですがその前に <emphasis role="strong">バージョン管理</emphasis> で1つだけ解説しておきたいことがありますのでそちらから進めて行きたいと思います。</simpara>
<section xml:id="_コミットメッセージ">
<title>コミットメッセージ</title>
<simpara>これまで作業の区切りにごとにレポジトリにコミットしていましたがその際に以下のような書式でメッセージを書いていました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git commit -m 'refactor: メソッドの抽出'</programlisting>
<simpara>この書式は <link xl:href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#type">Angularルール</link>に従っています。具体的には、それぞれのコミットメッセージはヘッダ、ボディ、フッタで構成されています。ヘッダはタイプ、スコープ、タイトルというフォーマットで構成されています。</simpara>
<screen>&lt;タイプ&gt;(&lt;スコープ&gt;): &lt;タイトル&gt;
&lt;空行&gt;
&lt;ボディ&gt;
&lt;空行&gt;
&lt;フッタ&gt;</screen>
<simpara>ヘッダは必須です。
ヘッダのスコープは任意です。
コミットメッセージの長さは50文字までにしてください。</simpara>
<simpara>(そうすることでその他のGitツールと同様にGitHub上で読みやすくなります。)</simpara>
<simpara>コミットのタイプは次を用いて下さい。</simpara>
<itemizedlist>
<listitem>
<simpara>feat: A new feature (新しい機能)</simpara>
</listitem>
<listitem>
<simpara>fix: A bug fix (バグ修正)</simpara>
</listitem>
<listitem>
<simpara>docs: Documentation only changes (ドキュメント変更のみ)</simpara>
</listitem>
<listitem>
<simpara>style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) (コードに影響を与えない変更)</simpara>
</listitem>
<listitem>
<simpara>refactor: A code change that neither fixes a bug nor adds a feature (機能追加でもバグ修正でもないコード変更)</simpara>
</listitem>
<listitem>
<simpara>perf: A code change that improves performance (パフォーマンスを改善するコード変更)</simpara>
</listitem>
<listitem>
<simpara>test: Adding missing or correcting existing tests (存在しないテストの追加、または既存のテストの修正)</simpara>
</listitem>
<listitem>
<simpara>chore: Changes to the build process or auxiliary tools and libraries such as documentation generation (ドキュメント生成のような、補助ツールやライブラリやビルドプロセスの変更)</simpara>
</listitem>
</itemizedlist>
<simpara>コミットメッセージにつけるプリフィックスに関しては <link xl:href="https://qiita.com/numanomanu/items/45dd285b286a1f7280ed">【今日からできる】コミットメッセージに 「プレフィックス」 をつけるだけで、開発効率が上がった話</link> を参照ください。</simpara>
</section>
<section xml:id="_パッケージマネージャ">
<title>パッケージマネージャ</title>
<simpara>では <emphasis role="strong">自動化</emphasis> の準備に入りたいのですがそのためにはいくつかの外部プログラムを利用する必要があります。そのためのツールが <emphasis role="strong">RubyGems</emphasis> です。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>RubyGemsとは、Rubyで記述されたサードパーティ製のライブラリを管理するためのツールで、RubyGemsで扱うライブラリをgemパッケージと呼びます。</simpara>
</blockquote>
<simpara><emphasis role="strong">RubyGems</emphasis> はすでに何度か使っています。例えばエピソード1の初めの <literal>minitest-reporters</literal> のインストールなどです。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ gem install minitest-reporters</programlisting>
<simpara>では、これからもこのようにして必要な外部プログラムを一つ一つインストールしていくのでしょうか？また、開発用マシンを変えた時にも同じことを繰り返さないといけないのでしょうか？面倒ですよね。そのような面倒なことをしないで済む仕組みがRubyには用意されています。それが <emphasis role="strong">Bundler</emphasis> です。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>Bundlerとは、作成したアプリケーションがどのgemパッケージに依存しているか、そしてインストールしているバージョンはいくつかという情報を管理するためのgemパッケージです。</simpara>
</blockquote>
<simpara><emphasis role="strong">Bundler</emphasis> をインストールしてgemパッケージを束ねましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ gem install bundler
$ bundle init</programlisting>
<simpara><literal>Gemfile</literal> が作成されます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

source "https://rubygems.org"

git_source(:github) {|repo_name| "https://github.com/#{repo_name}" }

# gem "rails"</programlisting>
<simpara><literal># gem "rails"</literal> の部分を以下の様に書き換えます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

source "https://rubygems.org"

git_source(:github) {|repo_name| "https://github.com/#{repo_name}" }

gem 'rubocop', require: false</programlisting>
<simpara>書き換えたら <literal>bundle install</literal> でgemパッケージをインストールします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ bundle install
Fetching gem metadata from https://rubygems.org/....................
Resolving dependencies...
Using ast 2.4.0
Using bundler 2.1.4
Using jaro_winkler 1.5.4
Using parallel 1.19.1
Fetching parser 2.7.0.2
Installing parser 2.7.0.2
Using rainbow 3.0.0
Using ruby-progressbar 1.10.1
Fetching unicode-display_width 1.6.1
Installing unicode-display_width 1.6.1
Fetching rubocop 0.79.0
Installing rubocop 0.79.0
Bundle complete! 1 Gemfile dependency, 9 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.</programlisting>
<simpara>これで次の準備ができました。</simpara>
</section>
<section xml:id="_静的コード解析">
<title>静的コード解析</title>
<simpara>良いコードを書き続けるためにはコードの品質を維持していく必要があります。エピソード1では <emphasis role="strong">テスト駆動開発</emphasis> によりプログラムを動かしながら品質の改善していきました。出来上がったコードに対する品質チェックの方法として <emphasis role="strong">静的コード解析</emphasis> があります。Ruby用 <emphasis role="strong">静的コード解析</emphasis> ツール <link xl:href="https://github.com/rubocop-hq/rubocop">RuboCop</link> を使って確認してみましょう。プログラムは先程 <emphasis role="strong">Bundler</emphasis> を使ってインストールしたので以下のコマンドを実行します。</simpara>
<programlisting language="bash" linenumbering="unnumbered"> $ rubocop
Inspecting 5 files
CCCWW

Offenses:

Gemfile:3:8: C: Style/StringLiterals: Prefer single-quoted strings when you don't need string interpolation or special symbols.
source "https://rubygems.org"
       ^^^^^^^^^^^^^^^^^^^^^^
Gemfile:5:21: C: Layout/SpaceInsideBlockBraces: Space between { and | missing.
git_source(:github) {|repo_name| "https://github.com/#{repo_name}" }
                    ^^
...</programlisting>
<simpara>なにかいろいろ出てきましたね。RuboCopの詳細に関しては <link xl:href="https://qiita.com/tomohiii/items/1a17018b5a48b8284a8b">RuboCop is 何？</link>を参照ください。<literal>--lint</literal> オプションをつけて実施してみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rubocop --lint
Inspecting 5 files
...W.

Offenses:

test/fizz_buzz_test.rb:109:7: : Parenthesize the param %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i } to make sure that the block will be associated with the %w[2 4 13 3 1 10].sort method call.
      assert_equal %w[1 2 3 4 10 13], ...
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
test/fizz_buzz_test.rb:111:7: W: Lint/AmbiguousBlockAssociation: Parenthesize the param %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i } to make sure that the block will be associated with the %w[2 4 13 3 1 10].sort method call.
      assert_equal %w[13 10 4 3 2 1], ...
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

5 files inspected, 2 offenses detected</programlisting>
<simpara>また何やら出てきましたね。 <link xl:href="https://rubocop.readthedocs.io/en/latest/cops_lint/#lintambiguousblockassociation">W: Lint/AmbiguousBlockAssociation</link>のメッセージを調べたところ、<literal>fizz_buzz_test.rb</literal> の以下の学習用テストコードは書き方がよろしくないようですね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
      def test_指定した評価式で並び変えた配列を返す
        assert_equal %w[1 10 13 2 3 4], %w[2 4 13 3 1 10].sort
        assert_equal %w[1 2 3 4 10 13],
                     %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
        assert_equal %w[13 10 4 3 2 1],
                     %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }
      end
...</programlisting>
<simpara><emphasis role="strong">説明用変数の導入</emphasis> を使ってテストコードをリファクタリングしておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    def test_指定した評価式で並び変えた配列を返す
      result1 = %w[2 4 13 3 1 10].sort
      result2 = %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
      result3 = %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }

      assert_equal %w[1 10 13 2 3 4], result1
      assert_equal %w[1 2 3 4 10 13], result2
      assert_equal %w[13 10 4 3 2 1], result3
    end
...</programlisting>
<simpara>再度確認します。チェックは通りましたね。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rubocop --lint
Inspecting 5 files
.....

5 files inspected, no offenses detected</programlisting>
<simpara>テストも実行して壊れていないかも確認しておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fizz_buzz_test.rb
Started with run options --seed 42058

  19/19: [=========================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00257s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>いちいち調べるのも手間なので自動で修正できるところは修正してもらいましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rubocop --auto-correct</programlisting>
<simpara>再度確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered"> $ rubocop
Inspecting 5 files
...CC

Offenses:

test/fizz_buzz_test.rb:15:11: C: Naming/MethodName: Use snake_case for method names.
      def test_3を渡したら文字列Fizzを返す
          ^^^^^^^^^^^^^^^^^^^^^
...</programlisting>
<simpara>まだ、自動修正できなかった部分があるようですね。この部分はチェック対象から外すことにしましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rubocop --auto-gen-config
Added inheritance from `.rubocop_todo.yml` in `.rubocop.yml`.
Phase 1 of 2: run Layout/LineLength cop
Inspecting 5 files
.....

5 files inspected, no offenses detected
Created .rubocop_todo.yml.
Phase 2 of 2: run all cops
Inspecting 5 files
.C.CW

5 files inspected, 110 offenses detected
Created .rubocop_todo.yml.</programlisting>
<simpara>生成された <literal>.rubocop_todo.yml</literal> の以下の部分を変更します。</simpara>
<programlisting language="yml" linenumbering="unnumbered">...
# Offense count: 32
# Configuration parameters: IgnoredPatterns.
# SupportedStyles: snake_case, camelCase
Naming/MethodName:
  EnforcedStyle: snake_case
  Exclude:
    - 'test/fizz_buzz_test.rb'
...</programlisting>
<simpara>再度チェックを実行します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rubocop
Inspecting 5 files
.....

5 files inspected, no offenses detected</programlisting>
<simpara>セットアップができたのでここでコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'chore: 静的コード解析セットアップ'</programlisting>
</section>
<section xml:id="_コードフォーマッタ">
<title>コードフォーマッタ</title>
<simpara>良いコードであるためにはフォーマットも大切な要素です。</simpara>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>優れたソースコードは「目に優しい」ものでなければいけない。</simpara>
</blockquote>
<simpara>Rubyにはいくつかフォーマットアプリケーションはあるのですがここは <literal>RuboCop</literal> の機能を使って実現することにしましょう。以下のコードのフォーマットをわざと崩してみます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number)
          isFizz = number.modulo(3).zero?
    isBuzz = number.modulo(5).zero?

    return 'FizzBuzz' if isFizz &amp;&amp; isBuzz
    return 'Fizz' if isFizz
    return 'Buzz' if isBuzz

    number.to_s
  end

  def self.generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<simpara>スタイルオプションをつけてチェックしてみます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rubocop --only Layout
Inspecting 5 files
.C...

Offenses:

lib/fizz_buzz.rb:7:3: C: Layout/IndentationWidth: Use 2 (not 8) spaces for indentation.
          isFizz = number.modulo(3).zero?
  ^^^^^^^^
lib/fizz_buzz.rb:8:5: C: Layout/IndentationConsistency: Inconsistent indentation detected.
    isBuzz = number.modulo(5).zero?
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:10:5: C: Layout/IndentationConsistency: Inconsistent indentation detected.
    return 'FizzBuzz' if isFizz &amp;&amp; isBuzz
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:11:5: C: Layout/IndentationConsistency: Inconsistent indentation detected.
    return 'Fizz' if isFizz
    ^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:12:5: C: Layout/IndentationConsistency: Inconsistent indentation detected.
    return 'Buzz' if isBuzz
    ^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:14:5: C: Layout/IndentationConsistency: Inconsistent indentation detected.
    number.to_s
    ^^^^^^^^^^^

5 files inspected, 6 offenses detected</programlisting>
<simpara>編集した部分が <literal>Use 2 (not 8) spaces for indentation.</literal> と指摘されています。 <literal>--fix-layout</literal> オプションで自動保存しておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rubocop --fix-layout
Inspecting 5 files
.C...

Offenses:

lib/fizz_buzz.rb:7:3: C: [Corrected] Layout/IndentationWidth: Use 2 (not 8) spaces for indentation.
          isFizz = number.modulo(3).zero?
  ^^^^^^^^
lib/fizz_buzz.rb:8:5: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
    isBuzz = number.modulo(5).zero?
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:8:11: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
          isBuzz = number.modulo(5).zero?
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:10:5: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
    return 'FizzBuzz' if isFizz &amp;&amp; isBuzz
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:10:11: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
          return 'FizzBuzz' if isFizz &amp;&amp; isBuzz
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:11:5: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
    return 'Fizz' if isFizz
    ^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:11:11: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
          return 'Fizz' if isFizz
          ^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:12:5: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
    return 'Buzz' if isBuzz
    ^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:12:11: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
          return 'Buzz' if isBuzz
          ^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:14:5: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
    number.to_s
    ^^^^^^^^^^^
lib/fizz_buzz.rb:14:11: C: [Corrected] Layout/IndentationConsistency: Inconsistent indentation detected.
          number.to_s
          ^^^^^^^^^^^

5 files inspected, 11 offenses detected, 11 offenses corrected</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number)
    isFizz = number.modulo(3).zero?
    isBuzz = number.modulo(5).zero?

    return 'FizzBuzz' if isFizz &amp;&amp; isBuzz
    return 'Fizz' if isFizz
    return 'Buzz' if isBuzz

    number.to_s
  end

  def self.generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ rubocop --only Layout
Inspecting 5 files
.....

5 files inspected, no offenses detected</programlisting>
<simpara>フォーマットが修正されたことが確認できましたね。ちなみに <literal>--auto-correct</literal> オプションでもフォーマットをしてくれるので通常はこちらのオプションで問題ないと思います。</simpara>
</section>
<section xml:id="_コードカバレッジ">
<title>コードカバレッジ</title>
<simpara>静的コードコード解析による品質の確認はできました。では動的なテストに関してはどうでしょうか？ <emphasis role="strong">コードカバレッジ</emphasis> を確認する必要あります。</simpara>
<blockquote>
<attribution>
ウィキペディア
</attribution>
<simpara>コード網羅率（コードもうらりつ、英: Code coverage ）コードカバレッジは、ソフトウェアテストで用いられる尺度の1つである。プログラムのソースコードがテストされた割合を意味する。この場合のテストはコードを見ながら行うもので、ホワイトボックステストに分類される。</simpara>
</blockquote>
<simpara>Ruby用 <emphasis role="strong">コードカバレッジ</emphasis> 検出プログラムとして <link xl:href="https://github.com/colszowka/simplecov">SimpleCov</link>を使います。Gemfileに追加して <emphasis role="strong">Bundler</emphasis> でインストールをしましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

source 'https://rubygems.org'

git_source(:github) { |repo_name| "https://github.com/#{repo_name}" }

gem 'minitest'
gem 'minitest-reporters'
gem 'rubocop', require: false
gem 'simplecov', require: false, group: :test</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ bundle install
Fetching gem metadata from https://rubygems.org/..................
Resolving dependencies...
Fetching ansi 1.5.0
Installing ansi 1.5.0
Using ast 2.4.0
Fetching builder 3.2.4
Installing builder 3.2.4
Using bundler 2.1.4
Using docile 1.3.2
Using jaro_winkler 1.5.4
Using json 2.3.0
Fetching minitest 5.14.0
Installing minitest 5.14.0
Using ruby-progressbar 1.10.1
Fetching minitest-reporters 1.4.2
Installing minitest-reporters 1.4.2
Using parallel 1.19.1
Using parser 2.7.0.2
Using rainbow 3.0.0
Using unicode-display_width 1.6.1
Using rubocop 0.79.0
Using simplecov-html 0.10.2
Using simplecov 0.17.1
Bundle complete! 4 Gemfile dependencies, 17 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.</programlisting>
<simpara>サイトの説明に従ってテストコードの先頭に以下のコードを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true
require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'
...</programlisting>
<simpara>テストを実施します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fizz_buzz_test.rb
Started with run options --seed 10538

  19/19: [===============================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00297s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テスト実行後に <literal>coverage</literal> というフォルダが作成されます。その中の <literal>index.html</literal> を開くとカバレッジ状況を確認できます。セットアップが完了したらコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'chore: コードカバレッジセットアップ'</programlisting>
</section>
<section xml:id="_タスクランナー">
<title>タスクランナー</title>
<simpara>ここまででテストの実行、静的コード解析、コードフォーマット、コードカバレッジを実施することができるようになりました。でもコマンドを実行するのにそれぞれコマンドを覚えておくのは面倒ですよね。例えばテストの実行は</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fizz_buzz_test.rb
Started with run options --seed 21943

  19/19: [=======================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00261s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>このようにしていました。では静的コードの解析はどうやりましたか？フォーマットはどうやりましたか？調べるのも面倒ですよね。いちいち調べるのが面倒なことは全部 <emphasis role="strong">タスクランナー</emphasis> にやらせるようにしましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>タスクランナーとは、アプリケーションのビルドなど、一定の手順で行う作業をコマンド一つで実行できるように予めタスクとして定義したものです。</simpara>
</blockquote>
<simpara>Rubyの <emphasis role="strong">タスクランナー</emphasis> は <literal>Rake</literal> です。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>RakeはRubyにおけるタスクランナーです。rakeコマンドと起点となるRakefileというタスクを記述するファイルを用意することで、タスクの実行や登録されたタスクの一覧表示を行えます。</simpara>
</blockquote>
<simpara>早速、テストタスクから作成しましょう。まず <literal>Rakefile</literal> を作ります。Mac/Linuxでは <literal>touch</literal> コマンドでファイルを作れます。Windowsの場合は手作業で追加してください。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ touch Rakefile</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">require 'rake/testtask'

task default: [:test]

Rake::TestTask.new do |test|
  test.test_files = Dir['./test/fizz_buzz_test.rb']
  test.verbose = true
end</programlisting>
<simpara>タスクが登録されたか確認してみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake -T
rake test  # Run tests</programlisting>
<simpara>タスクが登録されたことが確認できたのでタスクを実行します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake test
/Users/k2works/.rbenv/versions/2.5.5/bin/ruby -w -I"lib" -I"/Users/k2works/.rbenv/versions/2.5.5/lib/ruby/gems/2.5.0/gems/rake-13.0.1/lib" "/Users/k2works/.rbenv/versions/2.5.5/lib/ruby/gems/2.5.0/gems/rake-13.0.1/lib/rake/rake_test_loader.rb" "./test/fizz_buzz_test.rb"
/Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/test/fizz_buzz_test.rb:79: warning: method redefined; discarding old test_特定の条件を満たす要素だけを配列に入れて返す
/Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/test/fizz_buzz_test.rb:74: warning: previous definition of test_特定の条件を満たす要素だけを配列に入れて返す was here
/Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/test/fizz_buzz_test.rb:94: warning: method redefined; discarding old test_新しい要素の配列を返す
/Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/test/fizz_buzz_test.rb:89: warning: previous definition of test_新しい要素の配列を返す was here
/Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/test/fizz_buzz_test.rb:104: warning: method redefined; discarding old test_配列の中から条件に一致する要素を取得する
/Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/test/fizz_buzz_test.rb:99: warning: previous definition of test_配列の中から条件に一致する要素を取得する was here
/Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/test/fizz_buzz_test.rb:138: warning: method redefined; discarding old test_畳み込み演算を行う
/Users/k2works/Projects/hiroshima-arc/tdd_rb/docs/src/article/code/test/fizz_buzz_test.rb:133: warning: previous definition of test_畳み込み演算を行う was here
Started with run options --seed 5886

  19/19: [=======================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00271s
19 tests, 21 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストは実施されたのですが警告メッセージが表示されるようになりました。メッセージの内容としては <emphasis role="strong">学習用テスト</emphasis> のテストメソッド名が重複していることが理由のようです。せっかくなので修正しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  describe 'FizzBuzz' do
  ...
  end

  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&amp;:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&amp;:size)
      assert_equal 'apple', result
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&amp;:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      result1 = %w[2 4 13 3 1 10].sort
      result2 = %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
      result3 = %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }

      assert_equal %w[1 10 13 2 3 4], result1
      assert_equal %w[1 2 3 4 10 13], result2
      assert_equal %w[13 10 4 3 2 1], result3
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item &lt; 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item &lt; 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
end</programlisting>
<simpara><emphasis role="strong">メソッド名の変更</emphasis> を適用してリファクタリングしましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  describe 'FizzBuzz' do
  ...
  end

  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_selectメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_find_allメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&amp;:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_mapメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_collectメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_findメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&amp;:size)
      assert_equal 'apple', result
    end

    def test_detectメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&amp;:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      result1 = %w[2 4 13 3 1 10].sort
      result2 = %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
      result3 = %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }

      assert_equal %w[1 10 13 2 3 4], result1
      assert_equal %w[1 2 3 4 10 13], result2
      assert_equal %w[13 10 4 3 2 1], result3
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item &lt; 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item &lt; 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_injectメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_reduceメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
end</programlisting>
<simpara>テストを再実行して警告メッセージが消えたこと確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake test
/home/gitpod/.rvm/rubies/ruby-2.6.3/bin/ruby -w -I"lib" -I"/home/gitpod/.rvm/rubies/ruby-2.6.3/lib/ruby/gems/2.6.0/gems/rake-12.3.2/lib" "/home/gitpod/.rvm/rubies/ruby-2.6.3/lib/ruby/gems/2.6.0/gems/rake-12.3.2/lib/rake/rake_test_loader.rb" "./test/fizz_buzz_test.rb"
Started with run options --seed 10674

  24/24: [=========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00396s
24 tests, 26 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストタスクが実行されたことが確認できたので引き続き静的コードの解析タスクを追加します。こちらも開発元がタスクを用意しているのでそちらを使うことにします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'rake/testtask'
require 'rubocop/rake_task'
RuboCop::RakeTask.new

task default: [:test]

Rake::TestTask.new do |test|
  test.test_files = Dir['./test/fizz_buzz_test.rb']
  test.verbose = true
end</programlisting>
<simpara>タスクが登録されたことを確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake -T
rake rubocop               # Run RuboCop
rake rubocop:auto_correct  # Auto-correct RuboCop offenses
rake test                  # Run tests</programlisting>
<simpara>続いてタスクを実行してみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake rubocop
Running RuboCop...
Inspecting 5 files
.C..C

Offenses:

Rakefile:1:1: C: Style/FrozenStringLiteralComment: Missing magic comment # frozen_string_literal: true.
require 'rake/testtask'
^
Rakefile:10:4: C: Layout/TrailingEmptyLines: Final newline missing.
end

test/fizz_buzz_test.rb:2:1: C: Layout/EmptyLineAfterMagicComment: Add an empty line after magic comments.
require 'simplecov'
^
test/fizz_buzz_test.rb:148:6: C: Layout/TrailingWhitespace: Trailing whitespace detected.
  end
     ^^

5 files inspected,</programlisting>
<simpara>いろいろ出てきましたので自動修正しましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake rubocop:auto_correct
Running RuboCop...
Inspecting 5 files
.C..C

Offenses:

Rakefile:1:1: C: [Corrected] Style/FrozenStringLiteralComment: Missing magic comment # frozen_string_literal: true.
require 'rake/testtask'
^
Rakefile:2:1: C: [Corrected] Layout/EmptyLineAfterMagicComment: Add an empty line after magic comments.
require 'rake/testtask'
^
Rakefile:10:4: C: [Corrected] Layout/TrailingEmptyLines: Final newline missing.
end

test/fizz_buzz_test.rb:2:1: C: [Corrected] Layout/EmptyLineAfterMagicComment: Add an empty line after magic comments.
require 'simplecov'
^
test/fizz_buzz_test.rb:148:6: C: [Corrected] Layout/TrailingWhitespace: Trailing whitespace detected.
  end
     ^^

5 files inspected, 5 offenses detected, 5 offenses corrected</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">$ rake rubocop
Running RuboCop...
Inspecting 5 files
.....

5 files inspected, no offenses detected</programlisting>
<simpara>うまく修正されたようですね。後、フォーマットコマンドもタスクとして追加しておきましょう。こちらは開発元が用意していないタスクなので以下のように追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'rake/testtask'
require 'rubocop/rake_task'
RuboCop::RakeTask.new

task default: [:test]

Rake::TestTask.new do |test|
  test.test_files = Dir['./test/fizz_buzz_test.rb']
  test.verbose = true
end

desc "Run Format"
task :format do
  sh "rubocop --fix-layout"
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ rake -T
rake format                # Run Format
rake rubocop               # Run RuboCop
rake rubocop:auto_correct  # Auto-correct RuboCop offenses
rake test                  # Run tests</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ rake format
rubocop --fix-layout
Inspecting 5 files
.C...

Offenses:

Rakefile:17:4: C: [Corrected] Layout/TrailingEmptyLines: Final newline missing.
end


5 files inspected, 1 offense detected, 1 offense corrected</programlisting>
<simpara>フォーマットは <literal>rake rubocop:auto_correct</literal> で一緒にやってくれるので特に必要は無いのですがプログラムの開発元が提供していないタスクを作りたい場合はこのように追加します。セットアップができたのでコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'chore: タスクランナーセットアップ'</programlisting>
</section>
<section xml:id="_タスクの自動化">
<title>タスクの自動化</title>
<simpara>良いコードを書くためのタスクをまとめることができました。でも、どうせなら自動で実行できるようにしたいですよね。
タスクを自動実行するためのgemを追加します。 <link xl:href="https://github.com/guard/guard">Guard</link>とそのプラグインの <link xl:href="https://github.com/guard/guard-shell">Guard::Shell</link> <link xl:href="https://github.com/guard/guard-minitest">Guard::Minitest</link> <link xl:href="https://github.com/yujinakayama/guard-rubocop">guard-rubocop</link> をインストールします。それぞれの詳細は以下を参照してください。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://qiita.com/tbpgr/items/f5be21d8e19dd852d9b7">Ruby | Guard gem を利用してファイルの変更を検出し、任意のタスクを自動実行する</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/emergent/items/0a38909206844265e0b5">guard-shellでソースコードの変更を監視して自動でmake＆実行させる</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://forest-valley17.hatenablog.com/entry/2018/10/05/183521">Rails - Guardを使い、ファイル変更時にMinitestやRspecを自動実行する</link></simpara>
</listitem>
</itemizedlist>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

source 'https://rubygems.org'

git_source(:github) { |repo_name| "https://github.com/#{repo_name}" }

gem 'guard'
gem 'guard-minitest'
gem 'guard-rubocop'
gem 'guard-shell'
gem 'minitest'
gem 'minitest-reporters'
gem 'rake'
gem 'rubocop', require: false
gem 'simplecov', require: false, group: :test</programlisting>
<simpara><literal>bundle install</literal> は <literal>bundle</literal> に省略できます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ bundle
$ guard init</programlisting>
<simpara><literal>Guardfile</literal> が生成されるので以下の内容に変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

# Add files and commands to this file, like the example:
#   watch(%r{file/path}) { `command(s)` }
#
guard :shell do
  watch(%r{lib/(.*).rb}) { |_m| `rake test` }
end

guard :minitest do
  # with Minitest::Unit
  watch(%r{test\/*.rb})
end

guard :rubocop, cli: %w[--auto-correct --format fuubar --format html -o ./tmp/rubocop_results.html] do
  watch(/(.*).rb/)
end</programlisting>
<simpara><literal>guard</literal> が起動するか確認して一旦終了します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ guard start
Warning: the running version of Bundler (2.1.3) is older than the version that created the lockfile (2.1.4). We suggest you to upgrade to the version that created the lockfile by running `gem install bundler:2.1.4`.
03:49:28 - INFO - Guard::Minitest 2.4.6 is running, with Minitest::Unit 5.14.0!
03:49:28 - INFO - Running: all tests
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 4 / 11 LOC (36.36%) covered.
Started with run options --guard --seed 1256

  24/24: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00363s
24 tests, 26 assertions, 0 failures, 0 errors, 0 skips

03:49:28 - INFO - Inspecting Ruby code style of all files
Gemfile:15:46: C: [Corrected] Layout/TrailingEmptyLines: Final newline missing.
gem 'simplecov', require: false, group: :test

Guardfile:17:4: C: [Corrected] Layout/TrailingEmptyLines: Final newline missing.
end

 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, 2 offenses detected, 2 offenses corrected
03:49:30 - INFO - Guard is now watching at '/workspace/tdd_rb'
[1] guard(main)&gt; exit

03:50:31 - INFO - Bye bye...</programlisting>
<simpara>続いて <literal>Rakefile</literal> にguardタスクを追加します。あと、guardタスクをデフォルトにして <literal>rake</literal> を実行すると呼び出されるようにしておきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'rake/testtask'
require 'rubocop/rake_task'
RuboCop::RakeTask.new

task default: [:guard]

Rake::TestTask.new do |test|
  test.test_files = Dir['./test/fizz_buzz_test.rb']
  test.verbose = true
end

desc 'Run Format'
task :format do
  sh 'rubocop --fix-layout'
end

desc 'Run Guard'
task :guard do
  sh 'guard start'
end</programlisting>
<simpara>自動実行タスクを起動しましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake
guard start
03:52:01 - INFO - Guard::Minitest 2.4.6 is running, with Minitest::Unit 5.14.0!
03:52:01 - INFO - Running: all tests
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 4 / 11 LOC (36.36%) covered.
Started with run options --guard --seed 3219

  24/24: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00844s
24 tests, 26 assertions, 0 failures, 0 errors, 0 skips

03:52:01 - INFO - Inspecting Ruby code style of all files
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
03:52:03 - INFO - Guard is now watching at '/workspace/tdd_rb'
[1] guard(main)&gt;</programlisting>
<simpara>起動したら <literal>fizz_buzz_test.rb</literal> を編集してテストが自動実行されるか確認しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe 'FizzBuzz' do
    def setup
      @fizzbuzz = FizzBuzz
    end

    describe '三の倍数の場合' do
      def test_3を渡したら文字列Fizzを返す
        assert_equal 'FizzFizz', @fizzbuzz.generate(3)
      end
    end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">05:00:34 - INFO - Running: all tests
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 4 / 11 LOC (36.36%) covered.
Started with run options --guard --seed 16292

 FAIL["test_3を渡したら文字列Fizzを返す", #&lt;Minitest::Reporters::Suite:0x000055640e99f080 @name="FizzBuzz::三の倍数の場合"&gt;, 0.005698626991943456]
 test_3を渡したら文字列Fizzを返す#FizzBuzz::三の倍数の場合 (0.01s)
        Expected: "FizzFizz"
          Actual: "Fizz"
        /workspace/tdd_rb/test/fizz_buzz_test.rb:18:in `test_3を渡したら文字列Fizzを返す'

  24/24: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00742s
24 tests, 26 assertions, 1 failures, 0 errors, 0 skips

05:00:35 - INFO - Inspecting Ruby code style: test/fizz_buzz_test.rb
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected
05:00:36 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/controls.png
 0/0 files |====================================== 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
[1] guard(main)&gt;</programlisting>
<simpara>変更を感知してテストが実行されるた結果失敗していましました。コードを元に戻してテストをパスするようにしておきましょう。テストがパスすることが確認できたらコミットしておきましょう。このときターミナルでは <literal>guard</literal> が動いているので別ターミナルを開いてコミットを実施すると良いでしょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'chore: タスクの自動化'</programlisting>
<simpara>これで <link xl:href="https://t-wada.hatenablog.jp/entry/clean-code-that-works">ソフトウェア開発の三種の神器</link>の最後のアイテムの準備ができました。次回の開発からは最初にコマンドラインで <literal>rake</literal> を実行すれば良いコードを書くためのタスクを自動でやってくるようになるのでコードを書くことに集中できるようになりました。では、次のエピソードに進むとしましょう。</simpara>
</section>
</section>
</section>
<section xml:id="_エピソード3">
<title>エピソード3</title>
<section xml:id="_オブジェクト指向から始めるテスト駆動開発">
<title>オブジェクト指向から始めるテスト駆動開発</title>
<section xml:id="_テスト駆動開発">
<title>テスト駆動開発</title>
<simpara>エピソード1ので作成したプログラムに以下の仕様を追加します。</simpara>
<simpara>仕様</simpara>
<literallayout class="monospaced">1 から 100 までの数をプリントするプログラムを書け。
ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、
3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。
タイプごとに出力を切り替えることができる。
タイプ１は通常、タイプ２は数字のみ、タイプ３は FizzBuzz の場合のみをプリントする。</literallayout>
<simpara>早速開発に取り掛かりましょう。エピソード2で開発環境の自動化をしているので以下のコマンドを実行するだけで開発を始めることができます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake</programlisting>
<simpara><literal>guard</literal> が起動するとコンソールが使えなくなるのでもう一つコンソールを開いておきましょう。もしくは <literal>.</literal> を使うことで <literal>guard</literal> 内でコンソールのコマンドを呼び出すことができます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">[1] guard(main)&gt; . ls
coverage  Gemfile.lock  lib      provisioning  README.md  tmp
Gemfile   Guardfile     main.rb  Rakefile      test       Vagrantfile
[2] guard(main)&gt; . pwd
/workspace/tdd_rb
[3] guard(main)&gt; . git status</programlisting>
<section xml:id="_todoリスト作成">
<title>TODOリスト作成</title>
<simpara>まずは追加仕様を <emphasis role="strong">TODOリスト</emphasis> に落とし込んでいきます。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>タイプ1の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_タイプ1の場合">
<title>タイプ1の場合</title>
<simpara><emphasis role="strong">テストファースト</emphasis> <emphasis role="strong">アサートファースト</emphasis> で最初に失敗するテストから始めます。テストを追加しましょう。</simpara>
<simpara>ここでは既存の <literal>FizzBuzz.generate</literal> メソッドにタイプを <emphasis role="strong">引数</emphasis> として追加することで対応できるように変更してみたいと思います。まず、 <literal>fizz_buzz_test.rb</literal> ファイルに以下のテストコードを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  end

  describe 'タイプごとに出力を切り替えることができる' do
    describe 'タイプ1の場合' do
      def test_1を渡したら文字列1を返す
        assert_equal '1', FizzBuzz.generate(1, 1)
      end
    end
  end

  describe '配列や繰り返し処理を理解する' do
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
05:32:51 - INFO - Running: all tests
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 4 / 11 LOC (36.36%) covered.
Started with run options --guard --seed 37049

ERROR["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00005623e6a24260 @name="タイプごとに出力を切り替えることができる::タイプ1の場合"&gt;, 0.0019176720088580623]
 test_1を渡したら文字列1を返す#タイプごとに出力を切り替えることができる::タイプ1の場合 (0.00s)
Minitest::UnexpectedError:         ArgumentError: wrong number of arguments (given 2, expected 1)
            /workspace/tdd_rb/lib/fizz_buzz.rb:6:in `generate'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:74:in `test_1を渡したら文字列1を返す'

  25/25: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00796s
25 tests, 26 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara><literal>ArgumentError: wrong number of arguments (given 2, expected 1)</literal> <emphasis role="strong">引数</emphasis> が違うと指摘されていますね。 <literal>FizzBuzz.generate</literal> メソッドの引数の変更したいのですが既存のテストを壊したくないのでここは <emphasis role="strong">デフォルト引数</emphasis> 使ってみましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>メソッドの引数にはデフォルト値を指定する定義方法があります。これは、メソッドの引数を省略した場合に割り当てられる値です。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
05:32:52 - INFO - Inspecting Ruby code style: test/fizz_buzz_test.rb Guardfile
 2/2 files |====================================== 100 =======================================&gt;| Time: 00:00:00

2 files inspected, no offenses detected
05:32:54 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |====================================== 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
05:37:29 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
lib/fizz_buzz.rb:6:29: W: [Corrected] Lint/UnusedMethodArgument: Unused method argument - type. If it's necessary, use _ or _type as an argument name to indicate that it won't be used.
  def self.generate(number, type = 1)
                            ^^^^
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, 1 offense detected, 1 offense corrected
05:37:31 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected
[1] guard(main)&gt;
05:39:37 - INFO - Run all
05:39:37 - INFO - Running: all tests
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 4 / 11 LOC (36.36%) covered.
Started with run options --guard --seed 8607

  25/25: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00723s
25 tests, 27 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>ちなみにここでは 引数に <literal>type=1</literal> と入力したのですがコードフォーマットによって以下のように自動修正されます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, _type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
...</programlisting>
<simpara><emphasis role="strong">case式</emphasis> を使って <emphasis role="strong">引数</emphasis> を判定できるように変更しましょう。ちなみに <literal>_type</literal> をメソッド内で変数として使うと警告されるので <literal>type</literal> に変更しています。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    case type
    when 1
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 51330


Progress: |=============================================================|

Finished in 0.00828s
25 tests, 27 assertions, 0 failures, 0 errors, 0 skips
04:27:12 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |=================== 100 ====================&gt;| Time: 00:00:00

1 file inspected, no offenses detected
04:27:13 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |=================== 100 ===================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
...</programlisting>
<simpara>テストは無事通りました。ここでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: タイプ1の場合'</programlisting>
<simpara>追加仕様の取っ掛かりができました。既存のテストを流用したいので先程作成したテストを削除して以下のように新しいグループ内に既存テストコードを移動しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...

class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.generate(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.generate(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1)
        end
      end

      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          @result = FizzBuzz.generate_list
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2]
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4]
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14]
        end
      end
    end
  end
...</programlisting>
<simpara>テストコードが壊れていないことを確認したらコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッドのインライン化'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>タイプ1の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数の代わりに｢Fizz｣と返す_</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"Fizz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す_</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"Buzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す_</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">15を渡したら文字列"FizzBuzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>タイプ2の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"15"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"FizzBuzz"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_タイプ2の場合">
<title>タイプ2の場合</title>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>タイプ2の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"15"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"FizzBuzz"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>続いて、タイプ2の場合に取り掛かりましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1, 2)
        end
      end
    end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
FAIL["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00005555ec747100 @name="数を文字列にして返す::タイプ2の場合::その他の場合"&gt;, 0.002283181995153427]
 test_1を渡したら文字列1を返す#数を文字列にして返す::タイプ2の場合::その他の場合 (0.00s)
        Expected: "1"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:75:in `test_1を渡したら文字列1を返す'

  24/24: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00437s
24 tests, 26 assertions, 1 failures, 0 errors, 0 skips
...</programlisting>
<simpara>まだ <emphasis role="strong">引数</emphasis> に2を渡した場合は何もしないので <emphasis role="strong">case式</emphasis> に2を渡した場合の処理を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    case type
    when 1
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 19625


Progress: |=============================================================================|

Finished in 0.00894s
24 tests, 26 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>テストが通ったのでテストケースを追加します。ここはタイプ1の場合をコピーして編集すれば良いでしょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
   end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3, 2)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5, 2)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.generate(15, 2)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1, 2)
        end
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 4 / 13 LOC (30.77%) covered.
Started with run options --guard --seed 898

  27/27: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00900s
27 tests, 29 assertions, 0 failures, 0 errors, 0 skips

06:27:40 - INFO - Inspecting Ruby code style of all files
test/fizz_buzz_test.rb:11:3: C: Metrics/BlockLength: Block has too many lines. [70/62]
  describe '数を文字列にして返す' do ...
  ^^^^^^^^^^^^^^^^^^^^^^^^
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, 1 offense detected
...</programlisting>
<simpara>テストは通りましたが何やら警告が表示されるようになりました。　https://rubocop.readthedocs.io/en/latest/cops_metrics/#metricsblocklength[Metrics/BlockLength: Block has too many lines.^] これは <literal>数を文字列にして返す</literal> テストケースのコードブロックが長いという警告のようですがテストコードはチェックの対象から外しておきたいので <literal>.rubocop_todo.yml</literal> に以下コードを追加してチェック対象から外しておきます。</simpara>
<programlisting language="yml" linenumbering="unnumbered">...
# Offense count: 2
# Configuration parameters: CountComments, ExcludedMethods.
# ExcludedMethods: refine
Metrics/BlockLength:
  Max: 62
  Exclude:
    - 'test/fizz_buzz_test.rb'
...</programlisting>
<simpara>ちなみに <literal>guard(main)&gt;</literal> にカーソルを合わせてエンターキーを押すと自動化タスクが実行されます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">[1] guard(main)&gt;
02:03:15 - INFO - Run all
/home/gitpod/.rvm/rubies/ruby-2.6.3/bin/ruby -w -I"lib" -I"/workspace/.rvm/gems/rake-13.0.1/lib" "/workspace/.rvm/gems/rake-13.0.1/lib/rake/rake_test_loader.rb" "./test/fizz_buzz_test.rb"
/home/gitpod/.rvm/rubies/ruby-2.6.3/bin/ruby -w -I"lib" -I"/workspace/.rvm/gems/rake-13.0.1/lib" "/workspace/.rvm/gems/rake-13.0.1/lib/rake/rake_test_loader.rb" "./test/fizz_buzz_test.rb"
Started with run options --seed 47335


Progress: |==============================================================================|

Finished in 0.00781s
27 tests, 29 assertions, 0 failures, 0 errors, 0 skips
Started with run options --seed 47825


Progress: |==============================================================================|

Finished in 0.00761s
27 tests, 29 assertions, 0 failures, 0 errors, 0 skips
02:03:17 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 13 / 13 LOC (100.0%) covered.
Started with run options --guard --seed 17744

  27/27: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00789s
27 tests, 29 assertions, 0 failures, 0 errors, 0 skips

02:03:17 - INFO - Inspecting Ruby code style of all files
 7/7 files |=========================== 100 ============================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
02:03:19 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png
 0/0 files |=========================== 100 ============================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
[1] guard(main)&gt;</programlisting>
<simpara>警告は消えたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: タイプ2の場合'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>タイプ2の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"3"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"5"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">15を渡したら文字列"15"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"FizzBuzz"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_タイプ3の場合">
<title>タイプ3の場合</title>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ2の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"FizzBuzz"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>続いて、タイプ3の場合ですがやることは同じなので今回は一気にテストを書いてみましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3, 3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5, 3)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15, 3)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1, 3)
        end
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00005642171ea5a0 @name="数を文字列にして返す::タイプ3の場合::その他の場合"&gt;, 0.003375133004738018]
 test_1を渡したら文字列1を返す#数を文字列にして返す::タイプ3の場合::その他の場合 (0.00s)
        Expected: "1"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:123:in `test_1を渡したら文字列1を返す'

 FAIL["test_5を渡したら文字列5を返す", #&lt;Minitest::Reporters::Suite:0x000056421723af78 @name="数を文字列にして返す::タイプ3の場合::五の倍数の場合"&gt;, 0.003832244998193346]
 test_5を渡したら文字列5を返す#数を文字列にして返す::タイプ3の場合::五の倍数の場合 (0.00s)
        Expected: "5"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:111:in `test_5を渡したら文字列5を返す'

 FAIL["test_3を渡したら文字列3を返す", #&lt;Minitest::Reporters::Suite:0x0000564217297340 @name="数を文字列にして返す::タイプ3の場合::三の倍数の場合"&gt;, 0.0043466729985084385]
 test_3を渡したら文字列3を返す#数を文字列にして返す::タイプ3の場合::三の倍数の場合 (0.00s)
        Expected: "3"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:105:in `test_3を渡したら文字列3を返す'

 FAIL["test_15を渡したら文字列FizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x00005642174dec98 @name="数を文字列にして返す::タイプ3の場合::三と五の倍数の場合"&gt;, 0.006096020006225444]
 test_15を渡したら文字列FizzBuzzを返す#数を文字列にして返す::タイプ3の場合::三と五の倍数の場合 (0.01s)
        Expected: "FizzBuzz"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:117:in `test_15を渡したら文字列FizzBuzzを返す'

  31/31: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00650s
31 tests, 33 assertions, 4 failures, 0 errors, 0 skips
...</programlisting>
<simpara><emphasis role="strong">case式</emphasis> に処理を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    case type
    when 1
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 12137


Progress: |=============================================================================|

Finished in 0.01662s
31 tests, 33 assertions, 0 failures, 0 errors, 0 skips
05:06:44 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png lib/fizz_buzz.rb
lib/fizz_buzz.rb:6:3: C: Metrics/CyclomaticComplexity: Cyclomatic complexity for generate is too high. [10/8]
  def self.generate(number, type = 1) ...
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:6:3: C: Metrics/PerceivedComplexity: Perceived complexity for generate is too high. [8/7]
  def self.generate(number, type = 1) ...
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 1/1 file |=========================== 100 ============================&gt;| Time: 00:00:00

1 file inspected, 2 offenses detected
...</programlisting>
<simpara>テストは通りましたが新しい警告が表示されるようになりました。とりあえずコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: タイプ3の場合'</programlisting>
<simpara>処理の追加により一部重複が発生しました。ここは、 <emphasis role="strong">ステートメントのスライド</emphasis> を適用して重複をなくしておきましょう。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>ステートメントのスライド</simpara>
<simpara>旧：重複した条件記述の断片の統合</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>重複した条件記述の断片の統合</simpara>
<simpara>条件式のすべて分岐に同じコードの断片がある。</simpara>
<simpara>それを式の外側に移動する。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    case type
    when 1
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    end
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    end
  end
...</programlisting>
<simpara>警告は消えていませんがプログラムは壊れていないことが確認できたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: ステートメントのスライド'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ2の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"3"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"5"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">15を渡したら文字列"FizzBuzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_それ以外のタイプの場合">
<title>それ以外のタイプの場合</title>
<simpara>追加仕様には対応しましたがタイプ1,2,3以外の値が <emphasis role="strong">引数</emphasis> として渡された場合はどうしましょうか？
現状では <literal>nil</literal> を返しますがこのような例外ケースも考慮する必要があります。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ2の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ3の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>それ以外のタイプの場合</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">例外処理</emphasis> を追加します。まず、例外のテストですが以下の様に書きます。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>例外とは記述したプログラムが想定していない値を受け取ったり、何らかの障害が発生した場合に処理を中断して、例外オブジェクトを生成して呼び出し元のメソッドに処理を戻す機構です。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">    describe 'タイプ3の場合' do
...
    end

    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      def test_例外を返す
        e = assert_raises RuntimeError do
          @fizzbuzz.generate(1, 4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_例外を返す", #&lt;Minitest::Reporters::Suite:0x0000558a26888e60 @name="数を文字列にして返す::それ以外のタイプの場合"&gt;, 0.003033002998563461]
 test_例外を返す#数を文字列にして返す::それ以外のタイプの場合 (0.00s)
        RuntimeError expected but nothing was raised.
        /workspace/tdd_rb/test/fizz_buzz_test.rb:134:in `test_例外を返す'

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00609s
32 tests, 34 assertions, 1 failures, 0 errors, 0 skips
...</programlisting>
<simpara><emphasis role="strong">case式</emphasis> に該当しないタイプが指定された場合は <emphasis role="strong">例外を発生させる</emphasis> ようにします。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>例外を明示的に発生させるには「raise」を使います。raiseには発生させたい例外クラスを指定するのですが、何も指定しない場合はRuntimeErrorオブジェクトが生成されます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:04:53 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 16 / 16 LOC (100.0%) covered.
Started with run options --guard --seed 32508

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00600s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>テストが通ったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: それ以外のタイプの場合'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ2の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ3の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">それ以外のタイプの場合</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">TODOリスト</emphasis> をすべて完了しました。追加仕様を満たすプログラムは出来ましたがまだ改善の余地がありそうですね。以降ではオブジェクト指向アプローチによるコードのリファクタリングを解説していきたいと思います。</simpara>
</section>
</section>
<section xml:id="_オブジェクト指向">
<title>オブジェクト指向</title>
<section xml:id="_手続き型プログラム">
<title>手続き型プログラム</title>
<simpara><emphasis role="strong">オブジェクト指向</emphasis> の解説の前に以下のコードを御覧ください。いわゆる <emphasis role="strong">手続き型</emphasis> で書かれたコードですが、これも追加仕様を満たしています。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">MAX_NUMBER = 100
type = 1
list = []

MAX_NUMBER.times do |i|
  r = ''
  i += 1
  case type
  when 1
    if i % 3 == 0 &amp;&amp; i % 5 == 0
      r = 'FizzBuzz'
    elsif i % 3 == 0
      r = 'Fizz'
    elsif i % 5 == 0
      r = 'Buzz'
    else
      r = i.to_s
    end
  when 2
    r = i.to_s
  when 3
    if i % 3 == 0 &amp;&amp; i % 5 == 0
      r = 'FizzBuzz'
    else
      r = i.to_s
    end
  else
    r = '該当するタイプは存在しません'
  end

  list.push(r)
end

puts list</programlisting>
<simpara>処理の流れをフローチャートにしたものです、実態はコードに記述されている内容を記号に置き換えて人間が読めるようにしたものです。</simpara>
<screen>start

repeat

  if (タイプ1) then (yes)
    if (カウンタが3と5で割り切れる) then (yes)
      :変数にFizzBuzzをセットする;
    else if (カウンタが3で割り切れる) then (yes)
      :変数にFizzをセットする;
    else if (カウンタが5で割り切れる) then (yes)
      :変数にBuzzをセットする;
    else
      :変数にカウンタをセットする;
    endif
  else if (タイプ2) then (yes)
    :変数にカウンタをセットする;
  else if (タイプ3) then (yes)
    if (カウンタが3と5で割り切れる) then (yes)
      :変数にFizzBuzzをセットする;
    else
      :変数にカウンタを文字列にしてセットする;
    endif
  else (no)
   :変数に該当するタイプは存在しませんをセットする;
  endif

  :カウンタを1増やす;
repeat while (カウンタが100になるまで)

stop</screen>
</section>
<section xml:id="_オブジェクト指向プログラム">
<title>オブジェクト指向プログラム</title>
<simpara>続いて、これまでに作ってきたコードがこちらになります。上記の <emphasis role="strong">手続き型コード</emphasis> との大きな違いとして <literal>class</literal> というキーワードでくくられている部分があります。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスとは、大まかに説明すると何らかの値と処理（メソッド）をひとかたまりにしたものです。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end

  def self.generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E">UML</link> を使って上記のコードの構造をクラス図として表現しました。</simpara>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    {static} generate(number)
    {static} generate_list()
}</screen>
<simpara>更にシーケンス図を使って上記のコードの振る舞いを表現しました。</simpara>
<screen>participant "Main" as A
participant "FizzBuzz" as B

A -&gt; B : generate_list()
activate B

loop 100 times
  B -&gt; B : generate()
end loop

A &lt;&lt;-- B : list
deactivate B</screen>
<simpara><emphasis role="strong">手続き型コード</emphasis> のフローチャートと比べてどう思われましたか？具体的な記述が少なくデータや処理の概要だけを表現しているけどFizzBuzzのルールを知っている人であれば何をやろうとしているかのイメージはつかみやすいのではないでしょうか？だから何？と思われるかもしれませんが現時点では <emphasis role="strong">オブジェクト指向</emphasis> において <emphasis role="strong">抽象化</emphasis> がキーワードだという程度の認識で十分です。</simpara>
<simpara>オブジェクト指向の理解を深める取り掛かりにはこちらの記事を参照してください。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://qiita.com/nrslib/items/73bf176147192c402049">オブジェクト指向のいろは</link></simpara>
</listitem>
</itemizedlist>
<simpara>オブジェクト指向の詳細は控えるとして、ここでは <emphasis role="strong">カプセル化</emphasis> <emphasis role="strong">ポリモフィズム</emphasis> <emphasis role="strong">継承</emphasis> というオブジェクト指向プログラムで原則とされる概念をリファクタリングを通して体験してもらい、オブジェクト指向プログラムの感覚を掴んでもらうことを目的に解説を進めていきたいと思います。</simpara>
</section>
</section>
<section xml:id="_カプセル化">
<title>カプセル化</title>
<section xml:id="_フィールドのカプセル化">
<title>フィールドのカプセル化</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    {static} generate(number)
    {static} generate_list()
}</screen>
<simpara>まず、データとロジックを１つのクラスにまとめていくためのリファクタリングを実施していくとします。<literal>FizzBuzz</literal> クラスにFizzBuzz配列を保持できるようして以下のように取得できるようにしたいと思います。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
          fizzbuzz.generate_list
          @result = fizzbuzz.list
...</programlisting>
<simpara>まず、 <emphasis role="strong">インスタンス変数</emphasis> 追加します。次に <literal>self</literal> キーワードを外して <emphasis role="strong">クラスメソッド</emphasis> から <emphasis role="strong">インスタンスメソッド</emphasis> に変更します。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスメソッドはいくつか定義方法がありますが、どの方法を使ってもクラスメソッドとして定義されれば「クラス名.メソッド名」という形で呼び出せます。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>インスタンスメソッドはコンストラクタと同じようにクラス内でdefキーワードを使ってメソッドを定義するだけで作成できます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end

  def self.generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def list
    @list
  end

  def generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...

ERROR["test_15を渡したら文字列FizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x00005613555ed120 @name="数を文字列にして返す::タイプ3の場合::三と五の倍数の場合"&gt;, 0.0041351839900016785]
 test_15を渡したら文字列FizzBuzzを返す#数を文字列にして返す::タイプ3の場合::三と五の倍数の場合 (0.00s)
Minitest::UnexpectedError:         NoMethodError: undefined method `generate' for FizzBuzz:Class
            /workspace/tdd_rb/test/fizz_buzz_test.rb:117:in `test_15を渡したら文字列FizzBuzzを返す'
...</programlisting>
<simpara>FizzBuzz配列を <emphasis role="strong">インスタンス変数</emphasis> <literal>@list</literal> に <emphasis role="strong">代入</emphasis> して <emphasis role="strong">インスタンス変数</emphasis> 経由で取得できるように変更しました。変更にあたり <emphasis role="strong">クラスメソッド</emphasis> <literal>FizzBuzz.generate</literal> と <literal>FizzBuzz.generate_list</literal> を <emphasis role="strong">インスタンスメソッド</emphasis> に変更しています。それに伴ってテストが失敗して <literal>NoMethodError: undefined method `generate'</literal> と表示されるようになってしまいました。<emphasis role="strong">インスタンスメソッド</emphasis> が使えるようにするため　<literal>new</literal> メソッドを使ってFizzBuzzクラスの <emphasis role="strong">インスタンス</emphasis> を作りFizzBuzz配列を <emphasis role="strong">インスタンス変数</emphasis> 経由で取得するようにテストコードを変更します。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスとして定義された情報を元に具体的な値を伴ったオブジェクトを作成することをインスタンス化と呼び、生成されたオブジェクトのことをインスタンスと呼びます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new
      end
...
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new
      end
...
    end

    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.new
      end
...
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:17:36 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 5 / 17 LOC (29.41%) covered.
Started with run options --guard --seed 7701

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00616s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>テストが直りました。<emphasis role="strong">クラスメソッド</emphasis> <emphasis role="strong">インスタンスメソッド</emphasis> <emphasis role="strong">インスタンス変数</emphasis> <emphasis role="strong">インスタンス</emphasis> などいろんな単語が出てきて戸惑ってしまったかもしれませんが、ピンとこないうちは <emphasis role="strong">クラス</emphasis> に値や状態を保持させるためには <emphasis role="strong">インスタンス化</emphasis> する必要があってそのためには <literal>new</literal> メソッドを使わないといけないのね程度の理解で十分です。大概のことは手を動かしているうちにピンと来るようになります。</simpara>
<simpara><emphasis role="strong">インスタンス変数</emphasis> に直接アクセスしているのでここは <emphasis role="strong">アクセッサメソッド</emphasis> を使って <emphasis role="strong">フィールドのカプセル化</emphasis> を適用しておきます。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>オブジェクト指向ではクラス内の値をカプセル化することが重要ですが、時には内部で保持しているインスタンス変数を参照や更新できる方が良い場合もあります。複雑な処理ではなく、単にインスタンス変数にアクセスするためのメソッドのことを、アクセッサメソッドと呼びます。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>フィールドのカプセル化</simpara>
<simpara>公開フィールドがある。</simpara>
<simpara>それを非公開にして、そのアクセサを用意する。</simpara>
</blockquote>
<simpara>自動実行の結果、以下のように書き換えられている部分を変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuz、
  MAX_NUMBER = 100
　attr_reader :list
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list
...</programlisting>
<simpara>テストが動作して既存のコードが壊れていないことが確認できたのでここでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: フィールドのカプセル化'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    generate(number)
    generate_list()
}</screen>
<simpara>引き続き、FizzBuzz配列は保持できるようになりましたがタイプごとに出力される配列のパターンは違います。FizzBuzzクラスにタイプを持たる必要があります。ここでは <emphasis role="strong">コンストラクタ</emphasis> を使って <emphasis role="strong">インスタンス化</emphasis> する際に <emphasis role="strong">インスタンス変数</emphasis> に <emphasis role="strong">代入</emphasis> するようにします。Rubyでは <emphasis role="strong">initialize</emphasis> というメソッドを使って初期化処理を実行します。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスをインスタンス化した時に初期化処理を行うシチュエーションはよくあります。このような初期化処理を行うメソッドをコンストラクタと呼び、Rubyではinitializeという特別なメソッドを用意することで実現できます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list

  def initialize(type)
    @type = type
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_3を渡したら文字列3を返す", #&lt;Minitest::Reporters::Suite:0x00005564e21e85b0 @name="数を文字列にして返す::タイプ3の場合::三の倍数の場合"&gt;, 0.004276092993677594]
 test_3を渡したら文字列3を返す#数を文字列にして返す::タイプ3の場合::三の倍数の場合 (0.00s)
Minitest::UnexpectedError:         ArgumentError: wrong number of arguments (given 0, expected 1)
            /workspace/tdd_rb/lib/fizz_buzz.rb:7:in `initialize'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:101:in `new'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:101:in `setup'
...</programlisting>
<simpara>テストが失敗して引数が違うというエラーが表示される用になりました。<literal>new</literal> メソッドの <emphasis role="strong">引数</emphasis> にタイプを渡すようにテストを変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(1)
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(2)
      end
...
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(3)
      end
...
    end

    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(4)
      end
...
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:28:38 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 6 / 19 LOC (31.58%) covered.
Started with run options --guard --seed 46661

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00793s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>テストは直りましたがまだ <emphasis role="strong">インスタンス変数</emphasis> のタイプが使われていないので使うようにプロダクトコードを変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list

  def initialize(type)
    @type = type
  end

  def generate(number, _type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case @type
...</programlisting>
<simpara><literal>FizzBuzz.gnerate</literal> メソッドの <emphasis role="strong">引数</emphasis> から <literal>type</literal> を削除します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list

  def initialize(type)
    @type = type
  end

  def generate(number)
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_15を渡したら文字列FizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x0000564e16c14200 @name="数を文字列にして返す::タイプ3の場合::三と五の倍数の場合"&gt;, 0.01706391001062002]
 test_15を渡したら文字列FizzBuzzを返す#数を文字列にして返す::タイプ3の場合::三と五の倍数の場合 (0.02s)
Minitest::UnexpectedError:         ArgumentError: wrong number of arguments (given 2, expected 1)
            /workspace/tdd_rb/lib/fizz_buzz.rb:11:in `generate'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:118:in `test_15を渡したら文字列FizzBuzzを返す'
...</programlisting>
<simpara>続いて、<literal>FizzBuzz#generate</literal> メソッドから不要になった <emphasis role="strong">引数</emphasis> <literal>type</literal> を削除したところテストが壊れたのでテストコードを修正します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
  ...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(2)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.generate(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1)
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(3)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1)
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(4)
      end

      def test_例外を返す
        e = assert_raises RuntimeError do
          @fizzbuzz.generate(1)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:34:57 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 15 / 19 LOC (78.95%) covered.
Started with run options --guard --seed 59116

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00700s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara><emphasis role="strong">インスタンス変数</emphasis> の <literal>@type</literal> も <emphasis role="strong">アクセッサメソッド</emphasis> を使って <emphasis role="strong">フィールドのカプセル化</emphasis> を適用しておきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list

  def initialize(type)
    @type = type
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list
  attr_accessor :type

  def initialize(type)
    @type = type
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --guard --seed 56315

  32/32: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01069s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>コミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: フィールドのカプセル化'</programlisting>
</section>
<section xml:id="_setterの削除">
<title>setterの削除</title>
<simpara>FizzBuzz配列を取得する <emphasis role="strong">アクセッサメソッド</emphasis> は現在このように定義されています。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list
  attr_accessor :type
...</programlisting>
<simpara>以下のようにテストコードを変更したらどうなるでしょうか？</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          fizzbuzz.list = []
          @result = fizzbuzz.list
        end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_配列の2番目は文字列のFizzを返す", #&lt;Minitest::Reporters::Suite:0x0000563c29a8a8c0 @name="数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.005137628992088139]
 test_配列の2番目は文字列のFizzを返す#数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
        Expected: "Fizz"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:58:in `test_配列の2番目は文字列のFizzを返す'
...</programlisting>
<simpara>FizzBuzz配列が初期化されてしまいました。<emphasis role="strong">アクセッサメソッド</emphasis> に参照のための <emphasis role="strong">getter</emphasis> と 更新するための <emphasis role="strong">setter</emphasis> が許可されているため　<emphasis role="strong">カプセル化</emphasis> が破られてしまいました。ここは <emphasis role="strong">setterの削除</emphasis> を適用して外部からの更新を出来ないようにしておきましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>getterを定義するには、「attr_reader」を使います。このメソッドにインスタンス変数の「@」を除いた名称をシンボル表現にしたものを列挙します。複数ある場合はカンマで区切って複数の値を指定することができます。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>setterを定義するには、「attr_writer」を使います。このメソッドもattr_readerと同じくインスタンス変数名の「@」を除いた名称をシンボル表現にしたものを列挙します。複数ある場合はカンマで区切って複数の値を指定することができます。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>getter/setterの両方を定義する場合、そのインスタンスは属しているクラス外から自由に参照や更新ができてしまいます。これはカプセル化の観点には反した挙動なので、できる限りattr_readerだけで済ませられないか検討しましょう。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>setterの削除</simpara>
<simpara>setterが用意されているということは、フィールドが変更される可能性があることを意味します。オブジェクトを生成した後でフィールドを変更したくないなら、setterは用意しません（加えて、フィールドを変更不可にします）。そうすることで、フィールドはコンストラクタでのみで設定され、変更させないという意図が明確になって、フィールドが変更される可能性を、たいていは排除できます。</simpara>
</blockquote>
<simpara>Rubyでは以下のようにして <emphasis role="strong">インスタンス変数</emphasis> を読み取り専用にします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_accessor :type
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">ERROR["test_配列の2番目は文字列のFizzを返す", #&lt;Minitest::Reporters::Suite:0x000055b32efd75f0 @name="数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.008614362974185497]
 test_配列の2番目は文字列のFizzを返す#数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
Minitest::UnexpectedError:         NoMethodError: undefined method `list=' for #&lt;FizzBuzz:0x000055b32ee8c678&gt;
        Did you mean?  list
            /workspace/tdd_rb/test/fizz_buzz_test.rb:45:in `setup'</programlisting>
<simpara>更新メソッドは存在しませんというエラーに変わったことが確認できたのでテストを元にもどします。</simpara>
<simpara>同様に <emphasis role="strong">インスタンス変数</emphasis> の <literal>@type</literal> も読み取り専用にします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
04:32:06 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 22 / 22 LOC (100.0%) covered.
Started with run options --guard --seed 20902

  32/32: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00920s
...</programlisting>
<simpara>テストが壊れていないことを確認したらコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: setterの削除'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}</screen>
</section>
</section>
<section xml:id="_ポリモーフィズム">
<title>ポリモーフィズム</title>
<section xml:id="_ポリモーフィズムによる条件記述の置き換え_1">
<title>ポリモーフィズムによる条件記述の置き換え 1</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}</screen>
<simpara>リファクタリングによりデータとロジックを１つのクラスにまとめて <emphasis role="strong">カプセル化</emphasis> を進めることが出来ました。しかし、以下の警告メッセージが表示されたままです。<emphasis role="strong">ポリモーフィズム</emphasis> を使ったロジックのリファクタリングを実施していきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
07:53:29 - INFO - Inspecting Ruby code style: test/fizz_buzz_test.rb lib/fizz_buzz.rb
lib/fizz_buzz.rb:11:3: C: Metrics/CyclomaticComplexity: Cyclomatic complexity for generate is too high. [10/8]
  def generate(number) ...
  ^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:11:3: C: Metrics/PerceivedComplexity: Perceived complexity for generate is too high. [8/7]
  def generate(number) ...
  ^^^^^^^^^^^^^^^^^^^^
 2/2 files |====================================== 100 =======================================&gt;| Time: 00:00:00

2 files inspected, 2 offenses detected
...</programlisting>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E7%9A%84%E8%A4%87%E9%9B%91%E5%BA%A6">循環的複雑度</link> が高く可読性が低く複雑なコードと警告されているようです。対象となっている　<literal>FizzBuzz#generate</literal> を確認してみましょう。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://rubocop.readthedocs.io/en/latest/cops_metrics/#metricscyclomaticcomplexity">Metrics/CyclomaticComplexity</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://rubocop.readthedocs.io/en/latest/cops_metrics/#metricsperceivedcomplexity">Metrics/PerceivedComplexity</link></simpara>
</listitem>
</itemizedlist>
<programlisting language="ruby" linenumbering="unnumbered">...
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case @type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end
...</programlisting>
<simpara>コードの不吉な臭いである <emphasis role="strong">スイッチ文</emphasis> に該当するコードのようなのでここはリファクタリングカタログに従って <emphasis role="strong">ポリモーフィズムによる条件記述の置き換え</emphasis> を適用していきましょう。比較的大きなリファクタリングなのでいくつかのステップに分けて進めていきます。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>スイッチ文</simpara>
<simpara>オブジェクト指向プログラミングのメリットして、スイッチ文が従来にくらべて少なくなるということがあります。スイッチ文は重複したコードを生み出す問題児です。コードのあちらこちらに同じようなスイッチ文が見られることがあります。これでは新たな分岐を追加したときに、すべてのスイッチ文を探して似たような変更をしていかなければなりません。オブジェクト指向ではポリモーフィズムを使い、この問題をエレガントに解決できます。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>重複したスイッチ文</simpara>
<simpara>最近はポリモーフィズムも一般的となり、15年前に比べるとswitch文が単純に赤信号というわけでもなくなりました。また、多くのプログラミング言語が、基本データ型以外をサポートする、より洗練されたswitch文を提供してきています。そこで、今後問題とするのは、重複したswitch文のみとします。switch/case文や、ネストしたif/else文の形で、コードのさまざまな箇所に同じ条件分岐ロジックが書かれていれば、それは「不吉な臭い」です。重複した条件分岐が問題なのは、新たな分岐を追加したら、すべての重複した条件分岐を探して更新指定かなけれけならないからです。ポリモーフィズムは、そうした単調な繰り返しに誘うダークフォースに対抗するための、洗練された武器です。コードベースをよりモダンにしていきましょう。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>ポリモーフィズムによる条件記述の置き換え</simpara>
<simpara>オブジェクトのタイプによって異なる振る舞いを選択する条件記述がある。</simpara>
<simpara>条件記述の各アクション部をサブクラスでオーバーライドするメソッドに移動する。元のメソッドはabstractにする。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
...
end

class FizzBuzzType01; end
class FizzBuzzType02; end
class FizzBuzzType03; end</programlisting>
<simpara>まず、タイプごとのクラスを定義します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end

  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end

...</programlisting>
<simpara>次に、タイプごとのクラスを <emphasis role="strong">インスタンス化</emphasis> する <emphasis role="strong">ファクトリメソッド</emphasis> をFizzBuzzクラスに追加します。この時点では新しいクラスとメソッドの追加だけなのでテストは壊れていないはずです（警告は出ていますが・・・）。ここでコミットしておきますがリファクタリング作業としては <link xl:href="https://ja.wikipedia.org/wiki/%E4%BB%95%E6%8E%9B%E5%93%81">仕掛</link> なのでWIP(Work In Progress)をメッセージに追加してコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): ポリモーフィズムによる条件記述の置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
FizzBuzz -&gt; FizzBuzzType01
FizzBuzz -&gt; FizzBuzzType02
FizzBuzz -&gt; FizzBuzzType03</screen>
</section>
<section xml:id="_ポリモーフィズムによる条件記述の置き換え_2">
<title>ポリモーフィズムによる条件記述の置き換え 2</title>
<simpara>続いて、各タイプクラスに <emphasis role="strong">インスタンスメソッド</emphasis> を実装します。ここでは <emphasis role="strong">case式</emphasis> の各処理をコピー&amp;ペーストしています。カット&amp;ペーストするとプロダクトコードが壊れたままリファクタリングを進めることになるのでここは慎重に進めていきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
...
end

class FizzBuzzType01; end
class FizzBuzzType02; end
class FizzBuzzType03; end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType01
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType02
  def generate(number)
    number.to_s
  end
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType03
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

    number.to_s
  end
end</programlisting>
<simpara>警告は出ますがテストは壊れていないのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): ポリモーフィズムによる条件記述の置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create()
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate()
}
class FizzBuzzType02 {
    generate()
}
class FizzBuzzType03 {
    generate()
}
FizzBuzz -&gt; FizzBuzzType01
FizzBuzz -&gt; FizzBuzzType02
FizzBuzz -&gt; FizzBuzzType03</screen>
</section>
<section xml:id="_ポリモーフィズムによる条件記述の置き換え_3">
<title>ポリモーフィズムによる条件記述の置き換え 3</title>
<simpara>これで準備は整いましたのでテストコードの <literal>setup</literal> メソッドを <emphasis role="strong">ファクトリメソッド</emphasis> の呼び出しに変更します。以下の部分は変更してはいけません。理由はわかりますか？</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(1)
      end
...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(2)
      end
...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(3)
      end
...
    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(4)
      end

      def test_例外を返す
        e = assert_raises RuntimeError do
          @fizzbuzz.generate(1)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:14:14 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 26 / 42 LOC (61.9%) covered.
Started with run options --guard --seed 37585

ERROR["test_例外を返す", #&lt;Minitest::Reporters::Suite:0x000056317940fa28 @name="数を文字列にして返す::それ以外のタイプの場合"&gt;, 0.0037079370085848495]
 test_例外を返す#数を文字列にして返す::それ以外のタイプの場合 (0.00s)
Minitest::UnexpectedError:         RuntimeError: 該当するタイプは存在しません
            /workspace/tdd_rb/lib/fizz_buzz.rb:20:in `create'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:132:in `setup'

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00685s
32 tests, 33 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara>失敗するテストがありますね、該当するコードを確認したところ例外が発生するタイミングが変わってしまったので以下のように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(4)
      end

      def test_例外を返す
        e = assert_raises RuntimeError do
          @fizzbuzz.generate(1)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzz.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:18:08 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 37 / 42 LOC (88.1%) covered.
Started with run options --guard --seed 40171

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00559s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>コミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): ポリモーフィズムによる条件記述の置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzz -&gt; FizzBuzzType01
FizzBuzz -&gt; FizzBuzzType02
FizzBuzz -&gt; FizzBuzzType03</screen>
</section>
<section xml:id="_ポリモーフィズムによる条件記述の置き換え_4">
<title>ポリモーフィズムによる条件記述の置き換え 4</title>
<simpara>タイプごとにFizzBuzzを生成するクラスを用意したのでFizzBuzzクラスから呼び出せるようにしましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end
...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<simpara>まず、<emphasis role="strong">コンストラクタ</emphasis> から <emphasis role="strong">クラスメソッド</emphasis> の <emphasis role="strong">ファクトリメソッド</emphasis> を呼び出して <emphasis role="strong">インスタンス変数</emphasis> の <literal>type</literal> にタイプクラスの <emphasis role="strong">参照</emphasis> を <emphasis role="strong">代入</emphasis> します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = FizzBuzz.create(type)
  end
...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">ERROR["test_配列の14番目は文字列のFizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x000055670a343110 @name="数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.006740843993611634]
 test_配列の14番目は文字列のFizzBuzzを返す#数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
Minitest::UnexpectedError:         RuntimeError: 該当するタイプは存在しません
            /workspace/tdd_rb/lib/fizz_buzz.rb:42:in `generate'
            /workspace/tdd_rb/lib/fizz_buzz.rb:48:in `block in generate_list'
            /workspace/tdd_rb/lib/fizz_buzz.rb:48:in `each'
            /workspace/tdd_rb/lib/fizz_buzz.rb:48:in `map'
            /workspace/tdd_rb/lib/fizz_buzz.rb:48:in `generate_list'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:44:in `setup'</programlisting>
<simpara>テストが失敗して沢山エラーが表示するようになりましたが落ち着いてください。次に <emphasis role="strong">インスタンスメソッド</emphasis> <literal>FizzBuzz#generate_list</literal> 内の <literal>FizzBuzz#generate</literal> メソッド呼び出しを <emphasis role="strong">インスタンス変数</emphasis> <literal>type</literal> が参照するタイプクラスのメソッド <literal>FizzBuzzTypeXX#generate</literal> を呼び出すように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = FizzBuzz.create(type)
  end
...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| @type.generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">Started with run options --seed 13878


Progress: |=====================================================================================================|

Finished in 0.00960s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
05:54:49 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
lib/fizz_buzz.rb:24:3: C: Metrics/CyclomaticComplexity: Cyclomatic complexity for generate is too high. [10/8]
  def generate(number) ...
  ^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:24:3: C: Metrics/PerceivedComplexity: Perceived complexity for generate is too high. [8/7]
  def generate(number) ...
  ^^^^^^^^^^^^^^^^^^^^
 1/1 file |======================================= 100 ========================================&gt;| Time: 00:00:00

1 file inspected, 2 offenses detected</programlisting>
<simpara>再びテストが通るようになりました。始めのうちはコードを少し変更しただけでなんで動くようになったの？と思うかもしれませんがこれが <emphasis role="strong">ポリモーフィズム</emphasis> の威力です。この概念を感覚としてつかんで使いこなせるようになることがオブジェクト指向プログラミングの第一歩です。感覚は意識して手を動かしていればそのうちつかめます（多分）。</simpara>
<simpara><emphasis role="strong">ポリモーフィズムによる条件記述の置き換え</emphasis> が完了したのでWIPを外してコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor ポリモーフィズムによる条件記述の置き換え'</programlisting>
</section>
<section xml:id="_state_strategyによるタイプコードの置き換え">
<title>State/Strategyによるタイプコードの置き換え</title>
<simpara>仕上げは　<emphasis role="strong">State/Strategyによるタイプコードの置き換え</emphasis> を適用して、警告メッセージを消すとしましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>State/Strategyによるタイプコードの置き換え</simpara>
<simpara>クラスの振る舞いに影響するタイプコードがあるが、サブクラス化はできない。</simpara>
<simpara>状態オブジェクトでタイプコードを置き換える</simpara>
</blockquote>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzz *- FizzBuzzType01
FizzBuzz *- FizzBuzzType02
FizzBuzz *- FizzBuzzType03</screen>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = FizzBuzz.create(type)
  end

  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end

  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case @type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| @type.generate(n) }
  end
end
...</programlisting>
<simpara>まず、<literal>FizzBuzz#generate</literal> のメソッド呼び出しを <emphasis role="strong">インスタンス変数</emphasis> <literal>type</literal> が参照するタイプクラスのメソッド <literal>FizzBuzzTypeXX#generate</literal> に <emphasis role="strong">委譲</emphasis> するように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| @type.generate(n) }
  end
end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 49543


Progress: |=====================================================================================================|

Finished in 0.00925s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
06:34:27 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 ========================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected
06:34:29 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detecte
...</programlisting>
<simpara>警告が消えました。しかもテストは壊れていないようです。実は <literal>FizzBuzz#generate</literal> メソッドはどこからも使われていないためテストも壊れることが無いのですがこれでは不要なメソッドになってしまうので <emphasis role="strong">移譲の隠蔽</emphasis> を実施して、ロジックを <emphasis role="strong">カプセル化</emphasis> します。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>委譲の隠蔽</simpara>
<simpara>オブジェクト指向について最初に教わる時、カプセル化とはフィールドを隠すことだと習うでしょう。しかし経験を積むにつれて、他にもカプセル化できるものがあることに気づきます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end
...</programlisting>
<simpara>テストもFizzBuzzインスタンス経由で実行するように修正しておきます。これですべての呼び出しが <literal>new</literal> メソッド経由となりテストコードに一貫性を取り戻すことが出来ました。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(1)
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(2)
      end
...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(3)
      end
...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzz.new(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:32:17 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 32 / 32 LOC (100.0%) covered.
Started with run options --guard --seed 63863

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00564s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:32:18 - INFO - Inspecting Ruby code style of all files
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
...</programlisting>
<simpara><emphasis role="strong">ポリモーフィズム</emphasis> の感覚がつかめないうちは <literal>FizzBuzz#generate</literal> のコードが一行になったのに既存のテストも壊れず動いていることが不思議に思うかもしれません。しかしコードとしてはFizzBuzzクラスの <literal>generate</literal> メソッドは任意のタイプクラスの <literal>generate</literal> メソッドを呼び出しているだけで処理の詳細は理解しなくても振る舞いを理解できる <emphasis role="strong">抽象化</emphasis> された読みやすいコードになりました。静的コード解析も可読性が高くシンプルなコードとみなしてくれているようです。
さて、警告メッセージもなくなり、テストも壊れていないのでコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: State/Strategyによるタイプコードの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzz *- FizzBuzzType01
FizzBuzz *- FizzBuzzType02
FizzBuzz *- FizzBuzzType03</screen>
</section>
</section>
<section xml:id="_継承">
<title>継承</title>
<simpara>分割したタイプクラスのメソッドに重複する処理があるので <emphasis role="strong">継承</emphasis> を使ってリファクタリングしましょう。ここでは <emphasis role="strong">スーパークラスの抽出</emphasis> を適用します。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>スーパークラスの抽出</simpara>
<simpara>似通った特性を持つ２つのクラスがある。</simpara>
<simpara>スーパークラスを作成して、共通の特性を移動する。</simpara>
</blockquote>
<section xml:id="_スーパークラスの抽出">
<title>スーパークラスの抽出</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzz *- FizzBuzzType01
FizzBuzz *- FizzBuzzType02
FizzBuzz *- FizzBuzzType03</screen>
<simpara>まずは、タイプクラスのスーパークラスとなる <literal>FizzBuzzType</literal> クラスを作成して各タイプクラスに継承させます。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスベースのオブジェクト指向言語の多くはクラスの継承機能を有しています。クラスの継承とはあるクラスを元として、新しいクラスを定義することです。この時、継承元となるクラスを親クラスやスーパークラスと呼び、継承したクラスのことを子クラスやサブクラスと呼びます。</simpara>
</blockquote>
<simpara>Rubyの <emphasis role="strong">クラスの継承</emphasis> は以下のように書きます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
...
end

class FizzBuzzType; end

class FizzBuzzType01
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType; end

class FizzBuzzType01 &lt; FizzBuzzType
...
end

class FizzBuzzType02 &lt; FizzBuzzType
...
end

class FizzBuzzType03 &lt; FizzBuzzType
...
end</programlisting>
<simpara>スーパークラス <literal>FizzBuzzType</literal> を定義して各サブクラスに継承させます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">08:42:24 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 33 / 33 LOC (100.0%) covered.
Started with run options --guard --seed 43548

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00860s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:42:25 - INFO - Inspecting Ruby code style of all files
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType {
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
<simpara>次に <literal>is_fizz</literal> <literal>is_buzz</literal> 部分を共通メソッドとしてスーパークラスに定義して各タイプクラスで呼び出すように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType; end

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

    number.to_s
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  def is_fizz(number)
    number.modulo(3).zero?
  end

  def is_buzz(number)
    number.modulo(5).zero?
  end
end

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if is_fizz(number) &amp;&amp; is_buzz(number)
    return 'Fizz' if is_fizz(number)
    return 'Buzz' if is_buzz(number)

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if is_fizz(number) &amp;&amp; is_buzz(number)

    number.to_s
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">08:50:16 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 33 / 33 LOC (100.0%) covered.
Started with run options --guard --seed 45685

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01073s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:50:17 - INFO - Inspecting Ruby code style of all files
lib/fizz_buzz.rb:35:7: C: Naming/PredicateName: Rename is_fizz to fizz?.
  def is_fizz(number)
      ^^^^^^^
lib/fizz_buzz.rb:39:7: C: Naming/PredicateName: Rename is_buzz to buzz?.
  def is_buzz(number)
      ^^^^^^^
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, 2 offenses detected</programlisting>
<simpara>テストが壊れていないことが確認できたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: スーパークラスの抽出'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType {
  is_fizz(number)
  is_buzz(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
</section>
<section xml:id="_メソッド名の変更">
<title>メソッド名の変更</title>
<simpara><emphasis role="strong">スーパークラスの抽出</emphasis> を実施したところまた警告メッセージが表示されるようになりました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">08:50:19 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png lib/fizz_buzz.rb
lib/fizz_buzz.rb:35:7: C: Naming/PredicateName: Rename is_fizz to fizz?.
  def is_fizz(number)
      ^^^^^^^
lib/fizz_buzz.rb:39:7: C: Naming/PredicateName: Rename is_buzz to buzz?.
  def is_buzz(number)
      ^^^^^^^
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, 2 offenses detected</programlisting>
<simpara><link xl:href="https://rubocop.readthedocs.io/en/latest/cops_naming/#namingpredicatename">Naming/PredicateName</link> Rubyのネーミングとしてはよろしくないようなので指示に従って <emphasis role="strong">メソッド名の変更</emphasis> を実施しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  def is_fizz(number)
    number.modulo(3).zero?
  end

  def is_buzz(number)
    number.modulo(5).zero?
  end
end

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if is_fizz(number) &amp;&amp; is_buzz(number)
    return 'Fizz' if is_fizz(number)
    return 'Buzz' if is_buzz(number)

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if is_fizz(number) &amp;&amp; is_buzz(number)

    number.to_s
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if fizz?(number) &amp;&amp; buzz?(number)
    return 'Fizz' if fizz?(number)
    return 'Buzz' if buzz?(number)

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if fizz?(number) &amp;&amp; buzz?(number)

    number.to_s
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">Progress: |====================================================================================================|

Finished in 0.01144s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
08:53:35 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected</programlisting>
<simpara>作業としては難しくないのでミスタイプしないように（まあ、ミスタイプしてもテストが教えてくれますが・・・）変更してコミットしましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッド名の変更'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType {
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
</section>
<section xml:id="_メソッドの移動">
<title>メソッドの移動</title>
<simpara><literal>FizzBuzz</literal> クラスの <emphasis role="strong">ファクトリメソッド</emphasis> ですが <emphasis role="strong">特性の横恋慕</emphasis> の臭いがするので <emphasis role="strong">メソッドの移動</emphasis> を実施します。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>特性の横恋慕</simpara>
<simpara>オブジェクト指向には、処理および処理に必要なデータを１つにまとめてしまうという重要な考え方があります。あるメソッドが、自分のクラスより他のクラスに興味を持つような場合には、古典的な誤りを犯しています。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>メソッドの移動</simpara>
<simpara>あるクラスでメソッドが定義されているが、現在または将来において、そのクラスの特性よりも他のクラスの特性の方が、そのメソッドを使ったり、そのメソッドから使われたりすることが多い。</simpara>
<simpara>同様の本体を持つ新たなメソッドを、それを最も多用するクラスに作成する。元のメソッドは、単純な委譲とするか、またはまるごと取り除く。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list

  def initialize(type)
    @type = FizzBuzz.create(type)
  end

  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end

  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end

class FizzBuzzType
  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end
...</programlisting>
<simpara><emphasis role="strong">クラスメソッド</emphasis> <literal>FizzBuzz.create</literal> をカット&amp;ペーストして <literal>FizzBuzzType.create</literal> に移動します。
<literal>FizzBuzz</literal> の <emphasis role="strong">コンストラクタ</emphasis> で呼び出している <emphasis role="strong">クラスメソッド</emphasis> を <literal>FizzBuzzType.create</literal> に変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list

  def initialize(type)
    @type = FizzBuzzType.create(type)
  end

  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end

class FizzBuzzType
  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end

  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">08:59:27 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 33 / 33 LOC (100.0%) covered.
Started with run options --guard --seed 19583

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00688s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:59:28 - INFO - Inspecting Ruby code style of all files
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected</programlisting>
<simpara>テストが壊れていないことを確認したらコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッドの移動'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
</section>
</section>
<section xml:id="_値オブジェクト">
<title>値オブジェクト</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
<section xml:id="_オブジェクトによるプリミティブの置き換え">
<title>オブジェクトによるプリミティブの置き換え</title>
<simpara><literal>FizzBuzz</literal> クラスを <emphasis role="strong">インスタンス化</emphasis> するには以下のように書きます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">fizz_buzz = FizzBuzz.new(1)</programlisting>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスとして定義された情報を元に具体的な値を伴ったオブジェクトを作成することをインスタンス化と呼び、生成されたオブジェクトのことをインスタンスと呼びます。</simpara>
</blockquote>
<simpara><emphasis role="strong">コンストラクタ</emphasis> の <emphasis role="strong">引数</emphasis> に渡される <literal>1</literal> は何を表しているのでしょうか？もちろんタイプですが初めてこのコードを見る人にはわからないでしょう。このような整数、浮動小数点、文字列などの基本データ（プリミティブ）型の使い方からは <emphasis role="strong">基本データ型への執着</emphasis> の臭いがします。 <emphasis role="strong">オブジェクトによるプリミティブの置き換え</emphasis> を実施してコードの意図を明確にしましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>基本データ型への執着</simpara>
<simpara>オブジェクト指向のメリットとして、基本データ型とそれより大きなクラスとの境界を取り除くということがあります。プログラミング言語の組み込み（built-in）型と区別できないような小さなクラスを自分で定義することが容易です。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>基本データ型への執着</simpara>
<simpara>興味深いことに、多くのプログラマは、対象としているドメインに役立つ、貨幣、座標、範囲などの基本的な型を導入するのを嫌がる傾向があります。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>オブジェクトによるデータ値の置き換え</simpara>
<simpara>追加のデータや振る舞いが必要なデータ項目がある。</simpara>
<simpara>そのデータ項目をオブジェクトに変える。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>オブジェクトによるプリミティブの置き換え</simpara>
<simpara>旧：オブジェクトによるデータ値の置き換え</simpara>
<simpara>旧：クラスによるタイプコードの置き換え</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = FizzBuzzType.create(type)
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end
...</programlisting>
<simpara><emphasis role="strong">コンストラクタ</emphasis> で引き渡されるタイプは整数ではなくタイプクラスの <emphasis role="strong">インスタンス</emphasis> に変更します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...

ERROR["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00005654f32602c0 @name="数を文字列にして返す::タイプ3の場合::その他の場合"&gt;, 0.00241121300496161]
 test_1を渡したら文字列1を返す#数を文字列にして返す::タイプ3の場合::その他の場合 (0.00s)
Minitest::UnexpectedError:         NoMethodError: undefined method `generate' for 3:Integer
            /workspace/tdd_rb/lib/fizz_buzz.rb:12:in `generate'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:125:in `test_1を渡したら文字列1を返す'
...</programlisting>
<simpara>テストが失敗しました。 <emphasis role="strong">コンストラクタ</emphasis> の引数を整数からタイプクラスの <emphasis role="strong">インスタンス</emphasis> に変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(1)
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(2)
      end
...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(3)
      end
...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzz.new(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end</programlisting>
<simpara>ここで注意するのは <literal>それ以外のタイプの場合</literal> ですが例外を投げなくなります。静的に型付けされた言語なら型チェックエラーになるのですがRubyは動的に型付けされる言語のため <literal>FizzBuzz#generate</literal> メソッド実行までエラーになりません。そこで例外を投げる <literal>FizzBuzzType#create</literal> メソッドに変更しておきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType02.new)
      end
...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType03.new)
      end
...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzzType.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end</programlisting>
<simpara>それ以外のタイプの場合は <emphasis role="strong">ファクトリメソッド</emphasis> 経由でないと <emphasis role="strong">例外</emphasis> を出さなくなるので注意してください。</simpara>
<programlisting language="bash" linenumbering="unnumbered">09:09:40 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 30 / 33 LOC (90.91%) covered.
Started with run options --guard --seed 17452

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00687s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>初めてコードを見る人でもテストコードを見ればコードの意図が読み取れるようになりましたのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: オブジェクトによるプリミティブの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType</screen>
</section>
<section xml:id="_マジックナンバーの置き換え">
<title>マジックナンバーの置き換え</title>
<simpara>まだプリミティグ型を使っている部分があります。ここは <emphasis role="strong">マジックナンバーの置き換え</emphasis> を実施して可読性を上げておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
 end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">09:18:51 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 33 / 36 LOC (91.67%) covered.
Started with run options --guard --seed 41124

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00909s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストは壊れていないのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: マジックナンバーの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType</screen>
</section>
<section xml:id="_オブジェクトによるプリミティブの置き換え_2">
<title>オブジェクトによるプリミティブの置き換え</title>
<simpara>次に <emphasis role="strong">基本データ型への執着</emphasis> の臭いがする箇所として <literal>FizzBuzz#generate</literal> メソッドが返すFizzBuzzの値が文字型である点です。文字列の代わりに <emphasis role="strong">値オブジェクト</emphasis> <literal>FizzBuzzValue</literal> クラスを定義します。</simpara>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>値の種類ごとに専用の型を用意するとコードが安定し、コードの意図が明確になります。このように、値を扱うための専用クラスを作るやり方を値オブジェクト（ValueObject）と呼びます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    @number = number
    @value = value
  end

  def to_s
    "#{@number}:#{@value}"
  end

  def ==(other)
    @number == other.number &amp;&amp; @value == other.value
  end

  alias eql? ==
end</programlisting>
<simpara>各タイプクラスの <literal>generate</literal> メソッドが文字列のプリミティブ型を返しているので <emphasis role="strong">値オブジェクト</emphasis> <literal>FizzBuzzValue</literal> を返すように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if fizz?(number) &amp;&amp; buzz?(number)
    return 'Fizz' if fizz?(number)
    return 'Buzz' if buzz?(number)

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if fizz?(number) &amp;&amp; buzz?(number)

    number.to_s
  end
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)
    return FizzBuzzValue.new(number, 'Fizz') if fizz?(number)
    return FizzBuzzValue.new(number, 'Buzz') if buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, number.to_s)
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_配列の2番目は文字列のFizzを返す", #&lt;Minitest::Reporters::Suite:0x000055feccc65ab8 @name="数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.012104410998290405]
 test_配列の2番目は文字列のFizzを返す#数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
        --- expected
        +++ actual
        @@ -1 +1 @@
        -"Fizz"
        +#&lt;FizzBuzzValue:0xXXXXXX @number=3, @value="Fizz"&gt;
        /workspace/tdd_rb/test/fizz_buzz_test.rb:57:in `test_配列の2番目は文字列のFizzを返す'
...</programlisting>
<simpara>変更によりテストが失敗しました。エラー内容を見てみると文字列からオブジェクトを返しているためアサーションが失敗しているようです。ここは、<emphasis role="strong">値オブジェクト</emphasis> の <emphasis role="strong">アクセッサメソッド</emphasis> を経由して取得した値をアサーション対象に変更しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.generate(3).value
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.generate(5).value
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15).value
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1).value
        end
      end

      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first.value
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last.value
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2].value
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4].value
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14].value
        end
      end
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType02.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3).value
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5).value
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.generate(15).value
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1).value
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType03.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3).value
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5).value
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15).value
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1).value
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzzType.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">08:49:28 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 41 / 46 LOC (89.13%) covered.
Started with run options --guard --seed 25972

  32/32: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00619s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:49:29 - INFO - Inspecting Ruby code style of all files
 7/7 files |======================================= 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
08:49:30 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detected</programlisting>
<simpara>テストコードをそれほど変更することなく <emphasis role="strong">値オブジェクト</emphasis> を返すリファクタリングが出来ました。コミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: オブジェクトによるプリミティブの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue</screen>
</section>
<section xml:id="_学習用テスト_2">
<title>学習用テスト</title>
<simpara><emphasis role="strong">値オブジェクト</emphasis> の理解を深めるために <emphasis role="strong">学習用テスト</emphasis> を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValue' do
    def setup
      @fizzbuzz = FizzBuzz.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    end

    def test_同じで値である
      value1 = @fizzbuzz.generate(1)
      value2 = @fizzbuzz.generate(1)

      assert value1.eql?(value2)
    end

    def test_to_stringメソッド
      value = @fizzbuzz.generate(3)

      assert_equal '3:Fizz', value.to_s
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: 学習用テスト'</programlisting>
</section>
</section>
<section xml:id="_ファーストクラスコレクション">
<title>ファーストクラスコレクション</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue</screen>
<section xml:id="_コレクションのカプセル化">
<title>コレクションのカプセル化</title>
<simpara><emphasis role="strong">値オブジェクト</emphasis> を扱うFizzBuzzリストですが <emphasis role="strong">コレクションのカプセル化</emphasis> を適用して <emphasis role="strong">ファーストクラスコレクション</emphasis> オブジェクトを追加しましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>コレクションのカプセル化</simpara>
<simpara>メソッドがコレクションを返している。</simpara>
<simpara>読み取り専用のビューを返して、追加と削除のメソッドを提供する。</simpara>
</blockquote>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>このように、コレクション型のデータとロジックを特別扱いにして、コレクションを１つだけ持つ専用クラスを作るやり方をコレクションオブジェクトあるいはファーストクラスコレクションと呼びます。</simpara>
</blockquote>
<simpara>まず、 <emphasis role="strong">ファーストクラスコレクション</emphasis> クラスを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzList
  attr_reader :value

  def initialize(list)
    @value = list
  end

  def to_s
    @value.to_s
  end

  def add(value)
    FizzBuzzList.new(@value + value)
  end
end</programlisting>
<simpara>FizzBuzz配列を <emphasis role="strong">ファーストクラスコレクション</emphasis> から取得するように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end
...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
    @list = FizzBuzzList.new([])
  end

...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = @list.add((1..MAX_NUMBER).map { |n| @type.generate(n) })
  end
end</programlisting>
<simpara>なんだか紛らわしい書き方になってしましました。配列を作るのに以前の配列を元に新しい配列を作るとか回りくどいことをしないで既存の配列を使い回せばいいじゃんと思うかもしれませんが <emphasis role="strong">変更可能なデータ</emphasis> はバグの原因となる傾向があります。変更可能な <emphasis role="strong">ミュータブル</emphasis> な変数ではなく 永続的に変更されない <emphasis role="strong">イミュータブル</emphasis> な変数を使うように心がけましょう。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>変更可能なデータ</simpara>
<simpara>データの変更はしばし予期せぬ結果結果や、厄介なバグを引き起こします。他で違う値を期待していることに気づかないままに、ソフトウェアのある箇所で値を変更してしまえば、それだけで動かなくなってしまいます。これは値が変わる条件がまれにしかない場合、特に見つけにくいバグとなります。そのため、ソフトウェア開発の一つの潮流である関数型プログラミングは、データは不変であるべきで、更新時は常に元にデータ構造のコピーを返すようにし、元データには手を触れないという思想に基づいています。</simpara>
</blockquote>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>値オブジェクトと同じようにコレクションオブジェクトも、できるだけ「不変」スタイルで設計します。そのほうがプログラムが安定します。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_配列の14番目は文字列のFizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x00005561331b7940 @name="FizzBuzz::数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.011710233025951311]
 test_配列の14番目は文字列のFizzBuzzを返す#FizzBuzz::数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
Minitest::UnexpectedError:         NoMethodError: undefined method `[]' for #&lt;FizzBuzzList:0x0000556133198ba8 @value=[]&gt;
            /workspace/tdd_rb/test/fizz_buzz_test.rb:66:in `test_配列の14番目は文字列のFizzBuzzを返す'
...</programlisting>
<simpara><emphasis role="strong">ファーストクラスコレクション</emphasis> 経由で取得するようになったので <emphasis role="strong">アクセッサメソッド</emphasis> を変更する必要があります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
    @list = FizzBuzzList.new([])
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :type

  def list
    @list.value
  end

  def initialize(type)
    @type = type
    @list = FizzBuzzList.new([])
  end
....</programlisting>
<programlisting language="bash" linenumbering="unnumbered">09:12:46 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 53 / 56 LOC (94.64%) covered.
Started with run options --guard --seed 61051

  34/34: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01285s
34 tests, 37 assertions, 0 failures, 0 errors, 0 skips

09:12:47 - INFO - Inspecting Ruby code style of all files
 7/7 files |======================================= 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
09:12:48 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detected</programlisting>
<simpara>テストが直ったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: コレクションのカプセル化'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue
FizzBuzzList *-- FizzBuzzValue
FizzBuzz -&gt; FizzBuzzList</screen>
</section>
<section xml:id="_学習用テスト_3">
<title>学習用テスト</title>
<simpara><emphasis role="strong">ファーストクラスコレクション</emphasis> を理解するため <emphasis role="strong">学習用テスト</emphasis> を追加しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def setup
      @fizzbuzz = FizzBuzz.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    end

    def test_新しいインスタンスが作られる
      list1 = @fizzbuzz.generate_list
      list2 = list1.add(list1.value)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: 学習用テスト'</programlisting>
</section>
</section>
<section xml:id="_オブジェクト指向設計">
<title>オブジェクト指向設計</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue
FizzBuzzList *-- FizzBuzzValue
FizzBuzz -&gt; FizzBuzzList</screen>
<simpara><emphasis role="strong">値オブジェクト</emphasis> 及び <emphasis role="strong">ファーストクラスコレクション</emphasis> の適用で <emphasis role="strong">基本データ型への執着</emphasis> の臭いはなくなりました。今度は設計の観点から全体を眺めてみましょう。ここで気になるのが <literal>FizzBuzz</literal> クラスです。このクラスは他のクラスと比べてやることが多いようです。このようなクラスは <emphasis role="strong">単一責任の原則</emphasis> に違反している可能性があります。そこで <emphasis role="strong">デザインパターン</emphasis> の１つである <emphasis role="strong">Commandパターン</emphasis> を使ったリファクタリングである <emphasis role="strong">メソッドオブジェクトによるメソッドの置き換え</emphasis> 適用してみようと思います。</simpara>
<blockquote>
<attribution>
Clean Architecture 達人に学ぶソフトウェアの構造と設計
</attribution>
<simpara>SRP: 単一責任の原則</simpara>
<simpara>かつて単一責任の原則(SRP)は、以下のように語られてきた。</simpara>
<literallayout class="monospaced">モジュールを変更する理由はたったひとつだけであるべきである</literallayout>
<simpara>ソフトウェアシステムに手を加えるのは、ユーザーやステークホルダーを満足させるためだ。この「ユーザーやステークホルダー」こそが、単一責任の原則（SRP）を指す「変更する理由」である。つまり、この原則は以下のように言い換えられる。</simpara>
<literallayout class="monospaced">モジュールはたったひとりのユーザーやステークホルダーに対して責任を負うべきである。</literallayout>
<simpara>残念ながら「たったひとりのユーザーやステークホルダー」という表現は適切ではない。複数のユーザーやステークホルダーがシステムを同じように変更したいと考えることもある。ここでは、変更を望む人たちをひとまとめにしたグループとして扱いたい。このグループのことをアクターと呼ぶことにしよう。
これを踏まえると、最終的な単一責任の原則（SRP）は以下のようになる。</simpara>
<literallayout class="monospaced">モジュールはたったひとつのアクターに対して責任を負うべきである。</literallayout>
<simpara>さて、ここでいう「モジュール」とは何のことだろう？端的に言えば、モジュールとはソースファイルのことである。たいていの場合は、この定義で問題ないだろう。だが、ソースファイル以外のところにコードを格納する言語や開発環境も存在する。そのような場合の「モジュール」は、いくつかの関数やデータをまとめた凝集性のあるものだと考えよう。</simpara>
<simpara>「凝集性のある」という言葉が単一責任の原則（SRP）を匂わせる。凝集性が、ひとつのアクターに対する責務を負うコードをまとめるフォースとなる。</simpara>
</blockquote>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>Commandパターン</simpara>
<simpara>処理の呼び出しが、シンプルなメソッド呼び出しよりも複雑になってきたときはどうすればよいだろうか---処理のためのオブジェクトを作成し、それを起動するようにしよう。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>メソッドオブジェクトによるメソッドの置き換え</simpara>
<simpara>長いメソッドで、「メソッドの抽出」を適用できないようなローカル変数の使い方をしている。</simpara>
<simpara>メソッド自身をオブジェクトとし、すべてのローカル変数をそのオブジェクトのフィールドとする。そうすれば、そのメソッドを同じオブジェクト中のメソッド群に分解できる。</simpara>
</blockquote>
<section xml:id="_メソッドオブジェクトによるメソッドの置き換え">
<title>メソッドオブジェクトによるメソッドの置き換え</title>
<simpara>まず、<emphasis role="strong">値オブジェクト</emphasis> の <literal>FizzBuzzValue</literal> を返す責務だけを持った <emphasis role="strong">メソッドオブジェクト</emphasis> を抽出します。Rubyのような動的言語では必要が無いのですが <emphasis role="strong">Commandパターン</emphasis> の説明のため <emphasis role="strong">インターフェイス</emphasis> にあたるスーパークラスを継承した <emphasis role="strong">メソッドオブジェクト</emphasis> を定義します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzCommand
  def execute; end
end

class FizzBuzzValueCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    @type.generate(number).value
  end
end</programlisting>
<simpara>テストコードを <literal>FizzBuzzValueCommand</literal> を呼び出すように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType01.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end

      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first.value
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last.value
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2].value
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4].value
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14].value
        end
      end
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType02.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType03.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzzType.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
09:56:19 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 60 / 63 LOC (95.24%) covered.
Started with run options --guard --seed 27353

  35/35: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00692s
35 tests, 39 assertions, 0 failures, 0 errors, 0 skips

09:56:20 - INFO - Inspecting Ruby code style of all files
 7/7 files |======================================= 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
09:56:21 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00
 ...</programlisting>
<simpara><literal>FizzBuzzValueCommand</literal> の抽出ができたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッドオブジェクトによるメソッドの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue
FizzBuzzList *-- FizzBuzzValue
FizzBuzz -&gt; FizzBuzzList
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzValueCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_メソッドオブジェクトによるメソッドの置き換え_2">
<title>メソッドオブジェクトによるメソッドの置き換え</title>
<simpara>続いて、<emphasis role="strong">ファーストクラスコレクション</emphasis> を扱う <literal>FizzBuzzList</literal> を返す責務だけを持った <emphasis role="strong">メソッドオブジェクト</emphasis> を抽出します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzListCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    FizzBuzzList.new((1..number).map { |i| @type.generate(i) }).value
  end
end</programlisting>
<simpara>テストコードを <emphasis role="strong">FizzBuzzListCommand</emphasis> 経由から実行するように変更します</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
        describe '1から100までのFizzBuzzの配列を返す' do
          def setup
            fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
            fizzbuzz.generate_list
            @result = fizzbuzz.list
          end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzzListCommand.new(FizzBuzzType01.new)
          @result = fizzbuzz.execute(100)
        end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">01:27:54 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 61 / 66 LOC (92.42%) covered.
Started with run options --guard --seed 62253

  35/35: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00652s
35 tests, 39 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが通ったのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッドオブジェクトによるメソッドの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue
FizzBuzzList *-- FizzBuzzValue
FizzBuzz -&gt; FizzBuzzList
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzCommand *- FizzBuzzType
FizzBuzzListCommand -&gt; FizzBuzzList</screen>
</section>
<section xml:id="_デッドコードの削除">
<title>デッドコードの削除</title>
<simpara><literal>FizzBuzz</literal> クラスの責務は各 <emphasis role="strong">メソッドオブジェクト</emphasis> が実行するようになったので削除しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def initialize(type)
    @type = type
    @list = FizzBuzzList.new([])
  end

  def list
    @list.value
  end

  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = @list.add((1..MAX_NUMBER).map { |n| @type.generate(n) })
  end
end

class FizzBuzzType
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzType
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_同じで値である", #&lt;Minitest::Reporters::Suite:0x0000562fd34f7848 @name="FizzBuzzValue"&gt;, 0.008059715997660533]
 test_同じで値である#FizzBuzzValue (0.01s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
            /workspace/tdd_rb/test/fizz_buzz_test.rb:225:in `setup'

ERROR["test_to_stringメソッド", #&lt;Minitest::Reporters::Suite:0x0000562fd37694a0 @name="FizzBuzzValue"&gt;, 0.01728590900893323]
 test_to_stringメソッド#FizzBuzzValue (0.02s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
            /workspace/tdd_rb/test/fizz_buzz_test.rb:225:in `setup'

ERROR["test_新しいインスタンスが作られる", #&lt;Minitest::Reporters::Suite:0x0000562fd39be070 @name="FizzBuzzValueList"&gt;, 0.028008958004647866]
 test_新しいインスタンスが作られる#FizzBuzzValueList (0.03s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
            /workspace/tdd_rb/test/fizz_buzz_test.rb:244:in `setup'

========================================|

Finished in 0.03539s
35 tests, 35 assertions, 0 failures, 3 errors, 0 skips
...</programlisting>
<simpara>テストが失敗しました。これは <emphasis role="strong">学習用テスト</emphasis> で <literal>FizzBuzz</literal> クラスを使っている箇所があるからですね。 <emphasis role="strong">メソッドオブジェクト</emphasis> 呼び出しに変更しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">  describe 'FizzBuzzValue' do
    def setup
      @fizzbuzz = FizzBuzz.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    end

    def test_同じで値である
      value1 = @fizzbuzz.generate(1)
      value2 = @fizzbuzz.generate(1)

      assert value1.eql?(value2)
    end

    def test_to_stringメソッド
      value = @fizzbuzz.generate(3)

      assert_equal '3:Fizz', value.to_s
    end
  end

  describe 'FizzBuzzValueList' do
    def setup
      @fizzbuzz = FizzBuzz.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    end

    def test_新しいインスタンスが作られる
      list1 = @fizzbuzz.generate_list
      list2 = list1.add(list1.value)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValue' do
    def test_同じで値である
      value1 = FizzBuzzValue.new(1, '1')
      value2 = FizzBuzzValue.new(1, '1')

      assert value1.eql?(value2)
    end

    def test_to_stringメソッド
      value = FizzBuzzValue.new(3, 'Fizz')

      assert_equal '3:Fizz', value.to_s
    end
  end

  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(100)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
01:35:22 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 50 / 56 LOC (89.29%) covered.
Started with run options --guard --seed 10411

  35/35: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00704s
35 tests, 39 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>不要なコードを残しておくとメンテナンスの時に削除していいのかわからなくなり可読性を落とし原因となります。削除できる時に削除しておきましょう。後で必要になったとしてもバージョン管理システムを使えば問題ありません。ということでコミットします。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>デッドコードの削除</simpara>
<simpara>コードが使用されなくなったら削除すべきです。そのコードが将来必要になるかもしれないなどという心配はしません。必要になったらいつでも、バージョン管理システムから再び掘り起こせるからです。</simpara>
<simpara>（中略）</simpara>
<simpara>デッドコードのコメントアウトは、かつては一般的な習慣でした。それは、バージョン管理システムが広く使用される以前の時代や、使いづらかった時代には有用でした。現在では、とても小さなコードベースでもバージョン管理システムに置けるため、もはや必要のない習慣です。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: デッドコードの削除'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_デザインパターン">
<title>デザインパターン</title>
<simpara><emphasis role="strong">メソッドオブジェクトによるメソッドの置き換え</emphasis> リファクタリングの結果として <emphasis role="strong">Commandパターン</emphasis> という <emphasis role="strong">デザインパターン</emphasis> を適用しました。実はこれまでにも <emphasis role="strong">オブジェクトによるプリミティブの置き換え</emphasis> では <emphasis role="strong">Value Objectパターン</emphasis> を <emphasis role="strong">ポリモーフィズムによる条件記述の置き換え</emphasis> では <emphasis role="strong">Factory Methodパターン</emphasis> をそして、 <emphasis role="strong">委譲の隠蔽</emphasis> の実施による <emphasis role="strong">State/Strategyによるタイプコードの置き換え</emphasis> では <emphasis role="strong">Strategyパターン</emphasis> を適用しています。</simpara>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/Command_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Command パターン</link></simpara>
<screen>interface Command {
  execute()
}
class Invoker {
}
class ConcreateCommand {
  execute()
}
class Receiver {
  Action()
}
class Client {
}
Invoker o-&gt; Command
Command &lt;|-- ConcreateCommand
Receiver &lt;- ConcreateCommand
Client -&gt; Receiver
Client -&gt; ConcreateCommand</screen>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>Value Objectパターン</simpara>
<simpara>広く共有されるものの、同一インスタンスであることはさほど重要でないオブジェクトを設計するにはどうしたらよいだろうか----オブジェクト作成時に状態を設定したら、その後決して変えないようにする。オブジェクトへの操作は必ず新しいオブジェクトを返すようにしよう。</simpara>
</blockquote>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>Factory Methodパターン</simpara>
<simpara>オブジェクト作成に柔軟性をもたせたいときは、どうすればよいだろうか---単にコンストラクタで作るのではなく、メソッドを使ってオブジェクトを作成しよう。</simpara>
</blockquote>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/Strategy_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Strategy パターン</link></simpara>
<screen>class Context {
  ContextInterface()
}
interface Strategy {
  AlgorithmInterface()
}
class ConcreateStrategyA {
  AlgorithmInterface()
}
class ConcreateStrategyB {
  AlgorithmInterface()
}
Context o- Strategy
Strategy &lt;|-- ConcreateStrategyA
Strategy &lt;|-- ConcreateStrategyB</screen>
<simpara>作成したコードはパターンと完全に一致しているわけではありませんし、Rubyのような動的言語ではもっと簡単な実現方法もありますがここでは先人の考えた設計パターンというものがありオブジェクト指向設計の <link xl:href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%87%E3%82%A3%E3%82%AA%E3%83%A0">イデオム</link> として使えること。そしてテスト駆動開発では一般的な設計アプローチとは異なる形で導かれているということくらいを頭に残しておけば結構です。どのパターンをいつ適用するかはリファクタリングを繰り返しているうちに思いつくようになってきます（多分）。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>ただ、書籍『デザインパターン』（通称Gof本）の大ヒットは、その反面、それらパターンを表現する方法の多様性を奪ってしまった。Gof本には、設計をフェーズとして扱うという暗黙の前提があるように見受けられる。つまり、リファクタリングを設計行為として捉えていない。TDDにおける設計は、デザインパターンを少しだけ違う側面から捉えなければならない。</simpara>
</blockquote>
<simpara>あと、設計の観点から今回 <emphasis role="strong">単一責任の原則</emphasis> に従って <literal>FizzBuzz</literal> クラスを <emphasis role="strong">メソッドオブジェクト</emphasis> に分割して削除しました。</simpara>
<screen>Interface FizzBuzzCommand {
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>もし、新しい処理を追加する必要が発生した場合はどうしましょうか？ <literal>FizzBuzzCommand</literal> インターフェイスを実装した <emphasis role="strong">メソッドオブジェクト</emphasis> を追加しましょう。</simpara>
<screen>Interface FizzBuzzCommand {
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzCommand &lt;|-- FizzBuzzSomethingSpecialCommand
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>もし、新しいタイプが必要になったらどうしましょうか？ <literal>FizzBuzzType</literal> クラスを継承した新しいタイプクラスを追加しましょう。</simpara>
<screen>Interface FizzBuzzCommand {
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeXX
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>このように既存のコードを変更することなく振る舞いを変更できるので <emphasis role="strong">オープン・クローズドの原則</emphasis> を満たした設計といえます。</simpara>
<blockquote>
<attribution>
Clean Architecture 達人に学ぶソフトウェアの構造と設計
</attribution>
<simpara>OCP:オープン・クローズドの原則</simpara>
<simpara>「オープン・クローズドの原則（OCP）」は、1988年にBertrand Maeerが提唱した以下のような原則だ。</simpara>
<literallayout class="monospaced">ソフトウェアの構成要素は拡張に対しては開いていて、修正に対しては閉じていなければならない。
　　　　　　　　　　　　『アジャイルソフトウェア開発の奥義　第2版』（SBクリエイティブ）より引用</literallayout>
<simpara>言い換えれば、ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべきである、ということだ。</simpara>
</blockquote>
</section>
</section>
<section xml:id="_例外">
<title>例外</title>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>ここまでは、正常系をリファクタリングして設計を改善してきました。しかし、アプリケーションは例外系も考慮する必要があります。
続いて、<emphasis role="strong">アサーションの導入</emphasis> を適用した例外系のリファクタリングに取り組むとしましょう。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>アサーションの導入</simpara>
<simpara>前提を明示するためのすぐれたテクニックとして、アサーションを記述する方法があります。</simpara>
</blockquote>
<section xml:id="_アサーションの導入">
<title>アサーションの導入</title>
<simpara>まず、 <emphasis role="strong">メソッドオブジェクト</emphasis> の <literal>FizzBuzzValueCommand</literal> にマイナスの値が渡された場合の振る舞いをどうするか考えます。ここでは正の値のみ許可する振る舞いにしたいので以下のテストコードを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
...
  describe '例外ケース' do
    def test_値は正の値のみ許可する
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_値は正の値のみ許可する", #&lt;Minitest::Reporters::Suite:0x00007fadf30c45d8 @name="例外ケース"&gt;, 0.006546000000525964]
 test_値は正の値のみ許可する#例外ケース (0.01s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::Assertions
            /Users/k2works/Projects/sandbox/tdd_rb/test/fizz_buzz_test.rb:249:in `test_値は正の値のみ許可する'

  36/36: [=========================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.03159s
36 tests, 39 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara>テストを通すためアサーションモジュールを追加します。Rubyでは <emphasis role="strong">モジュール</emphasis> を使います。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>モジュールはクラスと非常によく似ていますが、以下の二点が異なります。</simpara>
<itemizedlist>
<listitem>
<simpara>モジュールはインスタンス化できない</simpara>
</listitem>
<listitem>
<simpara>本章後半可能なのは include や extend が可能なのはモジュールだけ</simpara>
</listitem>
</itemizedlist>
<simpara>それ以外のクラスメソッドや定数の定義などはクラスと同じように定義することができます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
module Assertions
  class AssertionFailedError &lt; StandardError; end

  def assert(&amp;condition)
    raise AssertionFailedError, 'Assertion Failed' unless condition.call
  end
end

class FizzBuzzValue
...</programlisting>
<simpara>アサーションモジュールを追加してエラーはなくなりましたがテストは失敗したままです。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_値は正の値のみ許可する", #&lt;Minitest::Reporters::Suite:0x00007fdcfc0c2548 @name="例外ケース"&gt;, 0.005800000000817818]
 test_値は正の値のみ許可する#例外ケース (0.01s)
        Assertions::AssertionFailedError expected but nothing was raised.
        /Users/k2works/Projects/sandbox/tdd_rb/test/fizz_buzz_test.rb:249:in `test_値は正の値のみ許可する'

============================================================================================================|

Finished in 0.00621s
36 tests, 40 assertions, 1 failures, 0 errors, 0 skips
...</programlisting>
<simpara>追加したモジュールを <literal>FizzBuzzValue</literal> クラスをに <emphasis role="strong">Mix-in</emphasis> します。そして、<emphasis role="strong">コンストラクタ</emphasis> 実行時に数値は0以上であるアサーションを追加します。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>Rubyでの継承は一種類、単一継承しか実行できませんが、複数のクラスを継承する多重継承の代わりにMix-inというメソッドの共有方法を提供します。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    @number = number
    @value = value
  end
...
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzValue
  include Assertions
  attr_reader :number, :value

  def initialize(number, value)
    assert { number &gt;= 0 }
    @number = number
    @value = value
  end
...
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 37354


Progress: |====================================================================================================|

Finished in 0.01433s
36 tests, 40 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>アサーションが機能するようになりました、コミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: アサーションの導入'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
class Assertions {
  assert(&amp;condition)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType
FizzBuzzValue --|&gt; Assertions</screen>
<simpara>次は、<emphasis role="strong">メソッドオブジェクト</emphasis> の <literal>FizzBuzzListCommand</literal> の実行時に100件以上指定された場合の振る舞いをどうするか考えます。ここでは100までを許可する振る舞いにします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe '例外ケース' do
    def test_値は正の値のみ許可する
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end
    end

    def test_100より多い数を許可しない
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end
    end
  end
end</programlisting>
<simpara><literal>FizzBuzzList</literal> にアサーションモジュールを <emphasis role="strong">Mix-in</emphasis> します。<emphasis role="strong">コンストラクタ</emphasis> 実行時に配列のサイズは100までというアサーションを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzList
  include Assertions
  attr_reader :value

  def initialize(list)
    assert { list.count &lt;= 100 }
    @value = list
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_新しいインスタンスが作られる", #&lt;Minitest::Reporters::Suite:0x00005558ca6e8e80 @name="FizzBuzzValueList"&gt;, 0.010412617004476488]
 test_新しいインスタンスが作られる#FizzBuzzValueList (0.01s)
Minitest::UnexpectedError:         Assertions::AssertionFailedError: Assertion Failed
            /workspace/tdd_rb/lib/fizz_buzz.rb:58:in `assert'
            /workspace/tdd_rb/lib/fizz_buzz.rb:88:in `initialize'
            /workspace/tdd_rb/lib/fizz_buzz.rb:97:in `new'
            /workspace/tdd_rb/lib/fizz_buzz.rb:97:in `add'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:259:in `test_新しいインスタンスが作られる'

====================================================================================================|

Finished in 0.01238s
36 tests, 38 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara>追加したテストはパスするようになりましたが既存のテストコードでエラーが出るようになりました。該当するテストコードを見たところ100件より多い <emphasis role="strong">学習用テスト</emphasis> で <emphasis role="strong">ファーストクラスコレクション</emphasis> を作ろうとしたため <literal>AssertionFailedError</literal> を発生させたようです。テストコードを修正しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(100)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
...</programlisting>
<simpara>最初は50件作るように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(50)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
...</programlisting>
<simpara>アサーションエラーはなくなりましたが期待した値と違うと指摘されています。テストコードのアサーションを修正します。</simpara>
<programlisting language="bash" linenumbering="unnumbered"> FAIL["test_新しいインスタンスが作られる", #&lt;Minitest::Reporters::Suite:0x0000556b5137c780 @name="FizzBuzzValueList"&gt;, 0.003735148988198489]
 test_新しいインスタンスが作られる#FizzBuzzValueList (0.00s)
        Expected: 100
          Actual: 50
        /workspace/tdd_rb/test/fizz_buzz_test.rb:261:in `test_新しいインスタンスが作られる'

  36/36: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00837s
36 tests, 39 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(50)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 50, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
...</programlisting>
<simpara>２つ目のアサーションに引っかかってしまいました。こちらも修正します。</simpara>
<programlisting language="bash" linenumbering="unnumbered"> FAIL["test_新しいインスタンスが作られる", #&lt;Minitest::Reporters::Suite:0x0000563a0c4fc2b0 @name="FizzBuzzValueList"&gt;, 0.005684088013367727]
 test_新しいインスタンスが作られる#FizzBuzzValueList (0.01s)
        Expected: 200
          Actual: 100
        /workspace/tdd_rb/test/fizz_buzz_test.rb:262:in `test_新しいインスタンスが作られる'

  36/36: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00809s
36 tests, 40 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(50)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 50, list1.value.count
      assert_equal 100, list2.value.count
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
01:58:57 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 61 / 64 LOC (95.31%) covered.
Started with run options --guard --seed 44956

  36/36: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00717s
36 tests, 40 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>仕様変更による反映が出来たのでコミットしましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: アサーションの導入'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
class Assertions {
  assert(&amp;condition)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType
FizzBuzzValue --|&gt; Assertions
FizzBuzzList --|&gt; Assertions</screen>
<simpara><emphasis role="strong">アサーションの導入</emphasis> とは別のアプローチとして <emphasis role="strong">例外</emphasis> を返す方法もあります。 <emphasis role="strong">例外によるエラーコードの置き換え</emphasis> を適用してアサーションモジュールを削除しましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>例外によるエラーコードの置き換え</simpara>
<simpara>エラーを示す特別なコードをメソッドがリターンしている。</simpara>
<simpara>代わりに例外を発生させる。</simpara>
</blockquote>
</section>
<section xml:id="_例外によるエラーコードの置き換え">
<title>例外によるエラーコードの置き換え</title>
<simpara>アサーションモジュールを削除してアサーション部分を <emphasis role="strong">例外</emphasis> に変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
module Assertions
  class AssertionFailedError &lt; StandardError; end

  def assert(&amp;condition)
    raise AssertionFailedError, 'Assertion Failed' unless condition.call
  end
end

class FizzBuzzValue
  include Assertions
  attr_reader :number, :value

  def initialize(number, value)
    assert { number &gt;= 0 }
    @number = number
    @value = value
  end
...
end

class FizzBuzzList
  include Assertions
  attr_reader :value

  def initialize(list)
    assert { list.count &lt;= 100 }
    @value = list
  end
...
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number &lt; 0

    @number = number
    @value = value
  end
...
end

class FizzBuzzList
  attr_reader :value

  def initialize(list)
    raise '上限は100件までです' if list.count &gt; 100

    @value = list
  end
...
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_値は正の値のみ許可する", #&lt;Minitest::Reporters::Suite:0x000055d30f0b8a50 @name="FizzBuzz::数を文字列にして返す::例外ケース"&gt;, 0.004186890990240499]
 test_値は正の値のみ許可する#FizzBuzz::数を文字列にして返す::例外ケース (0.00s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::Assertions
            /workspace/tdd_rb/test/fizz_buzz_test.rb:143:in `test_値は正の値のみ許可する'

ERROR["test_100より多い数を許可しない", #&lt;Minitest::Reporters::Suite:0x000055d30f114210 @name="FizzBuzz::数を文字列にして返す::例外ケース"&gt;, 0.008254560001660138]
 test_100より多い数を許可しない#FizzBuzz::数を文字列にして返す::例外ケース (0.01s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::Assertions
            /workspace/tdd_rb/test/fizz_buzz_test.rb:151:in `test_100より多い数を許可しない'

  37/37: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01731s
37 tests, 39 assertions, 0 failures, 2 errors, 0 skips
...</programlisting>
<simpara>アサーションモジュールを削除したのでエラーが発生しています。テストコードを修正しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe '例外ケース' do
    def test_値は正の値のみ許可する
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end
    end

    def test_100より多い数を許可しない
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end
    end
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe '例外ケース' do
    def test_値は正の値のみ許可する
      e = assert_raises RuntimeError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end

      assert_equal '正の値のみ有効です', e.message
    end

    def test_100より多い数を許可しない
      e = assert_raises RuntimeError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end

      assert_equal '上限は100件までです', e.message
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
02:13:46 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 55 / 58 LOC (94.83%) covered.
Started with run options --guard --seed 55179

  37/37: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00738s
37 tests, 43 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>再びテストが通るようになったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor:  例外によるエラーコードの置き換え'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_アルゴリズムの置き換え_2">
<title>アルゴリズムの置き換え</title>
<programlisting language="bash" linenumbering="unnumbered">02:13:46 - INFO - Inspecting Ruby code style: test/fizz_buzz_test.rb lib/fizz_buzz.rb
lib/fizz_buzz.rb:58:26: C: Style/NumericPredicate: Use number.negative? instead of number &lt; 0.
    raise '正の値のみ有効です' if number &lt; 0
                         ^^^^^^^^^^
 2/2 files |====================================== 100 =======================================&gt;| Time: 00:00:00

2 files inspected, 1 offense detected</programlisting>
<simpara>テストは通りますが警告が表示されるようになりました。 <literal>Style/NumericPredicate: Use number.negative? instead of number &lt; 0.</literal> とのことなので <emphasis role="strong">アルゴリズムの置き換え</emphasis> を適用しておきましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>アルゴリズムの取り替え</simpara>
<simpara>アルゴリズムをよりわかりやすいものに置き換えたい</simpara>
<simpara>メソッドの本体を新たなアルゴリズムで置き換える。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number &lt; 0
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...

class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number.negative?
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">02:18:31 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected</programlisting>
<simpara>警告が消えたのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: アルゴリズムの置き換え'</programlisting>
</section>
<section xml:id="_マジックナンバーの置き換え_2">
<title>マジックナンバーの置き換え</title>
<simpara>件数に <emphasis role="strong">リテラル</emphasis> を使っています。ここは <emphasis role="strong">マジックナンバーの置き換え</emphasis> を適用するべきですね。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>シンボリック定数によるマジックナンバーの置き換え</simpara>
<simpara>特別な意味を持った数字のリテラルがある。</simpara>
<simpara>定数を作り、それにふさわしい名前をつけて、そのリテラルを置き換える。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzList
  attr_reader :value

  def initialize(list)
    raise '上限は100件までです' if list.count &gt; 100

    @value = list
  end
...</programlisting>
<simpara><emphasis role="strong">式展開</emphasis> を使ってメッセージ内容も定数から参照するようにしましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>式展開</simpara>
<simpara>式展開とは、「#{}」の書式で文字列中に何らかの変数や式を埋め込むことが可能な機能です。これは、ダブルクオートを使用した場合のみの機能です。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzList
  MAX_COUNT = 100
  attr_reader :value

  def initialize(list)
    raise "上限は#{MAX_COUNT}件までです" if list.count &gt; MAX_COUNT

    @value = list
  end
...</programlisting>
<simpara>テストは壊れていないようですが <literal>MAX_COUNT</literal> を変更したらテストが失敗するか確認しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzList
  MAX_COUNT = 10
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_配列の14番目は文字列のFizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x000055942ab5e230 @name="FizzBuzz::数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.008073228993453085]
 test_配列の14番目は文字列のFizzBuzzを返す#FizzBuzz::数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
Minitest::UnexpectedError:         RuntimeError: 上限は10件までです
            /workspace/tdd_rb/lib/fizz_buzz.rb:80:in `initialize'
            /workspace/tdd_rb/lib/fizz_buzz.rb:112:in `new'
            /workspace/tdd_rb/lib/fizz_buzz.rb:112:in `execute'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:45:in `setup'
...</programlisting>
<simpara>想定通りのエラーが発生したのでコードを元に戻してコミットしましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzList
  MAX_COUNT = 100
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 5525


Progress: |====================================================================================================|

Finished in 0.01262s
37 tests, 43 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: マジックナンバーの置き換え'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   MAX_COUNT = 100
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_特殊ケースの導入">
<title>特殊ケースの導入</title>
<simpara>最後に <emphasis role="strong">ポリモーフィズム</emphasis> の応用としてタイプクラスが未定義の場合に <emphasis role="strong">例外</emphasis> ではなく未定義のタイプクラスを返す <emphasis role="strong">特殊ケースの導入</emphasis> を適用してみましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>ヌルオブジェクトの導入</simpara>
<simpara>null値のチェックが繰り返し現れる。</simpara>
<simpara>そのnull値をヌルオブジェクトで置き換える。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>特殊ケースの導入</simpara>
<simpara>旧：ヌルオブジェクトの導入</simpara>
<simpara>特殊ケースの処理を要する典型的な値がnullなので、このパターンをヌルオブジェクトパターンと呼ぶことがあります、しかし、通常の特殊ケースとアプローチは同じです。いわばヌルオブジェクトは「特殊ケース」の特殊ケースです。</simpara>
</blockquote>
<simpara>まず、それ以外のタイプの場合の振る舞いを変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzzType.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
   describe 'それ以外のタイプの場合' do
      def test_未定義のタイプを返す
        fizzbuzz = FizzBuzzType.create(4)

        assert_equal '未定義', fizzbuzz.to_s
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_未定義のタイプを返す", #&lt;Minitest::Reporters::Suite:0x00005593e21297d0 @name="数を文字列にして返す::それ以外のタイプの場合"&gt;, 0.0065623498521745205]
 test_未定義のタイプを返す#数を文字列にして返す::それ以外のタイプの場合 (0.01s)
Minitest::UnexpectedError:         RuntimeError: 該当するタイプは存在しません
            /workspace/tdd_rb/lib/fizz_buzz.rb:17:in `create'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:131:in `test_未定義のタイプを返す'

  37/37: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00780s
37 tests, 41 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara>現時点では <emphasis role="strong">例外</emphasis> を投げるので未定義タイプ <literal>FizzBuzzTypeNotDefined</literal> を作成して <emphasis role="strong">ファクトリメソッド</emphasis> を変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end

  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end

class FizzBuzzType01 &lt; FizzBuzzType
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      FizzBuzzTypeNotDefined.new
    end
  end
...
class FizzBuzzTypeNotDefined &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, '')
  end

  def to_s
    '未定義'
  end
end

class FizzBuzzValue
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 33939


Progress: |=====================================================================================================|

Finished in 0.01193s
37 tests, 42 assertions, 0 failures, 0 errors, 0 skips
06:46:48 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 ========================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected
06:46:49 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
...</programlisting>
<simpara>テストが通るようになりました。 <emphasis role="strong">メソッドオブジェクト</emphasis> から実行された場合の振る舞いも明記しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'それ以外のタイプの場合' do
      def test_未定義のタイプを返す
        fizzbuzz = FizzBuzzType.create(4)

        assert_equal '未定義', fizzbuzz.to_s
      end

      def test_空の文字列を返す
        type = FizzBuzzType.create(4)
        command = FizzBuzzValueCommand.new(type)

        assert_equal '', command.execute(3)
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
06:48:54 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 62 / 65 LOC (95.38%) covered.
Started with run options --guard --seed 18202

  38/38: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00747s
38 tests, 43 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara><literal>FizzBuzzTypeNotDefined</literal> オブジェクトは <emphasis role="strong">Null Objectパターン</emphasis> を適用したものです。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>Null Objectパターン</simpara>
<simpara>特殊な状況をオブジェクトで表現するにはどうすればよいだろうか---その特殊な状況を表現するオブジェクトを作り、通常のオブジェクトと同じプロトコル（メソッド群）を実装しよう。</simpara>
</blockquote>
<simpara><emphasis role="strong">オープン・クローズドの原則</emphasis> に従って未定義のタイプである <emphasis role="strong">Null Object</emphasis> を安全に追加することができたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: 特殊ケースの導入'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzTypeNotDefined {
   generate(number)
   to_s()
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   MAX_COUNT = 100
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
</section>
<section xml:id="_モジュール分割">
<title>モジュール分割</title>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzTypeNotDefined {
   generate(number)
   to_s()
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   MAX_COUNT = 100
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>クラスモジュールの抽出によってアプリケーションの構造が <emphasis role="strong">抽象化</emphasis> された結果、視覚的に把握できるようになりました。ここでアプリケーションをを実行してみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Traceback (most recent call last):
main.rb:5:in `&lt;main&gt;': uninitialized constant FizzBuzz (NameError)
Did you mean?  FizzBuzzType</programlisting>
<simpara>エラーが出ています、これはアプリケーションの構成が変わったためです。クライアントプログラムをアプリケーションの変更に合わせて修正します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './lib/fizz_buzz.rb'

puts FizzBuzz.generate_list</programlisting>
<programlisting language="bash" linenumbering="unnumbered"># frozen_string_literal: true

require './lib/fizz_buzz.rb'

command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
command.execute(100).each { |i| puts i.value }</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
1
2
Fizz
4
Buzz
...
Fizz</programlisting>
<simpara>クライアントプログラムが直ったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'fix: プリントする'</programlisting>
<section xml:id="_ドメインモデル">
<title>ドメインモデル</title>
<simpara><literal>fizz_buzz.rb</literal> ファイル内のクラスモジュールをファイルとして分割していきます。まずは <emphasis role="strong">ドメインオブジェクト</emphasis> を抽出して <emphasis role="strong">ドメインモデル</emphasis> として整理しましょう。既存のテストを壊さないように１つづつコピー&amp;ペーストしていきます。</simpara>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>関連する業務データと業務ロジックを１つにまとめたこのようなオブジェクトをドメインオブジェクトと呼びます。</simpara>
<simpara>「ドメイン」とは、対象領域とか問題領域という意味です。業務アプリケーションの場合、そのアプリケーションが対象となる業務活動全体がドメインです。業務活動という問題領域（ドメイン）で扱うデータと業務ロジックを、オブジェクトとして表現したものドメインオブジェクトです。ドメインオブジェクトは、業務データと業務ロジックを密接に関係づけます。</simpara>
</blockquote>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>このように業務アプリケーションの対象領域（ドメイン）をオブジェクトのモデルとして整理したものをドメインモデルと呼びます。</simpara>
</blockquote>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
      domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
               -- fizz_buzz_type_not_defined.rb
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<simpara><emphasis role="strong">値オブジェクトクラス</emphasis> と <emphasis role="strong">タイプクラス</emphasis> を <literal>domain</literal> フォルダ以下に配置します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number.negative?

    @number = number
    @value = value
  end

  def to_s
    "#{@number}:#{@value}"
  end

  def ==(other)
    @number == other.number &amp;&amp; @value == other.value
  end

  alias eql? ==
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzList
  MAX_COUNT = 100
  attr_reader :value

  def initialize(list)
    raise "上限は#{MAX_COUNT}件までです" if list.count &gt; MAX_COUNT

    @value = list
  end

  def to_s
    @value.to_s
  end

  def add(value)
    FizzBuzzList.new(@value + value)
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      FizzBuzzTypeNotDefined.new
    end
  end

  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)
    return FizzBuzzValue.new(number, 'Fizz') if fizz?(number)
    return FizzBuzzValue.new(number, 'Buzz') if buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzTypeNotDefined &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, '')
  end

  def to_s
    '未定義'
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:29:03 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png lib/domain/type/fizz_buzz_type_not_defined.rb lib/domain/type/fizz_buzz_type_03.rb lib/domain/type/fizz_buzz_type_02.rb lib/domain/type/fizz_buzz_type_01.rb lib/domain/type/fizz_buzz_type.rb lib/domain/model/fizz_buzz_list.rb lib/domain/model/fizz_buzz_value.rb
lib/domain/type/fizz_buzz_type_not_defined.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzTypeNotDefined &lt; FizzBuzzType
^^^^^
lib/domain/type/fizz_buzz_type_03.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzType03 &lt; FizzBuzzType
^^^^^
lib/domain/type/fizz_buzz_type_02.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzType02 &lt; FizzBuzzType
^^^^^
lib/domain/type/fizz_buzz_type_01.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzType01 &lt; FizzBuzzType
^^^^^
lib/domain/type/fizz_buzz_type.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzType
^^^^^
lib/domain/model/fizz_buzz_list.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzList
^^^^^
lib/domain/model/fizz_buzz_value.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzValue
^^^^^
 7/7 files |======================== 100 =========================&gt;| Time: 00:00:00

7 files inspected, 7 offenses detected
...</programlisting>
<simpara>テストは壊れていないようですが警告が出るようになりました。まだ仕掛ですが一旦コミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): モジュール分割'</programlisting>
<screen>package "Domain" {
  package "Model" {
    class FizzBuzzValue {
    }
    class FizzBuzzList {
    }
  }
  package "Type" {
    class FizzBuzzType {
    }
    class FizzBuzzType01 {
    }
    class FizzBuzzType02 {
    }
    class FizzBuzzType03 {
    }
    class FizzBuzzTypeNotDefined {
    }
  }
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue</screen>
</section>
<section xml:id="_アプリケーション">
<title>アプリケーション</title>
<simpara>続いて <emphasis role="strong">アプリケーション層</emphasis> の分割を行います。</simpara>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>データクラスと機能クラスを分ける手続き型の設計では、アプリケーション層のクラスに業務ロジックの詳細を記述します。</simpara>
</blockquote>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
      domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<simpara>ここでは <emphasis role="strong">ドメインオブジェクト</emphasis> を操作する <emphasis role="strong">メソッドオブジェクト</emphasis> を <literal>application</literal> フォルダ以下に配置します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzCommand
  def execute; end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzValueCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    @type.generate(number).value
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzListCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    FizzBuzzList.new((1..number).map { |i| @type.generate(i) }).value
  end
end</programlisting>
<simpara>テストは壊れていないのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): モジュール分割'</programlisting>
<screen>package "Application" {
  class FizzBuzzCommand {
  }
  class FizzBuzzValueCommand {
  }
  class FizzBuzzListCommand {
  }
}
package "Domain" {
  package "Model" {
    class FizzBuzzValue {
    }
    class FizzBuzzList {
    }
  }
  package "Type" {
    class FizzBuzzType {
    }
    class FizzBuzzType01 {
    }
    class FizzBuzzType02 {
    }
    class FizzBuzzType03 {
    }
    class FizzBuzzTypeNotDefined {
    }
  }
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_テスト">
<title>テスト</title>
<simpara>アプリケーションのメイン部分は分割できました。続いてテストも分割しましょう。</simpara>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
      application/
           |
           -- fizz_buzz_value_command_test.rb
           -- fizz_buzz_list_command_test.rb
      domain/
           |
           model/
                 |
                 -- fizz_buzz_value_test.rb
                 -- fizz_buzz_list_test.rb
      |
       -- learning_test.rb</literallayout>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzValueCommandTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType01.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType02.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType03.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def test_未定義のタイプを返す
        fizzbuzz = FizzBuzzType.create(4)

        assert_equal '未定義', fizzbuzz.to_s
      end

      def test_空の文字列を返す
        type = FizzBuzzType.create(4)
        command = FizzBuzzValueCommand.new(type)

        assert_equal '', command.execute(3)
      end
    end
  end

  describe '例外ケース' do
    def test_値は正の値のみ許可する
      e = assert_raises RuntimeError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end

      assert_equal '正の値のみ有効です', e.message
    end
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzListCommandTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzzListCommand.new(FizzBuzzType01.new)
          @result = fizzbuzz.execute(100)
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first.value
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last.value
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2].value
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4].value
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14].value
        end
      end
    end
  end

  describe '例外ケース' do
    def test_100より多い数を許可しない
      e = assert_raises RuntimeError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end

      assert_equal '上限は100件までです', e.message
    end
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzValueTest &lt; Minitest::Test
  def test_同じで値である
    value1 = FizzBuzzValue.new(1, '1')
    value2 = FizzBuzzValue.new(1, '1')

    assert value1.eql?(value2)
  end

  def test_to_stringメソッド
    value = FizzBuzzValue.new(3, 'Fizz')

    assert_equal '3:Fizz', value.to_s
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzListTest &lt; Minitest::Test
  def test_新しいインスタンスが作られる
    command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    array = command.execute(50)
    list1 = FizzBuzzList.new(array)
    list2 = list1.add(array)

    assert_equal 50, list1.value.count
    assert_equal 100, list2.value.count
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class LearningTest &lt; Minitest::Test
  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_selectメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_find_allメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&amp;:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_mapメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_collectメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_findメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&amp;:size)
      assert_equal 'apple', result
    end

    def test_detectメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&amp;:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      result1 = %w[2 4 13 3 1 10].sort
      result2 = %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
      result3 = %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }

      assert_equal %w[1 10 13 2 3 4], result1
      assert_equal %w[1 2 3 4 10 13], result2
      assert_equal %w[13 10 4 3 2 1], result3
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item &lt; 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item &lt; 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_injectメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_reduceメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
end</programlisting>
<simpara>ファイル分割でテストは壊れていないようですが警告がたくさん出てきました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
test/learning_test.rb:70:14: C: Naming/AsciiIdentifiers: Use only ascii symbols in identifiers.
    def test_ブロック内の条件式が真である間までの要素を返す
             ^^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:75:9: C: Naming/MethodName: Use snake_case for method names.
    def test_ブロック内の条件式が真である以降の要素を返す
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:75:14: C: Naming/AsciiIdentifiers: Use only ascii symbols in identifiers.
    def test_ブロック内の条件式が真である以降の要素を返す
             ^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:80:9: C: Naming/MethodName: Use snake_case for method names.
    def test_injectメソッドで畳み込み演算を行う
        ^^^^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:80:20: C: Naming/AsciiIdentifiers: Use only ascii symbols in identifiers.
    def test_injectメソッドで畳み込み演算を行う
                   ^^^^^^^^^^^^^^
test/learning_test.rb:85:9: C: Naming/MethodName: Use snake_case for method names.
    def test_reduceメソッドで畳み込み演算を行う
        ^^^^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:85:20: C: Naming/AsciiIdentifiers: Use only ascii symbols in identifiers.
    def test_reduceメソッドで畳み込み演算を行う
                   ^^^^^^^^^^^^^^
 15/15 files |======================= 100 ========================&gt;| Time: 00:00:00

15 files inspected, 87 offenses detected
...</programlisting>
<simpara>これらはテストコードに関する警告がほとんどなので <literal>.rubocop.yml</literal> を編集してチェック対象から外しておきましょう。</simpara>
<programlisting language="yml" linenumbering="unnumbered">inherit_from: .rubocop_todo.yml

Naming/AsciiIdentifiers:
  Exclude:
    - 'test/**/*'

Naming/MethodName:
  EnforcedStyle: snake_case
  Exclude:
    - 'test/**/*'

Metrics/BlockLength:
  Max: 62
  Exclude:
    - 'test/**/*'

Documentation:
  Enabled: false</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:21:55 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 144 / 215 LOC (66.98%) covered.
Started with run options --guard --seed 55977

  70/70: [=====================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01518s
70 tests, 79 assertions, 0 failures, 0 errors, 0 skips

08:21:56 - INFO - Inspecting Ruby code style of all files
/workspace/tdd_rb/.rubocop.yml: Warning: no department given for Documentation.
 22/22 files |======================= 100 ========================&gt;| Time: 00:00:00

22 files inspected, no offenses detected
08:21:58 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png
/workspace/tdd_rb/.rubocop.yml: Warning: no department given for Documentation.
 0/0 files |======================== 100 =========================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
...</programlisting>
<simpara>警告は消えました、仕上げに <literal>fizz_buzz_test.rb</literal> ファイルを削除します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
08:24:12 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 135 / 201 LOC (67.16%) covered.
Started with run options --guard --seed 40104

  32/32: [=====================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00601s
32 tests, 36 assertions, 0 failures, 0 errors, 0 skips

08:24:13 - INFO - Inspecting Ruby code style of all files
/workspace/tdd_rb/.rubocop.yml: Warning: no department given for Documentation.
 21/21 files |======================= 100 ========================&gt;| Time: 00:00:00

21 files inspected, no offenses detected
08:24:14 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png
/workspace/tdd_rb/.rubocop.yml: Warning: no department given for Documentation.
 0/0 files |======================== 100 =========================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
...</programlisting>
<simpara>テストの分割も完了したのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): モジュール分割'</programlisting>
</section>
<section xml:id="_エントリーポイント">
<title>エントリーポイント</title>
<simpara>仕上げはクラスモジュールのエントリーポイント作成とテストヘルパーの追加です。</simpara>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
      application/
           |
           -- fizz_buzz_value_command_test.rb
           -- fizz_buzz_list_command._test.rb
      domain/
           |
           model/
                 |
                 -- fizz_buzz_value_test.rb
                 -- fizz_buzz_list_test.rb
      |
       -- learning_test.rb</literallayout>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
      application/
           |
           -- fizz_buzz_value_command_test.rb
           -- fizz_buzz_list_command._test.rb
      domain/
           |
           model/
                 |
                 -- fizz_buzz_value_test.rb
                 -- fizz_buzz_list_test.rb
      |
       -- learning_test.rb
       -- test_helper.rb</literallayout>
<simpara><literal>fizz_buzz.rb</literal> ファイルの内容をクラスモジュール読み込みに変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require './lib/application/fizz_buzz_command.rb'
require './lib/application/fizz_buzz_value_command.rb'
require './lib/application/fizz_buzz_list_command.rb'
require './lib/domain/model/fizz_buzz_value.rb'
require './lib/domain/model/fizz_buzz_list.rb'
require './lib/domain/type/fizz_buzz_type.rb'
require './lib/domain/type/fizz_buzz_type_01.rb'
require './lib/domain/type/fizz_buzz_type_02.rb'
require './lib/domain/type/fizz_buzz_type_03.rb'
require './lib/domain/type/fizz_buzz_type_not_defined.rb'</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:34:32 - INFO - Running: all tests
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 119 / 211 LOC (56.4%) covered.
Started with run options --guard --seed 18696

  32/32: [=====================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00561s
32 tests, 36 assertions, 0 failures, 0 errors, 0 skips
....</programlisting>
<simpara>コードカバレッジがうまく機能していないようなので、<literal>test_helper.rb</literal> を追加して共通部分を各テストファイルから読み込むように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

...</programlisting>
<simpara>テストタスクを実行したところ動作しなくなりました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake test</programlisting>
<simpara>テスト対象をテストディレクトリ内のすべてのテストコードに変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
Rake::TestTask.new do |test|
  test.test_files = Dir['./test/fizz_buzz_test.rb']
  test.verbose = true
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
Rake::TestTask.new do |test|
  test.test_files = Dir['./test/**/*_test.rb']
  test.verbose = true
end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ rake test
Started with run options --seed 46929

  32/32: [=====================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00800s
32 tests, 36 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストも壊れていないし警告も出ていません。モジュール分割完了です。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: モジュール分割'</programlisting>
<screen>package "lib" {
  package "Application" {
    class FizzBuzzCommand {
    }
    class FizzBuzzValueCommand {
    }
    class FizzBuzzListCommand {
    }
  }
  package "Domain" {
    package "Model" {
      class FizzBuzzValue {
      }
      class FizzBuzzList {
      }
    }
    package "Type" {
      class FizzBuzzType {
      }
      class FizzBuzzType01 {
      }
      class FizzBuzzType02 {
      }
      class FizzBuzzType03 {
      }
      class FizzBuzzTypeNotDefined {
      }
    }
  }
}
package "test" {
  class FizzBuzzValueCommandTest {
  }
  class FizzBuzzListCommandTest {
  }
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
</section>
<section xml:id="_ふりかえり_2">
<title>ふりかえり</title>
<simpara>今回、 <emphasis role="strong">オブジェクト指向プログラム</emphasis> から <emphasis role="strong">オブジェクト指向設計</emphasis> そして <emphasis role="strong">モジュール分割</emphasis> を <emphasis role="strong">テスト駆動開発</emphasis> を通じて実践しました。各トピックを振り返ってみましょう。</simpara>
<section xml:id="_オブジェクト指向プログラム_2">
<title>オブジェクト指向プログラム</title>
<simpara>エピソード1で作成したプログラムの追加仕様を <emphasis role="strong">テスト駆動開発</emphasis> で実装しました。 次に <emphasis role="strong">手続き型コード</emphasis> との比較から <emphasis role="strong">オブジェクト指向プログラム</emphasis> を構成する <emphasis role="strong">カプセル化</emphasis> <emphasis role="strong">ポリモフィズム</emphasis> <emphasis role="strong">継承</emphasis> という概念をコードベースの <emphasis role="strong">リファクタリング</emphasis> を通じて解説しました。</simpara>
<simpara>具体的には <emphasis role="strong">フィールドのカプセル</emphasis> から <emphasis role="strong">setterの削除</emphasis> を適用することにより <emphasis role="strong">カプセル化</emphasis> を実現しました。続いて、 <emphasis role="strong">ポリモーフィズムによる条件記述の置き換え</emphasis> から <emphasis role="strong">State/Strategyによるタイプコードの置き換え</emphasis> を適用することにより <emphasis role="strong">ポリモーフィズム</emphasis> の効果を体験しました。そして、 <emphasis role="strong">スーパークラスの抽出</emphasis> から <emphasis role="strong">メソッド名の変更</emphasis> <emphasis role="strong">メソッドの移動</emphasis> の適用を通して <emphasis role="strong">継承</emphasis> の使い方を体験しました。さらに <emphasis role="strong">値オブジェクト</emphasis> と <emphasis role="strong">ファーストクラス</emphasis> というオブジェクト指向プログラミングに必要なツールの使い方も学習しました。</simpara>
</section>
<section xml:id="_オブジェクト指向設計_2">
<title>オブジェクト指向設計</title>
<simpara>次に設計の観点から <emphasis role="strong">単一責任の原則</emphasis> に違反している <literal>FizzBuzz</literal> クラスを <emphasis role="strong">デザインパターン</emphasis> の1つである <emphasis role="strong">Commandパターン</emphasis> を使ったリファクタリングである <emphasis role="strong">メソッドオブジェクトによるメソッドの置き換え</emphasis> を適用してクラスの責務を分割しました。オブジェクト指向設計のイデオムである <emphasis role="strong">デザインパターン</emphasis> として <emphasis role="strong">Commandパターン</emphasis> 以外に <emphasis role="strong">Value Objectパターン</emphasis> <emphasis role="strong">Factory Methodパターン</emphasis> <emphasis role="strong">Strategyパターン</emphasis> を <emphasis role="strong">リファクタリング</emphasis> を適用する過程ですでに実現していたことを説明しました。そして、<emphasis role="strong">オープン・クローズドの原則</emphasis> を満たすコードに <emphasis role="strong">リファクタリング</emphasis> されたことで既存のコードを変更することなく振る舞いを変更できるようになりました。</simpara>
<simpara>加えて、正常系の設計を改善した後 <emphasis role="strong">アサーションの導入</emphasis> <emphasis role="strong">例外によるエラーコードの置き換え</emphasis> といった例外系の <emphasis role="strong">リファクタリング</emphasis> を適用しました。最後に <emphasis role="strong">ポリモーフィズム</emphasis> の応用として <emphasis role="strong">特殊ケースの導入</emphasis> の適用による <emphasis role="strong">Null Objectパターン</emphasis> を使った <emphasis role="strong">オープン・クローズドの原則</emphasis> に従った安全なコードの追加方法を解説しました。</simpara>
</section>
<section xml:id="_モジュールの分割">
<title>モジュールの分割</title>
<simpara>仕上げに、<emphasis role="strong">モノリシック</emphasis> なファイルから個別のクラスモジュールへの分割を <emphasis role="strong">ドメインオブジェクト</emphasis> の抽出を通して <emphasis role="strong">ドメインモデル</emphasis> へと整理することにより <emphasis role="strong">モジュール分割</emphasis> を実現しました。最終的にプログラムからアプリケーションへと体裁を整えることが出来ました。以下が最終的なモジュール構造とコードです。</simpara>
<screen>package "lib" {
  package "Application" {
    class FizzBuzzCommand {
    }
    class FizzBuzzValueCommand {
    }
    class FizzBuzzListCommand {
    }
  }
  package "Domain" {
    package "Model" {
      class FizzBuzzValue {
      }
      class FizzBuzzList {
      }
    }
    package "Type" {
      class FizzBuzzType {
      }
      class FizzBuzzType01 {
      }
      class FizzBuzzType02 {
      }
      class FizzBuzzType03 {
      }
      class FizzBuzzTypeNotDefined {
      }
    }
  }
}
package "test" {
  class FizzBuzzValueCommandTest {
  }
  class FizzBuzzListCommandTest {
  }
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
<itemizedlist>
<listitem>
<simpara>Application</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>/main.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './lib/fizz_buzz.rb'

command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
command.execute(100).each { |i| puts i.value }</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/application/fizz_buzz_command.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzCommand
  def execute; end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/application/fizz_buzz_value_command.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzValueCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    @type.generate(number).value
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/application/fizz_buzz_list_command.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzListCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    FizzBuzzList.new((1..number).map { |i| @type.generate(i) }).value
  end
end</programlisting>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Domain</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>/lib/domain/model/fizz_buzz_value.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number.negative?

    @number = number
    @value = value
  end

  def to_s
    "#{@number}:#{@value}"
  end

  def ==(other)
    @number == other.number &amp;&amp; @value == other.value
  end

  alias eql? ==
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/model/fizz_buzz_list.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzList
  MAX_COUNT = 100
  attr_reader :value

  def initialize(list)
    raise "上限は#{MAX_COUNT}件までです" if list.count &gt; MAX_COUNT

    @value = list
  end

  def to_s
    @value.to_s
  end

  def add(value)
    FizzBuzzList.new(@value + value)
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      FizzBuzzTypeNotDefined.new
    end
  end

  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type_01.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)
    return FizzBuzzValue.new(number, 'Fizz') if fizz?(number)
    return FizzBuzzValue.new(number, 'Buzz') if buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type_02.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type_03.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type_not_defined.b</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzTypeNotDefined &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, '')
  end

  def to_s
    '未定義'
  end
end</programlisting>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Test</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>/test/application/fizz_buzz_value_command_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzValueCommandTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType01.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType02.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType03.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def test_未定義のタイプを返す
        fizzbuzz = FizzBuzzType.create(4)

        assert_equal '未定義', fizzbuzz.to_s
      end

      def test_空の文字列を返す
        type = FizzBuzzType.create(4)
        command = FizzBuzzValueCommand.new(type)

        assert_equal '', command.execute(3)
      end
    end
  end

  describe '例外ケース' do
    def test_値は正の値のみ許可する
      e = assert_raises RuntimeError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end

      assert_equal '正の値のみ有効です', e.message
    end
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/application/fizz_buzz_list_command_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzListCommandTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzzListCommand.new(FizzBuzzType01.new)
          @result = fizzbuzz.execute(100)
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first.value
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last.value
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2].value
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4].value
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14].value
        end
      end
    end
  end

  describe '例外ケース' do
    def test_100より多い数を許可しない
      e = assert_raises RuntimeError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end

      assert_equal '上限は100件までです', e.message
    end
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/domain/model/fizz_buzz_value_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzValueTest &lt; Minitest::Test
  def test_同じで値である
    value1 = FizzBuzzValue.new(1, '1')
    value2 = FizzBuzzValue.new(1, '1')

    assert value1.eql?(value2)
  end

  def test_to_stringメソッド
    value = FizzBuzzValue.new(3, 'Fizz')

    assert_equal '3:Fizz', value.to_s
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/domain/model/fizz_buzz_list_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzListTest &lt; Minitest::Test
  def test_新しいインスタンスが作られる
    command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    array = command.execute(50)
    list1 = FizzBuzzList.new(array)
    list2 = list1.add(array)

    assert_equal 50, list1.value.count
    assert_equal 100, list2.value.count
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/learning_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class LearningTest &lt; Minitest::Test
  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_selectメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_find_allメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&amp;:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_mapメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_collectメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_findメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&amp;:size)
      assert_equal 'apple', result
    end

    def test_detectメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&amp;:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      result1 = %w[2 4 13 3 1 10].sort
      result2 = %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
      result3 = %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }

      assert_equal %w[1 10 13 2 3 4], result1
      assert_equal %w[1 2 3 4 10 13], result2
      assert_equal %w[13 10 4 3 2 1], result3
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item &lt; 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item &lt; 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_injectメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_reduceメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_良い設計">
<title>良い設計</title>
<simpara>エピソード1では <emphasis role="strong">良いコード</emphasis> について考えました。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TDDは「より良いコードを書けば、よりうまくいく」という素朴で奇妙な仮設によって成り立っている</simpara>
</blockquote>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>「動作するきれいなコード」。RonJeffriesのこの簡潔な言葉が、テスト駆動開発(TDD)のゴールだ。動作するきれいなコードはあらゆる意味で価値がある。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>良いコードかどうかは、変更がどれだけ容易なのかで決まる。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>コードは理解しやすくなければいけない。</simpara>
</blockquote>
<simpara>本エピソードでは <emphasis role="strong">テスト駆動開発</emphasis> による <emphasis role="strong">オブジェクト指向プログラミング</emphasis> の <emphasis role="strong">リファクタリング</emphasis> を経てコードベースを改善してきました。そして <emphasis role="strong">オブジェクト指向設計</emphasis> により <emphasis role="strong">良いコード</emphasis> のプログラムを <emphasis role="strong">良い設計</emphasis> のアプリケーションへと進化させることができました。</simpara>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>どこに何が書いてあるかをわかりやすくし、変更の影響を狭い範囲に閉じ込め、安定して動作する部品を柔軟に組み合わせながらソフトウェアを構築する技法がオブジェクト指向設計です。</simpara>
</blockquote>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>設計の良し悪しは、ソフトウェアを変更するときにはっきりします。</simpara>
<simpara>構造が入り組んだわかりづらいプログラムは内容の理解に時間がかかります。重複したコードをあちこちで修正する作業が増え、変更の副作用に悩まされます。</simpara>
<simpara>一方、うまく設計されたプログラムは変更が楽で安全です。変更すべき箇所がかんたんにわかり、変更するコード量が少なく、変更の影響を狭い範囲に限定できます。</simpara>
<simpara>プログラムの修正に３日かかるか、それとも半日で済むか。その違いを生むのが「設計」なのです。</simpara>
</blockquote>
<simpara>では、いつ設計をしていたのでしょうか？ わかりますよね、このエピソードの始まりから終わりまで常に設計をしていたのです。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TDDは分析技法であり、設計技法であり、実際には開発のすべてのアクティビティを構造化する技法なのだ。</simpara>
</blockquote>
</section>
</section>
</section>
</section>
<section xml:id="_エピソード4">
<title>エピソード4</title>
<section xml:id="_クライアント開発から始めるテスト駆動開発">
<title>クライアント開発から始めるテスト駆動開発</title>
<section xml:id="_apiサービスを作る">
<title>APIサービスを作る</title>

</section>
<section xml:id="_apiサービスと連携する">
<title>APIサービスと連携する</title>

</section>
<section xml:id="_uiを作る">
<title>UIを作る</title>

</section>
<section xml:id="_uiとapiサービスを連携する">
<title>UIとAPIサービスを連携する</title>

</section>
</section>
</section>
<section xml:id="_エピソード5">
<title>エピソード5</title>
<section xml:id="_継続的インテグレーションから始めるテスト駆動開発">
<title>継続的インテグレーションから始めるテスト駆動開発</title>
<section xml:id="_e2eテストのセットアップ">
<title>E2Eテストのセットアップ</title>

</section>
<section xml:id="_クライアントモジュールの分割">
<title>クライアントモジュールの分割</title>

</section>
<section xml:id="_本番環境と開発環境で表示を切り返る">
<title>本番環境と開発環境で表示を切り返る</title>

</section>
<section xml:id="_クライアントタスクの自動化">
<title>クライアントタスクの自動化</title>

</section>
<section xml:id="_コードレビュー">
<title>コードレビュー</title>

</section>
</section>
</section>
<section xml:id="_エピソードx">
<title>エピソードx</title>
<section xml:id="_パフォーマンスチューニングから始めるテスト駆動開発">
<title>パフォーマンスチューニングから始めるテスト駆動開発</title>
<section xml:id="_概要">
<title>概要</title>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0">フィボナッチ数</link> を計算するプログラムを <emphasis role="strong">テスト駆動開発</emphasis> で作ります。</simpara>
<simpara>初めに <emphasis role="strong">TODOリスト</emphasis> をプログラミング作業をリストアップします。次に、最初に失敗するテストを作成します。 その後 <emphasis role="strong">仮実装</emphasis> でベタ書き値を返すテストを実行します。 それから <emphasis role="strong">三角測量</emphasis> を使って慎重にアルゴリズムを一般化していきます。そして、 <emphasis role="strong">明白な実装</emphasis> によりアルゴリズムを完成させます。</simpara>
<simpara>アルゴリズムが完成したら <emphasis role="strong">リファクタリング</emphasis> を実施してコードベースを <emphasis role="strong">動作するきれいなコード</emphasis> に洗練していきます。</simpara>
<simpara><emphasis role="strong">動作するきれいなコード</emphasis> になったらパフォーマンスの検証をするためパフォーマンスチューニングを実施します。 パフォーマンスチューニングでは <emphasis role="strong">プロファイラ</emphasis> を使ったプログラムのボトルネック調査を実施します。アルゴリズムのパフォーマンスを改善したら別途追加したアルゴリズムと <emphasis role="strong">ベンチマーク</emphasis> を実施してどのアルゴリズムを採用するかを決定します。</simpara>
<simpara>仕上げは、 <emphasis role="strong">モジュール分割</emphasis> によりRubyアプリケーションとしてリリースします。</simpara>
</section>
<section xml:id="_仕様">
<title>仕様</title>
<simpara>仕様は以下の通りです。</simpara>
<blockquote>
<attribution>
Wikipedia
</attribution>
<simpara>n 番目のフィボナッチ数を Fn で表すと、Fn は再帰的に</simpara>
<simpara>F0 = 0,</simpara>
<simpara>F1 = 1,</simpara>
<simpara>Fn + 2 = Fn + Fn + 1 (n ≧ 0)</simpara>
<simpara>で定義される。これは、2つの初期条件を持つ漸化式である。</simpara>
<simpara>この数列 (Fn)はフィボナッチ数列（フィボナッチすうれつ、（英: Fibonacci sequence）と呼ばれ、</simpara>
<simpara>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, …（オンライン整数列大辞典の数列 A45）
と続く。最初の二項は 0, 1 であり、以後どの項もその直前の2つの項の和となっている。</simpara>
</blockquote>
<simpara>表形式にすると以下のようになります。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="15%"?>
<?dbfo table-width="15%"?>
<?dblatex table-width="15%"?>
<tgroup cols="20">
<colspec colname="col_1" colwidth="3*"/>
<colspec colname="col_2" colwidth="3*"/>
<colspec colname="col_3" colwidth="3*"/>
<colspec colname="col_4" colwidth="3*"/>
<colspec colname="col_5" colwidth="3*"/>
<colspec colname="col_6" colwidth="3*"/>
<colspec colname="col_7" colwidth="3*"/>
<colspec colname="col_8" colwidth="3*"/>
<colspec colname="col_9" colwidth="3*"/>
<colspec colname="col_10" colwidth="3*"/>
<colspec colname="col_11" colwidth="3*"/>
<colspec colname="col_12" colwidth="3*"/>
<colspec colname="col_13" colwidth="3*"/>
<colspec colname="col_14" colwidth="3*"/>
<colspec colname="col_15" colwidth="3*"/>
<colspec colname="col_16" colwidth="3*"/>
<colspec colname="col_17" colwidth="3*"/>
<colspec colname="col_18" colwidth="3*"/>
<colspec colname="col_19" colwidth="3*"/>
<colspec colname="col_20" colwidth="3*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>11</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>14</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>18</simpara></entry>
<entry align="left" valign="top"><simpara>19</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>21</simpara></entry>
<entry align="left" valign="top"><simpara>34</simpara></entry>
<entry align="left" valign="top"><simpara>55</simpara></entry>
<entry align="left" valign="top"><simpara>89</simpara></entry>
<entry align="left" valign="top"><simpara>144</simpara></entry>
<entry align="left" valign="top"><simpara>233</simpara></entry>
<entry align="left" valign="top"><simpara>377</simpara></entry>
<entry align="left" valign="top"><simpara>610</simpara></entry>
<entry align="left" valign="top"><simpara>987</simpara></entry>
<entry align="left" valign="top"><simpara>1597</simpara></entry>
<entry align="left" valign="top"><simpara>2584</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_todoリスト_2">
<title>TODOリスト</title>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TODOリスト</simpara>
<simpara>何をテストすべきだろうか----着手する前に、必要になりそうなテストをリストに書き出しておこう。</simpara>
</blockquote>
<simpara><emphasis role="strong">TODOリスト</emphasis> を書き出す取っ掛かりとして仕様で定義されている内容からプログラムで実施できる内容に分解してきましょう。
仕様では以下のように定義されているので。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="15%"?>
<?dbfo table-width="15%"?>
<?dblatex table-width="15%"?>
<tgroup cols="20">
<colspec colname="col_1" colwidth="3*"/>
<colspec colname="col_2" colwidth="3*"/>
<colspec colname="col_3" colwidth="3*"/>
<colspec colname="col_4" colwidth="3*"/>
<colspec colname="col_5" colwidth="3*"/>
<colspec colname="col_6" colwidth="3*"/>
<colspec colname="col_7" colwidth="3*"/>
<colspec colname="col_8" colwidth="3*"/>
<colspec colname="col_9" colwidth="3*"/>
<colspec colname="col_10" colwidth="3*"/>
<colspec colname="col_11" colwidth="3*"/>
<colspec colname="col_12" colwidth="3*"/>
<colspec colname="col_13" colwidth="3*"/>
<colspec colname="col_14" colwidth="3*"/>
<colspec colname="col_15" colwidth="3*"/>
<colspec colname="col_16" colwidth="3*"/>
<colspec colname="col_17" colwidth="3*"/>
<colspec colname="col_18" colwidth="3*"/>
<colspec colname="col_19" colwidth="3*"/>
<colspec colname="col_20" colwidth="3*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>11</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>14</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>18</simpara></entry>
<entry align="left" valign="top"><simpara>19</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>21</simpara></entry>
<entry align="left" valign="top"><simpara>34</simpara></entry>
<entry align="left" valign="top"><simpara>55</simpara></entry>
<entry align="left" valign="top"><simpara>89</simpara></entry>
<entry align="left" valign="top"><simpara>144</simpara></entry>
<entry align="left" valign="top"><simpara>233</simpara></entry>
<entry align="left" valign="top"><simpara>377</simpara></entry>
<entry align="left" valign="top"><simpara>610</simpara></entry>
<entry align="left" valign="top"><simpara>987</simpara></entry>
<entry align="left" valign="top"><simpara>1597</simpara></entry>
<entry align="left" valign="top"><simpara>2584</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>最初のタスクは <literal>0を渡したら0を返す</literal> 振る舞いをするプログラムを作ることにしましょう。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="15%"?>
<?dbfo table-width="15%"?>
<?dblatex table-width="15%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="32*"/>
<colspec colname="col_2" colwidth="32*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>同様のパターンで他のタスクも切り出してみましょう。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="15%"?>
<?dbfo table-width="15%"?>
<?dblatex table-width="15%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="21*"/>
<colspec colname="col_2" colwidth="21*"/>
<colspec colname="col_3" colwidth="21*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="15%"?>
<?dbfo table-width="15%"?>
<?dblatex table-width="15%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="16*"/>
<colspec colname="col_2" colwidth="16*"/>
<colspec colname="col_3" colwidth="16*"/>
<colspec colname="col_4" colwidth="16*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>とりあえず、３件ほどタスクとして切り出したので <emphasis role="strong">TODOリスト</emphasis> の作成は一旦終了してプログラミング作業に入るとしましょう。</simpara>
<itemizedlist>
<listitem>
<simpara>0を渡したら0を返す</simpara>
</listitem>
<listitem>
<simpara>1を渡したら1を返す</simpara>
</listitem>
<listitem>
<simpara>2を渡したら1を返す</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_仮実装_2">
<title>仮実装</title>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>仮実装を経て本実装へ</simpara>
<simpara>失敗するテストを書いてから、最初に行う実装はどのようなものだろうか----ベタ書きの値を返そう。</simpara>
</blockquote>
<section xml:id="_0を渡したら0を返す">
<title>0を渡したら0を返す</title>
<simpara>早速、 <emphasis role="strong">TODOリスト</emphasis> の１つ目から片付けていくとしましょう。</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">0を渡したら0を返す</emphasis></simpara>
</listitem>
<listitem>
<simpara>1を渡したら1を返す</simpara>
</listitem>
<listitem>
<simpara>2を渡したら1を返す</simpara>
</listitem>
</itemizedlist>
<simpara>まずは最初に失敗するテストを書きますがまずは以下のサンプルコードを使ってテスティングフレームワークの動作確認をしておきましょう。今回利用するRubyのテスティングフレームワークは <link xl:href="https://github.com/seattlerb/minitest">minitest</link> です。 <literal>test</literal> フォルダ以下に <literal>fibonacci_test.rb</literal> ファイルを追加して以下のコードを入力します。</simpara>
<simpara><literal>test/fibonacci_test.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'

class FibonacciTest &lt; Minitest::Test
  def greeting
    'hello world'
  end

  def test_greeting
    assert_equal 'hello world', greeting
  end
end</programlisting>
<simpara>今回テスト結果を見やすくするため <literal>minitest/reporters</literal> というgemを使っているのでまずインストールしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ gem install minitest-reporters</programlisting>
<simpara>gemインストールが完了したらコマンドラインに <literal>ruby test/fibonacci_test.rb</literal> コマンドを入力してテストを実施します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 28548

  1/1: [==========================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01040s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>テストは無事実行されたようですね。続いてテストが失敗するか確認しておきましょう。 <literal>greeting</literal> メソッドの <literal>hello world</literal> を <literal>hello world!</literal> に変更してテストを実行します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci &lt; Minitest::Test
  def greeting
    'hello world!'
  end
...
end</programlisting>
<simpara>テストは失敗して以下のようなメッセージが表示されました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 30787

 FAIL["test_greeting", &lt;Minitest::Reporters::Suite:0x000055eaefeef5e0 @name="Fibonacci"&gt;, 0.003157061990350485]
 test_greeting#Fibonacci (0.00s)
        Expected: "hello world"
          Actual: "hello world!"
        test/fibonacci_test.rb:13:in `test_greeting`

  1/1: [==========================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00398s
1 tests, 1 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>テスティングフレームワークのセットアップと動作確認が終了したので最初の失敗するテストを書きます。まずは <emphasis role="strong">アサーションファースト</emphasis>　でサンプルコードを削除して以下のコードにします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def test_fibonacci
    assert_equal 0, fib(0)
  end
end</programlisting>
<simpara>テストは無事？失敗します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 21656

ERROR["test_fibonacci", &lt;Minitest::Reporters::Suite:0x0000559acae8d068 @name="FibonacciTest"&gt;, 0.001314591965638101]
 test_fibonacci#FibonacciTest (0.00s)
Minitest::UnexpectedError:         NoMethodError: undefined method `fib' for #&lt;FibonacciTest:0x0000559acae8d860&gt;
            test/fibonacci_test.rb:9:in `test_fibonacci'`

  1/1: [========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00419s
1 tests, 0 assertions, 0 failures, 1 errors, 0 skips</programlisting>
<simpara>まずは <emphasis role="strong">仮実装</emphasis> でテストを通すようにしましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    0
  end

  def test_fibonacci
    assert_equal 0, fib(0)
  end
end</programlisting>
<simpara>テストはレッドからグリーンになりました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 2885

  1/1: [==========================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00352s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが通ったのでバージョン管理システムにコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: 0を渡したら0を返す'</programlisting>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>1を渡したら1を返す</simpara>
</listitem>
<listitem>
<simpara>2を渡したら1を返す</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_三角測量_2">
<title>三角測量</title>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>三角測量</simpara>
<simpara>テストから最も慎重に一般化を引き出すやり方はどのようなものだろうか----２つ以上の例があるときだけ、一般化を行うようにしよう。</simpara>
</blockquote>
<section xml:id="_1を渡したら1を返す">
<title>1を渡したら1を返す</title>
<simpara>１つ目の <emphasis role="strong">TODOリスト</emphasis> を片付けたので２つ目の <emphasis role="strong">TODOリスト</emphasis> に取り掛かるとしましょう。</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">1を渡したら1を返す</emphasis></simpara>
</listitem>
<listitem>
<simpara>2を渡したら1を返す</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">テストファースト</emphasis>　<emphasis role="strong">アサーションファースト</emphasis> なのでまずはテストを追加するとこから始めます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    0
  end

  def test_fibonacci
    assert_equal 0, fib(0)
    assert_equal 1, fib(1)
  end
end</programlisting>
<simpara>テストは失敗します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 21207

 FAIL["test_fibonacci", &lt;Minitest::Reporters::Suite:0x000056525007ccb0 @name="FibonacciTest"&gt;, 0.0014098359970375896]
 test_fibonacci#FibonacciTest (0.00s)
        Expected: 1
          Actual: 0
        test/fibonacci_test.rb:14:in `test_fibonacci`

  1/1: [========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00196s
1 tests, 2 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara><emphasis role="strong">仮実装</emphasis> で0しか返さないベタ書きのコードなのだから当然ですよね。0ならば0を返してそれ以外の場合は1を返すようにプログラムを変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?

    1
  end
...
end</programlisting>
<simpara>プログラムの変更によりテストはレッドからグリーンに戻りました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 58331

  1/1: [==========================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00169s
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>ここでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: 1を渡したら1を返す'</programlisting>
</section>
<section xml:id="_リファクタリング_2">
<title>リファクタリング</title>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>2を渡したら1を返す</simpara>
</listitem>
</itemizedlist>
<simpara>次の <emphasis role="strong">TODOリスト</emphasis> に着手する前にテストケース内の重複が気になり始めたので、共通部分をアサーションからくくり出して、入力値と期待値の組でテストを回すようにテストコードを <emphasis role="strong">リファクタリング</emphasis> します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci &lt; Minitest::Test
...
  def test_fibonacci
    cases = [[0, 0], [1, 1]]
    cases.each do |i|
      assert_equal i[1], fib(i[0])
    end
  end
end</programlisting>
<simpara>テストを実行してプログラムが壊れていないことを確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 5991

  1/1: [==========================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00200s
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>プログラムが壊れていないことが確認できたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: アルゴリズムの置き換え'</programlisting>
</section>
<section xml:id="_1を渡したら2を返す">
<title>1を渡したら2を返す</title>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">2を渡したら1を返す</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>テストコードの　<emphasis role="strong">リファクタリング</emphasis> を実施したので続いて　<emphasis role="strong">TODOリスト</emphasis> の３つ目に着手します。まずは <emphasis role="strong">アサーション</emphasis> の追加ですね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?

    1
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1]]
    cases.each do |i|
      assert_equal i[1], fib(i[0])
    end
  end
end</programlisting>
<simpara>おや、今回はプロダクトコードを変更しなくてもテストは通るようです。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 26882

  1/1: [==========================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00287s
1 tests, 3 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>ここでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: 1を渡したら2を返す'</programlisting>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_明白な実装_2">
<title>明白な実装</title>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>明白な実装</simpara>
<simpara>シンプルな操作を実現するにはどうすればいいだろうか----そのまま実装しよう。</simpara>
<simpara>仮実装や三角測量は、細かく細かく刻んだ小さなステップだ。だが、ときには実装をどうすべきか既に見えていることが。
そのまま進もう。例えば先ほどのplusメソッドくらいシンプルなものを仮実装する必要が本当にあるだろうか。
普通は、その必要はない。頭に浮かんだ明白な実装をただ単にコードに落とすだけだ。もしもレッドバーが出て驚いたら、あらためてもう少し歩幅を小さくしよう。</simpara>
</blockquote>
<section xml:id="_3を渡したら2を返す">
<title>3を渡したら2を返す</title>
<simpara>最初に定義した <emphasis role="strong">TODOリスト</emphasis> の内容は完了しましたがプログラムの一般化にはまだテストケースが足りないでしょう。3を渡した場合のテストケースを追加します。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="15%"?>
<?dbfo table-width="15%"?>
<?dblatex table-width="15%"?>
<tgroup cols="5">
<colspec colname="col_1" colwidth="13*"/>
<colspec colname="col_2" colwidth="13*"/>
<colspec colname="col_3" colwidth="13*"/>
<colspec colname="col_4" colwidth="13*"/>
<colspec colname="col_5" colwidth="13*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">3を渡したら2を返す</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>テストケースを追加してテストを実施します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
...
  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2]]
    cases.each do |i|
      assert_equal i[1], fib(i[0])
    end
  end
end</programlisting>
<simpara>テストが失敗しました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 7598

 FAIL["test_fibonacci", &lt;Minitest::Reporters::Suite:0x000055c987498120 @name="FibonacciTest"&gt;, 0.00104286998976022]
 test_fibonacci#FibonacciTest (0.00s)
        Expected: 2
          Actual: 1
        test/fibonacci_test.rb:17:in `block in test_fibonacci''
        test/fibonacci_test.rb:16:in `each'
        test/fibonacci_test.rb:16:in `test_fibonacci'

  1/1: [========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00160s
1 tests, 4 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>2までは1を返すので条件分岐を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?
    return 1 if n &lt;= 2

    1
  end
...
end</programlisting>
<simpara>まだ、失敗したままです。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 26066

 FAIL["test_fibonacci", &lt;Minitest::Reporters::Suite:0x0000562bc96ee330 @name="Fibonacci"&gt;, 0.0055934099946171045]
 test_fibonacci#Fibonacci (0.01s)
        Expected: 2
          Actual: 1
        test/fibonacci_test.rb:24:in `block in test_fibonacci'
        test/fibonacci_test.rb:23:in `each'
        test/fibonacci_test.rb:23:in `test_fibonacci''

  1/1: [==========================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00882s
1 tests, 4 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>どの条件にも該当としない場合は2を返すように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?
    return 1 if n &lt;= 2

    2
  end
...
end</programlisting>
<simpara>グリーンになりました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 25117

  1/1: [==========================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01680s
1 tests, 4 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>ここでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: 3を渡したら2を返す'</programlisting>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら2を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_フィボナッチ数計算">
<title>フィボナッチ数計算</title>
<simpara>そろそろゴールが見えてきました。<emphasis role="strong">TODOリスト</emphasis> を追加してフィボナッチ数計算アルゴリズムを完成させましょう。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="15%"?>
<?dbfo table-width="15%"?>
<?dblatex table-width="15%"?>
<tgroup cols="6">
<colspec colname="col_1" colwidth="11*"/>
<colspec colname="col_2" colwidth="11*"/>
<colspec colname="col_3" colwidth="11*"/>
<colspec colname="col_4" colwidth="11*"/>
<colspec colname="col_5" colwidth="11*"/>
<colspec colname="col_6" colwidth="11*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら2を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">4を渡したら3を返す</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">テストファースト</emphasis> <emphasis role="strong">アサートファースト</emphasis> です。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?
    return 1 if n &lt;= 2

    2
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3]]
    cases.each do |i|
      assert_equal i[1], fib(i[0])
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 34595

 FAIL["test_fibonacci", &lt;Minitest::Reporters::Suite:0x0000564fdbd6dfe0 @name="Fibonacci"&gt;, 0.005386559059843421]
 test_fibonacci#Fibonacci (0.01s)
        Expected: 3
          Actual: 2
        test/fibonacci_test.rb:24:in `block in test_fibonacci'
        test/fibonacci_test.rb:23:in `each'
        test/fibonacci_test.rb:23:in `test_fibonacci''

  1/1: [==========================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01030s
1 tests, 5 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>最後に2を返すのではなく合計値をかえすのだから</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?
    return 1 if n &lt;= 2

    1 + 1
  end
...
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 10848

 FAIL["test_fibonacci", &lt;Minitest::Reporters::Suite:0x00005621247c9f48 @name="Fibonacci"&gt;, 0.0007573128677904606]
 test_fibonacci#Fibonacci (0.00s)
        Expected: 3
          Actual: 2
        test/fibonacci_test.rb:24:in `block in test_fibonacci'
        test/fibonacci_test.rb:23:in `each'
        test/fibonacci_test.rb:23:in `test_fibonacci''

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00130s
1 tests, 5 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>一つ前の <literal>fib</literal> の結果を足すのだから</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?
    return 1 if n &lt;= 2

    fib(n - 1) + 1
  end
...
end</programlisting>
<simpara>グリーンになりました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 25629

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00467s
1 tests, 5 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>ここでコミット。。。しないで今回は更に進めます。 <emphasis role="strong">TODOリスト</emphasis> を追加します。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="15%"?>
<?dbfo table-width="15%"?>
<?dblatex table-width="15%"?>
<tgroup cols="7">
<colspec colname="col_1" colwidth="9*"/>
<colspec colname="col_2" colwidth="9*"/>
<colspec colname="col_3" colwidth="9*"/>
<colspec colname="col_4" colwidth="9*"/>
<colspec colname="col_5" colwidth="9*"/>
<colspec colname="col_6" colwidth="9*"/>
<colspec colname="col_7" colwidth="9*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら2を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">4を渡したら3を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">5を渡したら5を返す</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>テストケースを追加して</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
...
  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], fib(i[0])
    end
  end
end</programlisting>
<simpara>レッド</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 54754

 FAIL["test_fibonacci", &lt;Minitest::Reporters::Suite:0x000055c42397e108 @name="Fibonacci"&gt;, 0.00174815789796412]
 test_fibonacci#Fibonacci (0.00s)
        Expected: 5
          Actual: 4
        test/fibonacci_test.rb:24:in `block in test_fibonacci'
        test/fibonacci_test.rb:23:in `each'
        test/fibonacci_test.rb:23:in `test_fibonacci''

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00237s
1 tests, 6 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<simpara>結局1つ前と2つ前の <literal>fib</literal> の結果を合計して返しているのだから</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?
    return 1 if n &lt;= 2

    fib(n - 1) + fib(n - 2)
  end
...
end</programlisting>
<simpara>グリーン</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 8399

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00107s
1 tests, 6 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>一般化ができたので0の場合と1の場合は与えらた値を返せば良くなったので</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?
    return 1 if n == 1

    fib(n - 1) + fib(n - 2)
  end
...
end</programlisting>
<simpara>リファクター</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 42476

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00162s
1 tests, 6 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>フィボナッチ数計算アルゴリズムが完成したのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'feat: フィボナッチ数計算'</programlisting>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">0を渡したら0を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">2を渡したら1を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら2を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">4を渡したら3を返す</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら5を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_リファクタリング_3">
<title>リファクタリング</title>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>リファクタリング(名詞) 外部から見たときの振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版
</attribution>
<simpara>リファクタリングする(動詞) 一連のリファクタリングを適用して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること。</simpara>
</blockquote>
<simpara>アルゴリズムの実装は出来ましたがアプリケーションとしては不十分なので <emphasis role="strong">リファクタリング</emphasis> を適用してコードを <emphasis role="strong">動作するきれいなコード</emphasis> に洗練していきます。</simpara>
<section xml:id="_クラスの抽出">
<title>クラスの抽出</title>
<simpara>まず、テストケース内でメソッドを定義していますがこれでは一つのクラスでアルゴリズムの実行とテストの実行という２つの責務を <literal>FibonacciTest</literal> クラスが担当しています。 <emphasis role="strong">単一責任の原則</emphasis> に違反しているので <emphasis role="strong">クラスの抽出</emphasis> を実施して責務を分担させましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
  def fib(n)
    return 0 if n.zero?
    return 1 if n == 1

    fib(n - 1) + 1
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], fib(i[0])
    end
  end
end</programlisting>
<simpara><literal>Fibonacci</literal> クラスを作成して <emphasis role="strong">クラスメソッド</emphasis> の <literal>Fibonacci.fib</literal> をコピー＆ペーストで作成します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.fib(n)
    return 0 if n.zero?
    return 1 if n == 1

    fib(n - 1) + fib(n - 2)
  end
end

class FibonacciTest &lt; Minitest::Test
  def self.fib(n)
    return 0 if n.zero?
    return 1 if n == 1

    fib(n - 1) + fib(n - 2)
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], fib(i[0])
    end
  end
end</programlisting>
<simpara>テストが壊れていないことを確認したら <literal>FibonacciTest</literal> クラス内の <emphasis role="strong">クラスメソッド</emphasis> <literal>FIbonacciTest.fib</literal> を削除して <emphasis role="strong">フィクスチャー</emphasis> <literal>setup</literal> メソッドを作成して <emphasis role="strong">インスタンス変数</emphasis> <literal>@fib</literal> に <literal>Fibonacci</literal> クラスの参照を代入します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.fib(n)
    return 0 if n.zero?
    return 1 if n == 1

    fib(n - 1) + fib(n - 2)
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.fib(i[0])
    end
  end
end</programlisting>
<simpara>テストが壊れていないかを確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 40694

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00393s
1 tests, 6 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara><emphasis role="strong">クラスの抽出</emphasis> の <emphasis role="strong">リファクタリング</emphasis> 適用が完了したのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: クラスの抽出'</programlisting>
</section>
<section xml:id="_変数名の変更_2">
<title>変数名の変更</title>
<simpara>続いて、 <literal>Fibonacci</literal> クラスに移動した <emphasis role="strong">クラスメソッド</emphasis> ですが引数が <literal>n</literal> というのは分かりづらいですね。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.fib(n)
    return 0 if n.zero?
    return 1 if n == 1

    fib(n - 1) + fib(n - 2)
  end
end
...</programlisting>
<simpara>ここは省略せず、引数の型を表す名前に変更して可読性を上げておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.fib(number)
    return 0 if number.zero?
    return 1 if number == 1

    fib(number - 1) + fib(number - 2)
  end
end
...</programlisting>
<simpara>テストが壊れていないか確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 37760

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00744s
1 tests, 6 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>コミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: 変数名の変更'</programlisting>
</section>
<section xml:id="_メソッド名の変更_2">
<title>メソッド名の変更</title>
<simpara><literal>Fibonacci</literal> クラスの <emphasis role="strong">クラスメソッド</emphasis> <literal>Fibonacci.fib</literal> はフィボナッチ数を計算するメソッドですが名前が紛らわしいので <emphasis role="strong">メソッド名の変更</emphasis> を適用します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.fib(number)
    return 0 if number.zero?
    return 1 if number == 1

    fib(number - 1) + fib(number - 2)
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.fib(i[0])
    end
  end
end</programlisting>
<simpara><emphasis role="strong">インスタンスメソッド</emphasis> を <literal>fib</literal> から <literal>calc</literal> に変更します。今回は呼び出し先の <literal>FibonacciTest</literal> のテストコードも修正する必要があります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.calc(number)
    return 0 if number.zero?
    return 1 if number == 1

    calc(number - 1) + calc(number - 2)
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.calc(i[0])
    end
  end
end</programlisting>
<simpara>テストが壊れていないか確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 15099

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00285s
1 tests, 6 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara><emphasis role="strong">メソッド名の変更</emphasis> の適用が完了したのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッド名の変更'</programlisting>
</section>
</section>
<section xml:id="_パフォーマンスチューニング">
<title>パフォーマンスチューニング</title>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>心がけるべきことは、他のパフォーマンス分析とおなじように、実際のデータを使い、リアルな利用パターンを試し、プロファイリングを行ってからでないと、パフォーマンスを問題にする資格はない、ということだ。</simpara>
</blockquote>
<simpara>これまでのテストケースでは小さな値を使ってきましたが大きな値の場合のプログラムの挙動が問題無いか確認しておく必要があります <link xl:href="http://www.suguru.jp/Fibonacci/Fib100.html">１００番目までのフィボナッチ数列</link> を参考に大きな値の場合のテストケースを追加してアプリケーションのパフォーマンスを検証しましょう。</simpara>
<section xml:id="_メモ化によるパフォーマンス改善">
<title>メモ化によるパフォーマンス改善</title>
<simpara><emphasis role="strong">TODOリスト</emphasis> に新しいタスクを追加します。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="15%"?>
<?dbfo table-width="15%"?>
<?dblatex table-width="15%"?>
<tgroup cols="7">
<colspec colname="col_1" colwidth="9*"/>
<colspec colname="col_2" colwidth="9*"/>
<colspec colname="col_3" colwidth="9*"/>
<colspec colname="col_4" colwidth="9*"/>
<colspec colname="col_5" colwidth="9*"/>
<colspec colname="col_6" colwidth="9*"/>
<colspec colname="col_7" colwidth="9*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
<entry align="left" valign="top"><simpara>38</simpara></entry>
<entry align="left" valign="top"><simpara>39</simpara></entry>
<entry align="left" valign="top"><simpara>40</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
<entry align="left" valign="top"><simpara>39088169</simpara></entry>
<entry align="left" valign="top"><simpara>63245986</simpara></entry>
<entry align="left" valign="top"><simpara>102334155</simpara></entry>
<entry align="left" valign="top"><simpara>&#8230;&#8203;</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<itemizedlist>
<listitem>
<simpara>大きな数値を計算する</simpara>
</listitem>
</itemizedlist>
<simpara>テストケースを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FibonacciTest &lt; Minitest::Test
...
  def test_large_number
    assert_equal 102_334_155, @fib.calc(40)
  end
end</programlisting>
<simpara>テストを実行します</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 1160

  2/2: [=========================================] 100% Time: 00:00:51, Time: 00:00:51

Finished in 51.15914s
2 tests, 7 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが完了するのが随分遅くなってしまいました。これはアルゴリズムを改善する必要がありそうです。
まずは <emphasis role="strong">プロファイラ</emphasis> を使って実行状況を確認します。今回は <link xl:href="https://docs.ruby-lang.org/ja/latest/library/profile.html">profileライブラリ</link> を使います。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby -r profile test/fibonacci_test.rb
Started with run options --seed 42383

  2/1: [======================                      ] 50% Time: 00:00:00,  ETA: 00:00:00</programlisting>
<simpara>処理が終わらないようなら <literal>ctr-c</literal> で強制終了すれば結果が出力されます。出力内容の <literal>Fibonacci.calc</literal> がフィボナッチ数計算メソッド実行部分です。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
192.39    25.50     25.50        2 12750.69 12750.69  Thread::Queue#pop
 75.32    35.49      9.98   246940     0.04     1.65  Fibonacci.calc
....</programlisting>
<simpara>再帰呼び出しが何度も実行された結果パフォーマンスを低下させているようです。ここは <link xl:href="https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%A2%E5%8C%96">メモ化</link> を使ってパフォーマンスを改善させましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.calc(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= calc(number - 1, memo) + calc(number - 2, memo)
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.calc(i[0])
    end
  end

  def test_large_number
    assert_equal 102_334_155, @fib.calc(40)
  end
end</programlisting>
<simpara><emphasis role="strong">プロファイラ</emphasis> で確認します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby -r profile test/fibonacci_test.rb
Started with run options --seed 20468

  2/2: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.04214s
2 tests, 7 assertions, 0 failures, 0 errors, 0 skips
  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
...
 12.09     0.06      0.06        2    32.09    32.09  Thread::Queue#pop
...
  1.33     0.26      0.01      105     0.07     1.41  Fibonacci.calc
...</programlisting>
<simpara>一気に再帰呼び出し回数が減りパフォーマンスを改善することが出来ましたのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'perf: メモ化によるパフォーマンス改善'</programlisting>
</section>
</section>
<section xml:id="_ベンチマーク">
<title>ベンチマーク</title>
<simpara>続いて、異なるフィボナッチ数計算アルゴリズムを実装してどのアルゴリズムを採用するべきかを <link xl:href="https://ja.wikipedia.org/wiki/%E3%83%99%E3%83%B3%E3%83%81%E3%83%9E%E3%83%BC%E3%82%AF">ベンチマーク</link> を取って判断したいと思います。</simpara>
<section xml:id="_ループ処理による実装">
<title>ループ処理による実装</title>
<simpara>まずはループ処理によるフィボナッチ数計算のアルゴリズムを実装します。以下が <emphasis role="strong">テストファースト</emphasis> <emphasis role="strong">アサートファースト</emphasis> で作成したコードです。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.calc(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= calc(number - 1, memo) + calc(number - 2, memo)
  end

  def self.calc2(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |i|
      a = b
      b = c
      c = a + b
    end
    c
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.calc(i[0])
    end
  end

  def test_large_number
    assert_equal 102_334_155, @fib.calc(40)
  end

  def test_large_number_calc2
    assert_equal 102_334_155, @fib.calc2(40)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb -n test_large_number_calc2 Started with run options -n test_large_number_calc2 --seed 18167

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00123s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが通ることを確認したらコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'feat: ループ処理による実装'</programlisting>
</section>
<section xml:id="_一般項による実装">
<title>一般項による実装</title>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0#%E4%B8%80%E8%88%AC%E9%A0%85">フィボナッチ数列の一般項</link> で定義されているのでこれを <emphasis role="strong">テストファースト</emphasis> <emphasis role="strong">アサートファースト</emphasis> で実装します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.calc(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= calc(number - 1, memo) + calc(number - 2, memo)
  end

  def self.calc2(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |i|
      a = b
      b = c
      c = a + b
    end
    c
  end

  def self.calc3(number)
    a = ((1 + Math.sqrt(5)) / 2)**number
    b = ((1 - Math.sqrt(5)) / 2)**number
    ((a - b) / Math.sqrt(5)).round
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.calc(i[0])
    end
  end

  def test_large_number
    assert_equal 102_334_155, @fib.calc(40)
  end

  def test_large_number_calc2
    assert_equal 102_334_155, @fib.calc2(40)
  end

  def test_large_number_calc3
    assert_equal 102_334_155, @fib.calc3(40)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb -n test_large_number_calc3
Started with run options -n test_large_number_calc3 --seed 55659

  1/1: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00111s
1 tests, 1 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが壊れていないか確認したらコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'feat: 一般項による実装'</programlisting>
</section>
<section xml:id="_メソッド名の変更_3">
<title>メソッド名の変更</title>
<simpara>各アルゴリズムのメソッド名が <literal>calc</literal> では分かりづらいので <emphasis role="strong">メソッド名の変更</emphasis> を適用して <emphasis role="strong">リファクタリング</emphasis> します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.recursive(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= recursive(number - 1, memo) + recursive(number - 2, memo)
  end

  def self.calc2(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |i|
      a = b
      b = c
      c = a + b
    end
    c
  end

  def self.calc3(number)
    a = ((1 + Math.sqrt(5)) / 2)**number
    b = ((1 - Math.sqrt(5)) / 2)**number
    ((a - b) / Math.sqrt(5)).round
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.recursive(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @fib.recursive(40)
  end

  def test_large_number_calc2
    assert_equal 102_334_155, @fib.calc2(40)
  end

  def test_large_number_calc3
    assert_equal 102_334_155, @fib.calc3(40)
  end
end</programlisting>
<simpara>まず、最初に実装した再帰呼び出しアルゴリズムのメソッド名を <literal>Fibonacci.calc</literal> から <literal>Fibonacci.recursive</literal> に変更します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 15174

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00137s
4 tests, 9 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>続いて、ループアルゴリズムのメソッド名を <literal>Fibonacci.calc2</literal> から <literal>Fibonacci.loop</literal> に変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class Fibonacci
  def self.recursive(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= recursive(number - 1, memo) + recursive(number - 2, memo)
  end

  def self.loop(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |i|
      a = b
      b = c
      c = a + b
    end
    c
  end

  def self.calc3(number)
    a = ((1 + Math.sqrt(5)) / 2) ** number
    b = ((1 - Math.sqrt(5)) / 2) ** number
    ((a - b) / Math.sqrt(5)).round
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.recursive(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @fib.recursive(40)
  end

  def test_large_number_loop
    assert_equal 102_334_155, @fib.loop(40)
  end

  def test_large_number_calc3
    assert_equal 102_334_155, @fib.calc3(40)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 28586

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00188s
4 tests, 9 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>最後に、一般項アルゴリズムのメソッド名を <literal>Fibonacci.calc3</literal> から <literal>Fibonacci.general_term</literal> に変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.recursive(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= recursive(number - 1, memo) + recursive(number - 2, memo)
  end

  def self.loop(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |i|
      a = b
      b = c
      c = a + b
    end
    c
  end

  def self.general_term(number)
    a = ((1 + Math.sqrt(5)) / 2) ** number
    b = ((1 - Math.sqrt(5)) / 2) ** number
    ((a - b) / Math.sqrt(5)).round
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.recursive(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @fib.recursive(40)
  end

  def test_large_number_loop
    assert_equal 102_334_155, @fib.loop(40)
  end

  def test_large_number_general_term
    assert_equal 102_334_155, @fib.general_term(40)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 42729

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00736s
4 tests, 9 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>変更によりテストが壊れていないことを確認したらコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッド名の変更'</programlisting>
</section>
<section xml:id="_サブクラスによるタイプコードの置き換え_1">
<title>サブクラスによるタイプコードの置き換え 1</title>
<simpara>現在の <literal>Fibonacci</literal> クラスはアルゴリズムを追加する場合クラスを編集する必要があります。その際に既存のアルゴリズムを壊してしまう可能性があります。これは <emphasis role="strong">オープン・クローズド原則</emphasis> に違反しているので <emphasis role="strong">サブクラスによるタイプコードの置き換え</emphasis> を適用してアルゴリズムを <emphasis role="strong">カプセル化</emphasis> して、安全に追加・変更できる設計に <emphasis role="strong">リファクタリング</emphasis> します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.recursive(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= recursive(number - 1, memo) + recursive(number - 2, memo)
  end

  def self.loop(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |_i|
      a = b
      b = c
      c = a + b
    end
    c
  end

  def self.general_term(number)
    a = ((1 + Math.sqrt(5)) / 2)**number
    b = ((1 - Math.sqrt(5)) / 2)**number
    ((a - b) / Math.sqrt(5)).round
  end
end

class FibonacciRecursive
  def calc(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= calc(number - 1, memo) + calc(number - 2, memo)
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
    @recursive = FibonacciRecursive.new
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @recursive.calc(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @recursive.calc(40)
  end

  def test_large_number_loop
    assert_equal 102_334_155, @fib.loop(40)
  end

  def test_large_number_general_term
    assert_equal 102_334_155, @fib.general_term(40)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 12762

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00130s
4 tests, 9 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>まず、<emphasis role="strong">クラスの抽出</emphasis> により再帰呼び出しアルゴリズムの <emphasis role="strong">メソッドオブジェクト</emphasis> <literal>FibonacciRecursive</literal> クラスを作成して テスト <emphasis role="strong">フィクスチャー</emphasis> で <emphasis role="strong">インスタンス化</emphasis> して <emphasis role="strong">インスタンス変数</emphasis> にオブジェクトの参照を代入します。ここではメソッドの呼び出しが <literal>exec</literal> に変更されているのでテストコードもそれに合わせて変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.loop(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |_i|
      a = b
      b = c
      c = a + b
    end
    c
  end

  def self.general_term(number)
    a = ((1 + Math.sqrt(5)) / 2)**number
    b = ((1 - Math.sqrt(5)) / 2)**number
    ((a - b) / Math.sqrt(5)).round
  end
end

class FibonacciRecursive
  def exec(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= exec(number - 1, memo) + exec(number - 2, memo)
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
    @recursive = FibonacciRecursive.new
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @recursive.exec(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @recursive.exec(40)
  end

  def test_large_number_loop
    assert_equal 102_334_155, @fib.loop(40)
  end

  def test_large_number_general_term
    assert_equal 102_334_155, @fib.general_term(40)
  end
end</programlisting>
<simpara>まだ、 仕掛ですがコードが壊れていない状態でコミットをしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): サブクラスによるタイプコードの置き換え'</programlisting>
</section>
<section xml:id="_サブクラスによるタイプコードの置き換え_2">
<title>サブクラスによるタイプコードの置き換え 2</title>
<simpara>続いて、 <emphasis role="strong">メソッドオブジェクト</emphasis> <literal>FibonacciLoop</literal> クラスを抽出します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def self.general_term(number)
    a = ((1 + Math.sqrt(5)) / 2)**number
    b = ((1 - Math.sqrt(5)) / 2)**number
    ((a - b) / Math.sqrt(5)).round
  end
end

class FibonacciRecursive
  def exec(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= exec(number - 1, memo) + exec(number - 2, memo)
  end
end

class FibonacciLoop
  def exec(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |_i|
      a = b
      b = c
      c = a + b
    end
    c
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
    @recursive = FibonacciRecursive.new
    @loop = FibonacciLoop.new
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @recursive.exec(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @recursive.exec(40)
  end

  def test_large_number_loop
    assert_equal 102_334_155, @loop.exec(40)
  end

  def test_large_number_general_term
    assert_equal 102_334_155, @fib.general_term(40)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rbStarted with run options --seed 33171

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00337s
4 tests, 9 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>コミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): サブクラスによるタイプコードの置き換え'</programlisting>
</section>
<section xml:id="_サブクラスによるタイプコードの置き換え_3">
<title>サブクラスによるタイプコードの置き換え 3</title>
<simpara>続いて、 <emphasis role="strong">メソッドオブジェクト</emphasis> <literal>FibonacciGeneralTerm</literal> クラスを抽出します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
end

class FibonacciRecursive
  def exec(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= exec(number - 1, memo) + exec(number - 2, memo)
  end
end

class FibonacciLoop
  def exec(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |_i|
      a = b
      b = c
      c = a + b
    end
    c
  end
end

class FibonacciGeneralTerm
  def exec(number)
    a = ((1 + Math.sqrt(5)) / 2)**number
    b = ((1 - Math.sqrt(5)) / 2)**number
    ((a - b) / Math.sqrt(5)).round
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci
    @recursive = FibonacciRecursive.new
    @loop = FibonacciLoop.new
    @general_term = FibonacciGeneralTerm.new
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @recursive.exec(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @recursive.exec(40)
  end

  def test_large_number_loop
    assert_equal 102_334_155, @loop.exec(40)
  end

  def test_large_number_general_term
    assert_equal 102_334_155, @general_term.exec(40)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rbStarted with run options --seed 65058

  4/4: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01576s
4 tests, 9 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>コミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): サブクラスによるタイプコードの置き換え'</programlisting>
</section>
<section xml:id="_サブクラスによるタイプコードの置き換え_4">
<title>サブクラスによるタイプコードの置き換え 4</title>
<simpara>最後に、 <literal>Fibonacci</literal> クラスに <emphasis role="strong">Strategyパターン</emphasis> を適用して各アルゴリズムの実行を <emphasis role="strong">委譲</emphasis> します。</simpara>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/Strategy_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Strategy パターン</link></simpara>
<screen>abstract class Protocol {
}
Protocol &lt;--r Fibonacci
Protocol &lt;|-- FibonacciRecursive
Protocol &lt;|-- FibonacciLoop
Protocol &lt;|-- FibonacciGeneralTerm

class Fibonacci {
-algorithm
exec()
}
class FibonacciRecursive {
exec()
}
class FibonacciLoop {
exec()
}
class FibonacciGeneralTerm {
exec()
}</screen>
<programlisting language="ruby" linenumbering="unnumbered">...
class Fibonacci
  def initialize(algorithm)
    @algorithm = algorithm
  end

  def exec(number)
    @algorithm.exec(number)
  end
end

class FibonacciRecursive
  def exec(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= exec(number - 1, memo) + exec(number - 2, memo)
  end
end

class FibonacciLoop
  def exec(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |_i|
      a = b
      b = c
      c = a + b
    end
    c
  end
end

class FibonacciGeneralTerm
  def exec(number)
    a = ((1 + Math.sqrt(5)) / 2)**number
    b = ((1 - Math.sqrt(5)) / 2)**number
    ((a - b) / Math.sqrt(5)).round
  end
end

class FibonacciTest &lt; Minitest::Test
  def setup
    @recursive = Fibonacci.new(FibonacciRecursive.new)
    @loop = Fibonacci.new(FibonacciLoop.new)
    @general_term = Fibonacci.new(FibonacciGeneralTerm.new)
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @recursive.exec(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @recursive.exec(40)
  end

  def test_large_number_loop
    assert_equal 102_334_155, @loop.exec(40)
  end

  def test_large_number_general_term
    assert_equal 102_334_155, @general_term.exec(40)
  end
end</programlisting>
<simpara><emphasis role="strong">サブクラスによるタイプコードの置き換え</emphasis> の適用が完了したのでコメントから <literal>(WIP)</literal> を外してコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: サブクラスによるタイプコードの置き換え'</programlisting>
</section>
<section xml:id="_ファイル分割">
<title>ファイル分割</title>
<simpara>続いてテストとアプリケーションを分割します。 <literal>lib</literal> ディレクトリを作成して <literal>fibonacci.rb</literal> ファイルを追加してアプリケーションコード部分をカット＆ペーストします。</simpara>
<simpara><literal>lib/fibonacci.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

# Fibonacci Calcultor
class Fibonacci
  def initialize(algorithm)
    @algorithm = algorithm
  end

  def exec(number)
    @algorithm.exec(number)
  end
end

# Fibonacci Recursive algorithm
class FibonacciRecursive
  def exec(number, memo = {})
    return 0 if number.zero?
    return 1 if number == 1

    memo[number] ||= exec(number - 1, memo) + exec(number - 2, memo)
  end
end

# Fibonacci Loop algorithm
class FibonacciLoop
  def exec(number)
    a = 0
    b = 1
    c = 0
    (0...number).each do |_i|
      a = b
      b = c
      c = a + b
    end
    c
  end
end

# Fibonacci General Term algorithm
class FibonacciGeneralTerm
  def exec(number)
    a = ((1 + Math.sqrt(5)) / 2)**number
    b = ((1 - Math.sqrt(5)) / 2)**number
    ((a - b) / Math.sqrt(5)).round
  end
end</programlisting>
<simpara>続いて、分割した <literal>fibonacci.rb</literal> ファイル内に定義されたクラスを読み込むようにテストクラスを修正します。
ファイルの読み込みには <literal>require</literal> を使います。</simpara>
<simpara><literal>test/fibonacci_test.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fibonacci'

class FibonacciTest &lt; Minitest::Test
  def setup
    @fib = Fibonacci.new(FibonacciRecursive.new)
    @recursive = Fibonacci.new(FibonacciRecursive.new)
    @loop = Fibonacci.new(FibonacciLoop.new)
    @general_term = Fibonacci.new(FibonacciGeneralTerm.new)
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @fib.calc(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @recursive.calc(40)
  end

  def test_large_number_loop
    assert_equal 102_334_155, @loop.calc(40)
  end

  def test_large_number_general_term
    assert_equal 102_334_155, @general_term.calc(40)
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_test.rb
Started with run options --seed 39723

  4/4: [==========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00227s
4 tests, 9 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>分割したファイルからクラスが読み込まれテストが通ることを確認したらコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'feat: ファイル分割'</programlisting>
</section>
<section xml:id="_ベンチマークの実施">
<title>ベンチマークの実施</title>
<simpara><emphasis role="strong">ベンチマーク</emphasis> を実施する準備が出来たので <literal>test</literal> ディレクトリに以下の <literal>fibonacci_benchmark.rb</literal> ファイルを追加します。</simpara>
<simpara><literal>test/fibonacci_benchmark.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'minitest'
require 'minitest/autorun'
require 'minitest/benchmark'
require './lib/fibonacci'

class FibonacciTestBenchmark &lt; Minitest::Benchmark
  def setup
    @recursive = Fibonacci.new(FibonacciRecursive.new)
    @loop = Fibonacci.new(FibonacciLoop.new)
    @general_term = Fibonacci.new(FibonacciGeneralTerm.new)
  end

  def bench_recursive
    assert_performance_constant do |_n|
      1000.times do |i|
        @recursive.exec(i)
      end
    end
  end

  def bench_loop
    assert_performance_constant do |_n|
      1000.times.each do |i|
        @loop.exec(i)
      end
    end
  end

  def bench_general_term
    assert_performance_constant do |_n|
      1000.times.each do |i|
        @general_term.exec(i)
      end
    end
  end
end</programlisting>
<simpara><emphasis role="strong">ベンチマーク</emphasis> を実行します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby test/fibonacci_benchmark.rb
Run options: --seed 1009

# Running:

bench_recursive  0.438420        0.436003        0.437170        0.453267        0.428123
.bench_loop      0.157816        0.160366        0.159504        0.160275        0.162165
.bench_general_term      0.001215        0.001200        0.001255        0.001204      0.001184
.

Finished in 3.074021s, 0.9759 runs/s, 0.9759 assertions/s.

3 runs, 3 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>結果を見たところ、再帰処理アルゴリズムが一番遅く、一般項アルゴリズムが一番早く実行されるようです。</simpara>
<simpara><emphasis role="strong">ベンチマーク</emphasis> を実施してアルゴリズムの性能を比較できたのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'perf: ベンチマークの実施'</programlisting>
</section>
</section>
<section xml:id="_モジュール分割_2">
<title>モジュール分割</title>
<section xml:id="_アプリケーションのリリース">
<title>アプリケーションのリリース</title>
<simpara><emphasis role="strong">動作するきれいなコード</emphasis> をリリースするにあたってクラスモジュールごとにファイル分割して <emphasis role="strong">エントリーポイント</emphasis> からアプリケーションを実行できるようにしたいと思います。</simpara>
<literallayout class="monospaced">/
  |--lib/
      |
       -- fibonacci.rb
  |--test/
      |
       -- fibonacci_test.rb
       -- fibonacci_benchmark.rb</literallayout>
<simpara>まず、 <literal>lib</literal> に <literal>fibonacci</literal> フォルダを追加します。クラスモジュールは <literal>Fibonacci</literal> の <emphasis role="strong">名前空間</emphasis> で管理するようにします。</simpara>
<simpara><literal>lib/fibonacci/command.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

module Fibonacci
  # Fibonacci Calcultor
  class Command
    def initialize(algorithm)
      @algorithm = algorithm
    end

    def exec(number)
      @algorithm.exec(number)
    end
  end
end</programlisting>
<simpara><literal>lib/fibonacci/recursive.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

module Fibonacci
  # Fibonacci Recursive algorithm
  class Recursive
    def exec(number, memo = {})
      return 0 if number.zero?
      return 1 if number == 1

      memo[number] ||= exec(number - 1, memo) + exec(number - 2, memo)
    end
  end
end</programlisting>
<simpara><literal>lib/fibonacci/loop.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

module Fibonacci
  # Fibonacci Loop algorithm
  class Loop
    def exec(number)
      a = 0
      b = 1
      c = 0
      (0...number).each do |_i|
        a = b
        b = c
        c = a + b
      end
      c
    end
  end
end</programlisting>
<simpara><literal>lib/fibonacci/general_term.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

module Fibonacci
  # Fibonacci General Term algorithm
  class GeneralTerm
    def exec(number)
      a = ((1 + Math.sqrt(5)) / 2)**number
      b = ((1 - Math.sqrt(5)) / 2)**number
      ((a - b) / Math.sqrt(5)).round
    end
  end
end</programlisting>
<simpara><literal>fibonacci.rb</literal> は分割したクラスモジュールを読み込むエントリーポイントに変更します。</simpara>
<simpara><literal>lib/fibonacci.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './lib/fibonacci/command'
require './lib/fibonacci/recursive'
require './lib/fibonacci/loop'
require './lib/fibonacci/general_term'</programlisting>
<simpara><emphasis role="strong">名前空間</emphasis> を変更して呼び出すクラスが変わったのでテストとベンチマークを修正します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
require './lib/fibonacci'

class FibonacciTest &lt; Minitest::Test
  def setup
    @recursive = Fibonacci.new(FibonacciRecursive.new)
    @loop = Fibonacci.new(FibonacciLoop.new)
    @general_term = Fibonacci.new(FibonacciGeneralTerm.new)
  end
...</programlisting>
<simpara>まず、テストを修正してテストが通ることを確認します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
require './lib/fibonacci'

class FibonacciTest &lt; Minitest::Test
  def setup
    @recursive = Fibonacci::Command.new(Fibonacci::Recursive.new)
    @loop = Fibonacci::Command.new(Fibonacci::Loop.new)
    @general_term = Fibonacci::Command.new(Fibonacci::GeneralTerm.new)
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
require './lib/fibonacci'

class FibonacciTestBenchmark &lt; Minitest::Benchmark
  def setup
    @recursive = Fibonacci.new(FibonacciRecursive.new)
    @loop = Fibonacci.new(FibonacciLoop.new)
    @general_term = Fibonacci.new(FibonacciGeneralTerm.new)
  end
...</programlisting>
<simpara>続いてベンチマークを修正して実行できることを確認します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
require './lib/fibonacci'

class FibonacciTestBenchmark &lt; Minitest::Benchmark
  def setup
    @recursive = Fibonacci::Command.new(Fibonacci::Recursive.new)
    @loop = Fibonacci::Command.new(Fibonacci::Loop.new)
    @general_term = Fibonacci::Command.new(Fibonacci::GeneralTerm.new)
  end
...</programlisting>
<simpara>仕上げはコマンドラインから実行できるようにします。 ルート直下に <literal>main.rb</literal> を追加して以下のコードを追加します。
ここでは <emphasis role="strong">ベンチマーク</emphasis> で一番良い結果の出た一般項のアルゴリズムを使うことにします。</simpara>
<simpara><literal>main.rb</literal></simpara>
<programlisting language="ruby" linenumbering="unnumbered">require './lib/fibonacci'

number = ARGV[0].to_i
command = Fibonacci::Command.new(Fibonacci::GeneralTerm.new)
puts command.exec(number)</programlisting>
<simpara>コマンドラインから引数に番号を指定して実行します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb 0
0
$ ruby main.rb 1
1
$ ruby main.rb 2
1
$ ruby main.rb 3
2
$ ruby main.rb 4
3</programlisting>
<simpara>アプリケーションの完成したのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'feat: モジュール分割'</programlisting>
</section>
<section xml:id="_アプリケーションの構成">
<title>アプリケーションの構成</title>
<screen>package Fibonacci {
  abstract class Protocol {
  }
  Protocol &lt;--r Command
  Protocol &lt;|-- Recursive
  Protocol &lt;|-- Loop
  Protocol &lt;|-- GeneralTerm
}
main --&gt; Command

package Fibonacci {
  class Command {
  -algorithm
  exec()
  }
  class Recursive {
  exec()
  }
  class Loop {
  exec()
  }
  class GeneralTerm {
  exec()
  }
}</screen>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
       -- fibonacci.rb
     fibonacci/
      |
       -- command.rb
       -- general_term.rb
       -- loop.rb
       -- recursive.rb
  |--test/
      |
       -- fibonacci_test.rb
       -- fibonacci_benchmark.rb</literallayout>
<formalpara>
<title>/main.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered">require './lib/fibonacci'

number = ARGV[0].to_i
command = Fibonacci::Command.new(Fibonacci::GeneralTerm.new)
puts command.exec(number)</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/fibonacci.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './lib/fibonacci/command'
require './lib/fibonacci/recursive'
require './lib/fibonacci/loop'
require './lib/fibonacci/general_term'</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/fibonacci/command.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

module Fibonacci
  # Fibonacci Calcultor
  class Command
    def initialize(algorithm)
      @algorithm = algorithm
    end

    def exec(number)
      @algorithm.exec(number)
    end
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/fibonacci/recursive.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

module Fibonacci
  # Fibonacci Recursive algorithm
  class Recursive
    def exec(number, memo = {})
      return 0 if number.zero?
      return 1 if number == 1

      memo[number] ||= exec(number - 1, memo) + exec(number - 2, memo)
    end
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/fibonacci/loop.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

module Fibonacci
  # Fibonacci Loop algorithm
  class Loop
    def exec(number)
      a = 0
      b = 1
      c = 0
      (0...number).each do |_i|
        a = b
        b = c
        c = a + b
      end
      c
    end
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/fibonacci/general_term.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

module Fibonacci
  # Fibonacci General Term algorithm
  class GeneralTerm
    def exec(number)
      a = ((1 + Math.sqrt(5)) / 2)**number
      b = ((1 - Math.sqrt(5)) / 2)**number
      ((a - b) / Math.sqrt(5)).round
    end
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/fibonacci_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fibonacci'

class FibonacciTest &lt; Minitest::Test
  def setup
    @recursive = Fibonacci::Command.new(Fibonacci::Recursive.new)
    @loop = Fibonacci::Command.new(Fibonacci::Loop.new)
    @general_term = Fibonacci::Command.new(Fibonacci::GeneralTerm.new)
  end

  def test_fibonacci
    cases = [[0, 0], [1, 1], [2, 1], [3, 2], [4, 3], [5, 5]]
    cases.each do |i|
      assert_equal i[1], @recursive.exec(i[0])
    end
  end

  def test_large_number_recursive
    assert_equal 102_334_155, @recursive.exec(40)
  end

  def test_large_number_loop
    assert_equal 102_334_155, @loop.exec(40)
  end

  def test_large_number_general_term
    assert_equal 102_334_155, @general_term.exec(40)
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/fibonacci_benchmark.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'minitest'
require 'minitest/autorun'
require 'minitest/benchmark'
require './lib/fibonacci'

class FibonacciTestBenchmark &lt; Minitest::Benchmark
  def setup
    @recursive = Fibonacci::Command.new(Fibonacci::Recursive.new)
    @loop = Fibonacci::Command.new(Fibonacci::Loop.new)
    @general_term = Fibonacci::Command.new(Fibonacci::GeneralTerm.new)
  end

  def bench_recursive
    assert_performance_constant do |_n|
      1000.times do |i|
        @recursive.exec(i)
      end
    end
  end

  def bench_loop
    assert_performance_constant do |_n|
      1000.times.each do |i|
        @loop.exec(i)
      end
    end
  end

  def bench_general_term
    assert_performance_constant do |_n|
      1000.times.each do |i|
        @general_term.exec(i)
      end
    end
  end
end</programlisting>
</para>
</formalpara>
</section>
</section>
</section>
</section>
<section xml:id="_参照_2">
<title>参照</title>
<section xml:id="_参考サイト">
<title>参考サイト</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://channel9.msdn.com/Events/de-code/2017/DO03?ocid=player">50 分でわかるテスト駆動開発</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://backlog.com/ja/git-tutorial/">サルでもわかるGit入門〜バージョン管理を使いこなそう〜</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.ruby-lang.org/ja/">プログラミング言語 Ruby リファレンスマニュアル</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/jnchito/items/2dc760ee0716ea12bbf0">検索結果を要チェック！Rubyの公式リファレンスは docs.ruby-lang.org です 〜公式な情報源を調べるクセを付けよう〜</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://t-wada.hatenablog.jp/entry/clean-code-that-works">動作するきれいなコード: SeleniumConf Tokyo 2019 基調講演文字起こし+α</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/rubocop-hq/rubocop">RuboCop</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/tomohiii/items/1a17018b5a48b8284a8b">RuboCop is 何？</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/abcb2/items/9905449ab3fcf5d27ace">ruby rake の使い方</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/tbpgr/items/443fe45f0dbe02aa768a">RuboCopのrake taskを使う</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://qiita.com/nrslib/items/73bf176147192c402049">オブジェクト指向のいろは</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_参考図書">
<title>参考図書</title>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=4274217884&linkId=568f25b974af5645e862928a12c354e1&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=k2works0c-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=427405019X&linkId=08e705a5969e20f5129b4d3cefbcdb15&bc1=000000&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=k2works0c-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4274224546&linkId=5f857b58e988073ce92e0adcf1dd3ebb"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=k2works0c-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4873115655&linkId=82416afd8e4042cbfd2dc6d4b80653f1"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=k2works0c-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B078HYWY5X&linkId=920b3fce45a79c528e5be0b2140cce9c"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=k2works0c-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B073GSDBGT&linkId=84e5b25b776d7583da1d5addf2e24fa7"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=k2works0c-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4774198617&linkId=7858ddef815d9a093fcacb3a1208b774"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=k2works0c-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4774193976&linkId=fee0d915272172c2e25393dd52537bdc"></iframe>
</section>
</section>
<bibliography xml:id="_references">
<title>References</title>
<itemizedlist>
<listitem>
<simpara>[<anchor xml:id="tdd" xreflabel="1"/>] テスト駆動開発 Kent Beck (著), 和田 卓人 (翻訳):
オーム社; 新訳版 (2017/10/14)</simpara>
</listitem>
<listitem>
<simpara>[<anchor xml:id="rft" xreflabel="2"/>] 新装版 リファクタリング―既存のコードを安全に改善する― (OBJECT TECHNOLOGY SERIES) Martin Fowler (著), 児玉 公信 (翻訳), 友野 晶夫 (翻訳), 平澤 章  (翻訳), その他:
オーム社; 新装版 (2014/7/26)</simpara>
</listitem>
<listitem>
<simpara>[<anchor xml:id="rft2" xreflabel="3"/>] リファクタリング(第2版): 既存のコードを安全に改善する (OBJECT TECHNOLOGY SERIES) Martin Fowler (著), 児玉 公信 (翻訳), 友野 晶夫 (翻訳), 平澤 章 (翻訳), その他:
オーム社; 第2版 (2019/12/1)</simpara>
</listitem>
<listitem>
<simpara>[<anchor xml:id="rcd" xreflabel="4"/>] リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック (Theory in practice) Dustin Boswell (著), Trevor Foucher (著), 須藤 功平 (解説), 角 征典  (翻訳):
オライリージャパン; 初版八刷版 (2012/6/23)</simpara>
</listitem>
<listitem>
<simpara>[<anchor xml:id="clcd" xreflabel="5"/>] Clean Code　アジャイルソフトウェア達人の技 (アスキードワンゴ) Ｒｏｂｅｒｔ Ｃ．Ｍａｒｔｉｎ (著), 花井 志生  (著)
ドワンゴ (2017/12/28)</simpara>
</listitem>
<listitem>
<simpara>[<anchor xml:id="genba" xreflabel="6"/>] 現場で役立つシステム設計の原則 〜変更を楽で安全にするオブジェクト指向の実践技法 増田 亨  (著)
技術評論社 (2017/7/5)</simpara>
</listitem>
<listitem>
<simpara>[<anchor xml:id="kruby" xreflabel="7"/>] かんたん Ruby (プログラミングの教科書) すがわらまさのり  (著)
技術評論社 (2018/6/21)</simpara>
</listitem>
<listitem>
<simpara>[<anchor xml:id="pruby" xreflabel="8"/>] プロを目指す人のためのRuby入門 言語仕様からテスト駆動開発・デバッグ技法まで (Software Design plusシリーズ) 伊藤 淳一  (著):
技術評論社 (2017/11/25)</simpara>
</listitem>
</itemizedlist>
</bibliography>
</article>