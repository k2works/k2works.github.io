<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="5"?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>オブジェクト指向から始めるテスト駆動開発</title>
<date>2020-05-01</date>
</info>
<section xml:id="_オブジェクト指向から始めるテスト駆動開発">
<title>オブジェクト指向から始めるテスト駆動開発</title>
<section xml:id="_テスト駆動開発">
<title>テスト駆動開発</title>
<simpara>エピソード1ので作成したプログラムに以下の仕様を追加します。</simpara>
<simpara>仕様</simpara>
<literallayout class="monospaced">1 から 100 までの数をプリントするプログラムを書け。
ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、
3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。
タイプごとに出力を切り替えることができる。
タイプ１は通常、タイプ２は数字のみ、タイプ３は FizzBuzz の場合のみをプリントする。</literallayout>
<simpara>早速開発に取り掛かりましょう。エピソード2で開発環境の自動化をしているので以下のコマンドを実行するだけで開発を始めることができます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake</programlisting>
<simpara><literal>guard</literal> が起動するとコンソールが使えなくなるのでもう一つコンソールを開いておきましょう。もしくは <literal>.</literal> を使うことで <literal>guard</literal> 内でコンソールのコマンドを呼び出すことができます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">[1] guard(main)&gt; . ls
coverage  Gemfile.lock  lib      provisioning  README.md  tmp
Gemfile   Guardfile     main.rb  Rakefile      test       Vagrantfile
[2] guard(main)&gt; . pwd
/workspace/tdd_rb
[3] guard(main)&gt; . git status</programlisting>
<section xml:id="_todoリスト作成">
<title>TODOリスト作成</title>
<simpara>まずは追加仕様を <emphasis role="strong">TODOリスト</emphasis> に落とし込んでいきます。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>タイプ1の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_タイプ1の場合">
<title>タイプ1の場合</title>
<simpara><emphasis role="strong">テストファースト</emphasis> <emphasis role="strong">アサートファースト</emphasis> で最初に失敗するテストから始めます。テストを追加しましょう。</simpara>
<simpara>ここでは既存の <literal>FizzBuzz.generate</literal> メソッドにタイプを <emphasis role="strong">引数</emphasis> として追加することで対応できるように変更してみたいと思います。まず、 <literal>fizz_buzz_test.rb</literal> ファイルに以下のテストコードを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  end

  describe 'タイプごとに出力を切り替えることができる' do
    describe 'タイプ1の場合' do
      def test_1を渡したら文字列1を返す
        assert_equal '1', FizzBuzz.generate(1, 1)
      end
    end
  end

  describe '配列や繰り返し処理を理解する' do
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
05:32:51 - INFO - Running: all tests
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 4 / 11 LOC (36.36%) covered.
Started with run options --guard --seed 37049

ERROR["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00005623e6a24260 @name="タイプごとに出力を切り替えることができる::タイプ1の場合"&gt;, 0.0019176720088580623]
 test_1を渡したら文字列1を返す#タイプごとに出力を切り替えることができる::タイプ1の場合 (0.00s)
Minitest::UnexpectedError:         ArgumentError: wrong number of arguments (given 2, expected 1)
            /workspace/tdd_rb/lib/fizz_buzz.rb:6:in `generate'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:74:in `test_1を渡したら文字列1を返す'

  25/25: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00796s
25 tests, 26 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara><literal>ArgumentError: wrong number of arguments (given 2, expected 1)</literal> <emphasis role="strong">引数</emphasis> が違うと指摘されていますね。 <literal>FizzBuzz.generate</literal> メソッドの引数の変更したいのですが既存のテストを壊したくないのでここは <emphasis role="strong">デフォルト引数</emphasis> 使ってみましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>メソッドの引数にはデフォルト値を指定する定義方法があります。これは、メソッドの引数を省略した場合に割り当てられる値です。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
05:32:52 - INFO - Inspecting Ruby code style: test/fizz_buzz_test.rb Guardfile
 2/2 files |====================================== 100 =======================================&gt;| Time: 00:00:00

2 files inspected, no offenses detected
05:32:54 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |====================================== 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
05:37:29 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
lib/fizz_buzz.rb:6:29: W: [Corrected] Lint/UnusedMethodArgument: Unused method argument - type. If it's necessary, use _ or _type as an argument name to indicate that it won't be used.
  def self.generate(number, type = 1)
                            ^^^^
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, 1 offense detected, 1 offense corrected
05:37:31 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected
[1] guard(main)&gt;
05:39:37 - INFO - Run all
05:39:37 - INFO - Running: all tests
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 4 / 11 LOC (36.36%) covered.
Started with run options --guard --seed 8607

  25/25: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00723s
25 tests, 27 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>ちなみにここでは 引数に <literal>type=1</literal> と入力したのですがコードフォーマットによって以下のように自動修正されます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, _type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
...</programlisting>
<simpara><emphasis role="strong">case式</emphasis> を使って <emphasis role="strong">引数</emphasis> を判定できるように変更しましょう。ちなみに <literal>_type</literal> をメソッド内で変数として使うと警告されるので <literal>type</literal> に変更しています。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    case type
    when 1
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 51330


Progress: |=============================================================|

Finished in 0.00828s
25 tests, 27 assertions, 0 failures, 0 errors, 0 skips
04:27:12 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |=================== 100 ====================&gt;| Time: 00:00:00

1 file inspected, no offenses detected
04:27:13 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |=================== 100 ===================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
...</programlisting>
<simpara>テストは無事通りました。ここでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: タイプ1の場合'</programlisting>
<simpara>追加仕様の取っ掛かりができました。既存のテストを流用したいので先程作成したテストを削除して以下のように新しいグループ内に既存テストコードを移動しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...

class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.generate(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.generate(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1)
        end
      end

      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          @result = FizzBuzz.generate_list
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2]
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4]
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14]
        end
      end
    end
  end
...</programlisting>
<simpara>テストコードが壊れていないことを確認したらコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッドのインライン化'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara>タイプ1の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数の代わりに｢Fizz｣と返す_</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"Fizz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは｢Buzz｣と返す_</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"Buzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す_</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">15を渡したら文字列"FizzBuzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>タイプ2の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"15"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"FizzBuzz"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_タイプ2の場合">
<title>タイプ2の場合</title>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>タイプ2の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"15"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"FizzBuzz"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>続いて、タイプ2の場合に取り掛かりましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1, 2)
        end
      end
    end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
FAIL["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00005555ec747100 @name="数を文字列にして返す::タイプ2の場合::その他の場合"&gt;, 0.002283181995153427]
 test_1を渡したら文字列1を返す#数を文字列にして返す::タイプ2の場合::その他の場合 (0.00s)
        Expected: "1"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:75:in `test_1を渡したら文字列1を返す'

  24/24: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00437s
24 tests, 26 assertions, 1 failures, 0 errors, 0 skips
...</programlisting>
<simpara>まだ <emphasis role="strong">引数</emphasis> に2を渡した場合は何もしないので <emphasis role="strong">case式</emphasis> に2を渡した場合の処理を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    case type
    when 1
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 19625


Progress: |=============================================================================|

Finished in 0.00894s
24 tests, 26 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>テストが通ったのでテストケースを追加します。ここはタイプ1の場合をコピーして編集すれば良いでしょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
   end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3, 2)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5, 2)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.generate(15, 2)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1, 2)
        end
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 4 / 13 LOC (30.77%) covered.
Started with run options --guard --seed 898

  27/27: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00900s
27 tests, 29 assertions, 0 failures, 0 errors, 0 skips

06:27:40 - INFO - Inspecting Ruby code style of all files
test/fizz_buzz_test.rb:11:3: C: Metrics/BlockLength: Block has too many lines. [70/62]
  describe '数を文字列にして返す' do ...
  ^^^^^^^^^^^^^^^^^^^^^^^^
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, 1 offense detected
...</programlisting>
<simpara>テストは通りましたが何やら警告が表示されるようになりました。　https://rubocop.readthedocs.io/en/latest/cops_metrics/#metricsblocklength[Metrics/BlockLength: Block has too many lines.^] これは <literal>数を文字列にして返す</literal> テストケースのコードブロックが長いという警告のようですがテストコードはチェックの対象から外しておきたいので <literal>.rubocop_todo.yml</literal> に以下コードを追加してチェック対象から外しておきます。</simpara>
<programlisting language="yml" linenumbering="unnumbered">...
# Offense count: 2
# Configuration parameters: CountComments, ExcludedMethods.
# ExcludedMethods: refine
Metrics/BlockLength:
  Max: 62
  Exclude:
    - 'test/fizz_buzz_test.rb'
...</programlisting>
<simpara>ちなみに <literal>guard(main)&gt;</literal> にカーソルを合わせてエンターキーを押すと自動化タスクが実行されます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">[1] guard(main)&gt;
02:03:15 - INFO - Run all
/home/gitpod/.rvm/rubies/ruby-2.6.3/bin/ruby -w -I"lib" -I"/workspace/.rvm/gems/rake-13.0.1/lib" "/workspace/.rvm/gems/rake-13.0.1/lib/rake/rake_test_loader.rb" "./test/fizz_buzz_test.rb"
/home/gitpod/.rvm/rubies/ruby-2.6.3/bin/ruby -w -I"lib" -I"/workspace/.rvm/gems/rake-13.0.1/lib" "/workspace/.rvm/gems/rake-13.0.1/lib/rake/rake_test_loader.rb" "./test/fizz_buzz_test.rb"
Started with run options --seed 47335


Progress: |==============================================================================|

Finished in 0.00781s
27 tests, 29 assertions, 0 failures, 0 errors, 0 skips
Started with run options --seed 47825


Progress: |==============================================================================|

Finished in 0.00761s
27 tests, 29 assertions, 0 failures, 0 errors, 0 skips
02:03:17 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 13 / 13 LOC (100.0%) covered.
Started with run options --guard --seed 17744

  27/27: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00789s
27 tests, 29 assertions, 0 failures, 0 errors, 0 skips

02:03:17 - INFO - Inspecting Ruby code style of all files
 7/7 files |=========================== 100 ============================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
02:03:19 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png
 0/0 files |=========================== 100 ============================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
[1] guard(main)&gt;</programlisting>
<simpara>警告は消えたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: タイプ2の場合'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>タイプ2の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"3"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"5"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">15を渡したら文字列"15"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"FizzBuzz"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_タイプ3の場合">
<title>タイプ3の場合</title>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ2の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>1を渡したら文字列"1"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>3を渡したら文字列"3"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara>5を渡したら文字列"5"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara>15を渡したら文字列"FizzBuzz"を返す</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>続いて、タイプ3の場合ですがやることは同じなので今回は一気にテストを書いてみましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3, 3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5, 3)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15, 3)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1, 3)
        end
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00005642171ea5a0 @name="数を文字列にして返す::タイプ3の場合::その他の場合"&gt;, 0.003375133004738018]
 test_1を渡したら文字列1を返す#数を文字列にして返す::タイプ3の場合::その他の場合 (0.00s)
        Expected: "1"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:123:in `test_1を渡したら文字列1を返す'

 FAIL["test_5を渡したら文字列5を返す", #&lt;Minitest::Reporters::Suite:0x000056421723af78 @name="数を文字列にして返す::タイプ3の場合::五の倍数の場合"&gt;, 0.003832244998193346]
 test_5を渡したら文字列5を返す#数を文字列にして返す::タイプ3の場合::五の倍数の場合 (0.00s)
        Expected: "5"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:111:in `test_5を渡したら文字列5を返す'

 FAIL["test_3を渡したら文字列3を返す", #&lt;Minitest::Reporters::Suite:0x0000564217297340 @name="数を文字列にして返す::タイプ3の場合::三の倍数の場合"&gt;, 0.0043466729985084385]
 test_3を渡したら文字列3を返す#数を文字列にして返す::タイプ3の場合::三の倍数の場合 (0.00s)
        Expected: "3"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:105:in `test_3を渡したら文字列3を返す'

 FAIL["test_15を渡したら文字列FizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x00005642174dec98 @name="数を文字列にして返す::タイプ3の場合::三と五の倍数の場合"&gt;, 0.006096020006225444]
 test_15を渡したら文字列FizzBuzzを返す#数を文字列にして返す::タイプ3の場合::三と五の倍数の場合 (0.01s)
        Expected: "FizzBuzz"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:117:in `test_15を渡したら文字列FizzBuzzを返す'

  31/31: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00650s
31 tests, 33 assertions, 4 failures, 0 errors, 0 skips
...</programlisting>
<simpara><emphasis role="strong">case式</emphasis> に処理を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    case type
    when 1
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 12137


Progress: |=============================================================================|

Finished in 0.01662s
31 tests, 33 assertions, 0 failures, 0 errors, 0 skips
05:06:44 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png lib/fizz_buzz.rb
lib/fizz_buzz.rb:6:3: C: Metrics/CyclomaticComplexity: Cyclomatic complexity for generate is too high. [10/8]
  def self.generate(number, type = 1) ...
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:6:3: C: Metrics/PerceivedComplexity: Perceived complexity for generate is too high. [8/7]
  def self.generate(number, type = 1) ...
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 1/1 file |=========================== 100 ============================&gt;| Time: 00:00:00

1 file inspected, 2 offenses detected
...</programlisting>
<simpara>テストは通りましたが新しい警告が表示されるようになりました。とりあえずコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: タイプ3の場合'</programlisting>
<simpara>処理の追加により一部重複が発生しました。ここは、 <emphasis role="strong">ステートメントのスライド</emphasis> を適用して重複をなくしておきましょう。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>ステートメントのスライド</simpara>
<simpara>旧：重複した条件記述の断片の統合</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>重複した条件記述の断片の統合</simpara>
<simpara>条件式のすべて分岐に同じコードの断片がある。</simpara>
<simpara>それを式の外側に移動する。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    case type
    when 1
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      is_fizz = number.modulo(3).zero?
      is_buzz = number.modulo(5).zero?

      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    end
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    end
  end
...</programlisting>
<simpara>警告は消えていませんがプログラムは壊れていないことが確認できたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: ステートメントのスライド'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ2の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>タイプ3の場合</simpara>
<itemizedlist>
<listitem>
<simpara>数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">1を渡したら文字列"1"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">3を渡したら文字列"3"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 の倍数のときは数を文字列にして返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">5を渡したら文字列"5"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>3 と 5 両方の倍数の場合には｢FizzBuzz｣と返す</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">15を渡したら文字列"FizzBuzz"を返す</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_それ以外のタイプの場合">
<title>それ以外のタイプの場合</title>
<simpara>追加仕様には対応しましたがタイプ1,2,3以外の値が <emphasis role="strong">引数</emphasis> として渡された場合はどうしましょうか？
現状では <literal>nil</literal> を返しますがこのような例外ケースも考慮する必要があります。</simpara>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ2の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ3の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara>それ以外のタイプの場合</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">例外処理</emphasis> を追加します。まず、例外のテストですが以下の様に書きます。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>例外とは記述したプログラムが想定していない値を受け取ったり、何らかの障害が発生した場合に処理を中断して、例外オブジェクトを生成して呼び出し元のメソッドに処理を戻す機構です。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">    describe 'タイプ3の場合' do
...
    end

    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz
      end

      def test_例外を返す
        e = assert_raises RuntimeError do
          @fizzbuzz.generate(1, 4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_例外を返す", #&lt;Minitest::Reporters::Suite:0x0000558a26888e60 @name="数を文字列にして返す::それ以外のタイプの場合"&gt;, 0.003033002998563461]
 test_例外を返す#数を文字列にして返す::それ以外のタイプの場合 (0.00s)
        RuntimeError expected but nothing was raised.
        /workspace/tdd_rb/test/fizz_buzz_test.rb:134:in `test_例外を返す'

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00609s
32 tests, 34 assertions, 1 failures, 0 errors, 0 skips
...</programlisting>
<simpara><emphasis role="strong">case式</emphasis> に該当しないタイプが指定された場合は <emphasis role="strong">例外を発生させる</emphasis> ようにします。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>例外を明示的に発生させるには「raise」を使います。raiseには発生させたい例外クラスを指定するのですが、何も指定しない場合はRuntimeErrorオブジェクトが生成されます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:04:53 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 16 / 16 LOC (100.0%) covered.
Started with run options --guard --seed 32508

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00600s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>テストが通ったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: それ以外のタイプの場合'</programlisting>
<simpara>TODOリスト</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ1の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ2の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">タイプ3の場合</phrase></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis><phrase role="line-through">それ以外のタイプの場合</phrase></emphasis></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">TODOリスト</emphasis> をすべて完了しました。追加仕様を満たすプログラムは出来ましたがまだ改善の余地がありそうですね。以降ではオブジェクト指向アプローチによるコードのリファクタリングを解説していきたいと思います。</simpara>
</section>
</section>
<section xml:id="_オブジェクト指向">
<title>オブジェクト指向</title>
<section xml:id="_手続き型プログラム">
<title>手続き型プログラム</title>
<simpara><emphasis role="strong">オブジェクト指向</emphasis> の解説の前に以下のコードを御覧ください。いわゆる <emphasis role="strong">手続き型</emphasis> で書かれたコードですが、これも追加仕様を満たしています。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">MAX_NUMBER = 100
type = 1
list = []

MAX_NUMBER.times do |i|
  r = ''
  i += 1
  case type
  when 1
    if i % 3 == 0 &amp;&amp; i % 5 == 0
      r = 'FizzBuzz'
    elsif i % 3 == 0
      r = 'Fizz'
    elsif i % 5 == 0
      r = 'Buzz'
    else
      r = i.to_s
    end
  when 2
    r = i.to_s
  when 3
    if i % 3 == 0 &amp;&amp; i % 5 == 0
      r = 'FizzBuzz'
    else
      r = i.to_s
    end
  else
    r = '該当するタイプは存在しません'
  end

  list.push(r)
end

puts list</programlisting>
<simpara>処理の流れをフローチャートにしたものです、実態はコードに記述されている内容を記号に置き換えて人間が読めるようにしたものです。</simpara>
<screen>start

repeat

  if (タイプ1) then (yes)
    if (カウンタが3と5で割り切れる) then (yes)
      :変数にFizzBuzzをセットする;
    else if (カウンタが3で割り切れる) then (yes)
      :変数にFizzをセットする;
    else if (カウンタが5で割り切れる) then (yes)
      :変数にBuzzをセットする;
    else
      :変数にカウンタをセットする;
    endif
  else if (タイプ2) then (yes)
    :変数にカウンタをセットする;
  else if (タイプ3) then (yes)
    if (カウンタが3と5で割り切れる) then (yes)
      :変数にFizzBuzzをセットする;
    else
      :変数にカウンタを文字列にしてセットする;
    endif
  else (no)
   :変数に該当するタイプは存在しませんをセットする;
  endif

  :カウンタを1増やす;
repeat while (カウンタが100になるまで)

stop</screen>
</section>
<section xml:id="_オブジェクト指向プログラム">
<title>オブジェクト指向プログラム</title>
<simpara>続いて、これまでに作ってきたコードがこちらになります。上記の <emphasis role="strong">手続き型コード</emphasis> との大きな違いとして <literal>class</literal> というキーワードでくくられている部分があります。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスとは、大まかに説明すると何らかの値と処理（メソッド）をひとかたまりにしたものです。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end

  def self.generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E">UML</link> を使って上記のコードの構造をクラス図として表現しました。</simpara>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    {static} generate(number)
    {static} generate_list()
}</screen>
<simpara>更にシーケンス図を使って上記のコードの振る舞いを表現しました。</simpara>
<screen>participant "Main" as A
participant "FizzBuzz" as B

A -&gt; B : generate_list()
activate B

loop 100 times
  B -&gt; B : generate()
end loop

A &lt;&lt;-- B : list
deactivate B</screen>
<simpara><emphasis role="strong">手続き型コード</emphasis> のフローチャートと比べてどう思われましたか？具体的な記述が少なくデータや処理の概要だけを表現しているけどFizzBuzzのルールを知っている人であれば何をやろうとしているかのイメージはつかみやすいのではないでしょうか？だから何？と思われるかもしれませんが現時点では <emphasis role="strong">オブジェクト指向</emphasis> において <emphasis role="strong">抽象化</emphasis> がキーワードだという程度の認識で十分です。</simpara>
<simpara>オブジェクト指向の理解を深める取り掛かりにはこちらの記事を参照してください。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://qiita.com/nrslib/items/73bf176147192c402049">オブジェクト指向のいろは</link></simpara>
</listitem>
</itemizedlist>
<simpara>オブジェクト指向の詳細は控えるとして、ここでは <emphasis role="strong">カプセル化</emphasis> <emphasis role="strong">ポリモフィズム</emphasis> <emphasis role="strong">継承</emphasis> というオブジェクト指向プログラムで原則とされる概念をリファクタリングを通して体験してもらい、オブジェクト指向プログラムの感覚を掴んでもらうことを目的に解説を進めていきたいと思います。</simpara>
</section>
</section>
<section xml:id="_カプセル化">
<title>カプセル化</title>
<section xml:id="_フィールドのカプセル化">
<title>フィールドのカプセル化</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    {static} generate(number)
    {static} generate_list()
}</screen>
<simpara>まず、データとロジックを１つのクラスにまとめていくためのリファクタリングを実施していくとします。<literal>FizzBuzz</literal> クラスにFizzBuzz配列を保持できるようして以下のように取得できるようにしたいと思います。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
          fizzbuzz.generate_list
          @result = fizzbuzz.list
...</programlisting>
<simpara>まず、 <emphasis role="strong">インスタンス変数</emphasis> 追加します。次に <literal>self</literal> キーワードを外して <emphasis role="strong">クラスメソッド</emphasis> から <emphasis role="strong">インスタンスメソッド</emphasis> に変更します。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスメソッドはいくつか定義方法がありますが、どの方法を使ってもクラスメソッドとして定義されれば「クラス名.メソッド名」という形で呼び出せます。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>インスタンスメソッドはコンストラクタと同じようにクラス内でdefキーワードを使ってメソッドを定義するだけで作成できます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def self.generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end

  def self.generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def list
    @list
  end

  def generate(number, type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...

ERROR["test_15を渡したら文字列FizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x00005613555ed120 @name="数を文字列にして返す::タイプ3の場合::三と五の倍数の場合"&gt;, 0.0041351839900016785]
 test_15を渡したら文字列FizzBuzzを返す#数を文字列にして返す::タイプ3の場合::三と五の倍数の場合 (0.00s)
Minitest::UnexpectedError:         NoMethodError: undefined method `generate' for FizzBuzz:Class
            /workspace/tdd_rb/test/fizz_buzz_test.rb:117:in `test_15を渡したら文字列FizzBuzzを返す'
...</programlisting>
<simpara>FizzBuzz配列を <emphasis role="strong">インスタンス変数</emphasis> <literal>@list</literal> に <emphasis role="strong">代入</emphasis> して <emphasis role="strong">インスタンス変数</emphasis> 経由で取得できるように変更しました。変更にあたり <emphasis role="strong">クラスメソッド</emphasis> <literal>FizzBuzz.generate</literal> と <literal>FizzBuzz.generate_list</literal> を <emphasis role="strong">インスタンスメソッド</emphasis> に変更しています。それに伴ってテストが失敗して <literal>NoMethodError: undefined method `generate'</literal> と表示されるようになってしまいました。<emphasis role="strong">インスタンスメソッド</emphasis> が使えるようにするため　<literal>new</literal> メソッドを使ってFizzBuzzクラスの <emphasis role="strong">インスタンス</emphasis> を作りFizzBuzz配列を <emphasis role="strong">インスタンス変数</emphasis> 経由で取得するようにテストコードを変更します。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスとして定義された情報を元に具体的な値を伴ったオブジェクトを作成することをインスタンス化と呼び、生成されたオブジェクトのことをインスタンスと呼びます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new
      end
...
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new
      end
...
    end

    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.new
      end
...
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:17:36 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 5 / 17 LOC (29.41%) covered.
Started with run options --guard --seed 7701

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00616s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>テストが直りました。<emphasis role="strong">クラスメソッド</emphasis> <emphasis role="strong">インスタンスメソッド</emphasis> <emphasis role="strong">インスタンス変数</emphasis> <emphasis role="strong">インスタンス</emphasis> などいろんな単語が出てきて戸惑ってしまったかもしれませんが、ピンとこないうちは <emphasis role="strong">クラス</emphasis> に値や状態を保持させるためには <emphasis role="strong">インスタンス化</emphasis> する必要があってそのためには <literal>new</literal> メソッドを使わないといけないのね程度の理解で十分です。大概のことは手を動かしているうちにピンと来るようになります。</simpara>
<simpara><emphasis role="strong">インスタンス変数</emphasis> に直接アクセスしているのでここは <emphasis role="strong">アクセッサメソッド</emphasis> を使って <emphasis role="strong">フィールドのカプセル化</emphasis> を適用しておきます。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>オブジェクト指向ではクラス内の値をカプセル化することが重要ですが、時には内部で保持しているインスタンス変数を参照や更新できる方が良い場合もあります。複雑な処理ではなく、単にインスタンス変数にアクセスするためのメソッドのことを、アクセッサメソッドと呼びます。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>フィールドのカプセル化</simpara>
<simpara>公開フィールドがある。</simpara>
<simpara>それを非公開にして、そのアクセサを用意する。</simpara>
</blockquote>
<simpara>自動実行の結果、以下のように書き換えられている部分を変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuz、
  MAX_NUMBER = 100
　attr_reader :list
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list
...</programlisting>
<simpara>テストが動作して既存のコードが壊れていないことが確認できたのでここでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: フィールドのカプセル化'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    generate(number)
    generate_list()
}</screen>
<simpara>引き続き、FizzBuzz配列は保持できるようになりましたがタイプごとに出力される配列のパターンは違います。FizzBuzzクラスにタイプを持たる必要があります。ここでは <emphasis role="strong">コンストラクタ</emphasis> を使って <emphasis role="strong">インスタンス化</emphasis> する際に <emphasis role="strong">インスタンス変数</emphasis> に <emphasis role="strong">代入</emphasis> するようにします。Rubyでは <emphasis role="strong">initialize</emphasis> というメソッドを使って初期化処理を実行します。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスをインスタンス化した時に初期化処理を行うシチュエーションはよくあります。このような初期化処理を行うメソッドをコンストラクタと呼び、Rubyではinitializeという特別なメソッドを用意することで実現できます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list

  def initialize(type)
    @type = type
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_3を渡したら文字列3を返す", #&lt;Minitest::Reporters::Suite:0x00005564e21e85b0 @name="数を文字列にして返す::タイプ3の場合::三の倍数の場合"&gt;, 0.004276092993677594]
 test_3を渡したら文字列3を返す#数を文字列にして返す::タイプ3の場合::三の倍数の場合 (0.00s)
Minitest::UnexpectedError:         ArgumentError: wrong number of arguments (given 0, expected 1)
            /workspace/tdd_rb/lib/fizz_buzz.rb:7:in `initialize'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:101:in `new'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:101:in `setup'
...</programlisting>
<simpara>テストが失敗して引数が違うというエラーが表示される用になりました。<literal>new</literal> メソッドの <emphasis role="strong">引数</emphasis> にタイプを渡すようにテストを変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(1)
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(2)
      end
...
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(3)
      end
...
    end

    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(4)
      end
...
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:28:38 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 6 / 19 LOC (31.58%) covered.
Started with run options --guard --seed 46661

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00793s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>テストは直りましたがまだ <emphasis role="strong">インスタンス変数</emphasis> のタイプが使われていないので使うようにプロダクトコードを変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list

  def initialize(type)
    @type = type
  end

  def generate(number, _type = 1)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case @type
...</programlisting>
<simpara><literal>FizzBuzz.gnerate</literal> メソッドの <emphasis role="strong">引数</emphasis> から <literal>type</literal> を削除します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list

  def initialize(type)
    @type = type
  end

  def generate(number)
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_15を渡したら文字列FizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x0000564e16c14200 @name="数を文字列にして返す::タイプ3の場合::三と五の倍数の場合"&gt;, 0.01706391001062002]
 test_15を渡したら文字列FizzBuzzを返す#数を文字列にして返す::タイプ3の場合::三と五の倍数の場合 (0.02s)
Minitest::UnexpectedError:         ArgumentError: wrong number of arguments (given 2, expected 1)
            /workspace/tdd_rb/lib/fizz_buzz.rb:11:in `generate'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:118:in `test_15を渡したら文字列FizzBuzzを返す'
...</programlisting>
<simpara>続いて、<literal>FizzBuzz#generate</literal> メソッドから不要になった <emphasis role="strong">引数</emphasis> <literal>type</literal> を削除したところテストが壊れたのでテストコードを修正します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
  ...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(2)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.generate(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1)
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(3)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1)
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(4)
      end

      def test_例外を返す
        e = assert_raises RuntimeError do
          @fizzbuzz.generate(1)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:34:57 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 15 / 19 LOC (78.95%) covered.
Started with run options --guard --seed 59116

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00700s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara><emphasis role="strong">インスタンス変数</emphasis> の <literal>@type</literal> も <emphasis role="strong">アクセッサメソッド</emphasis> を使って <emphasis role="strong">フィールドのカプセル化</emphasis> を適用しておきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list

  def initialize(type)
    @type = type
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list
  attr_accessor :type

  def initialize(type)
    @type = type
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --guard --seed 56315

  32/32: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01069s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>コミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: フィールドのカプセル化'</programlisting>
</section>
<section xml:id="_setterの削除">
<title>setterの削除</title>
<simpara>FizzBuzz配列を取得する <emphasis role="strong">アクセッサメソッド</emphasis> は現在このように定義されています。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_accessor :list
  attr_accessor :type
...</programlisting>
<simpara>以下のようにテストコードを変更したらどうなるでしょうか？</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          fizzbuzz.list = []
          @result = fizzbuzz.list
        end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_配列の2番目は文字列のFizzを返す", #&lt;Minitest::Reporters::Suite:0x0000563c29a8a8c0 @name="数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.005137628992088139]
 test_配列の2番目は文字列のFizzを返す#数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
        Expected: "Fizz"
          Actual: nil
        /workspace/tdd_rb/test/fizz_buzz_test.rb:58:in `test_配列の2番目は文字列のFizzを返す'
...</programlisting>
<simpara>FizzBuzz配列が初期化されてしまいました。<emphasis role="strong">アクセッサメソッド</emphasis> に参照のための <emphasis role="strong">getter</emphasis> と 更新するための <emphasis role="strong">setter</emphasis> が許可されているため　<emphasis role="strong">カプセル化</emphasis> が破られてしまいました。ここは <emphasis role="strong">setterの削除</emphasis> を適用して外部からの更新を出来ないようにしておきましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>getterを定義するには、「attr_reader」を使います。このメソッドにインスタンス変数の「@」を除いた名称をシンボル表現にしたものを列挙します。複数ある場合はカンマで区切って複数の値を指定することができます。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>setterを定義するには、「attr_writer」を使います。このメソッドもattr_readerと同じくインスタンス変数名の「@」を除いた名称をシンボル表現にしたものを列挙します。複数ある場合はカンマで区切って複数の値を指定することができます。</simpara>
</blockquote>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>getter/setterの両方を定義する場合、そのインスタンスは属しているクラス外から自由に参照や更新ができてしまいます。これはカプセル化の観点には反した挙動なので、できる限りattr_readerだけで済ませられないか検討しましょう。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>setterの削除</simpara>
<simpara>setterが用意されているということは、フィールドが変更される可能性があることを意味します。オブジェクトを生成した後でフィールドを変更したくないなら、setterは用意しません（加えて、フィールドを変更不可にします）。そうすることで、フィールドはコンストラクタでのみで設定され、変更させないという意図が明確になって、フィールドが変更される可能性を、たいていは排除できます。</simpara>
</blockquote>
<simpara>Rubyでは以下のようにして <emphasis role="strong">インスタンス変数</emphasis> を読み取り専用にします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_accessor :type
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">ERROR["test_配列の2番目は文字列のFizzを返す", #&lt;Minitest::Reporters::Suite:0x000055b32efd75f0 @name="数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.008614362974185497]
 test_配列の2番目は文字列のFizzを返す#数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
Minitest::UnexpectedError:         NoMethodError: undefined method `list=' for #&lt;FizzBuzz:0x000055b32ee8c678&gt;
        Did you mean?  list
            /workspace/tdd_rb/test/fizz_buzz_test.rb:45:in `setup'</programlisting>
<simpara>更新メソッドは存在しませんというエラーに変わったことが確認できたのでテストを元にもどします。</simpara>
<simpara>同様に <emphasis role="strong">インスタンス変数</emphasis> の <literal>@type</literal> も読み取り専用にします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
04:32:06 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 22 / 22 LOC (100.0%) covered.
Started with run options --guard --seed 20902

  32/32: [===========================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00920s
...</programlisting>
<simpara>テストが壊れていないことを確認したらコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: setterの削除'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}</screen>
</section>
</section>
<section xml:id="_ポリモーフィズム">
<title>ポリモーフィズム</title>
<section xml:id="_ポリモーフィズムによる条件記述の置き換え_1">
<title>ポリモーフィズムによる条件記述の置き換え 1</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}</screen>
<simpara>リファクタリングによりデータとロジックを１つのクラスにまとめて <emphasis role="strong">カプセル化</emphasis> を進めることが出来ました。しかし、以下の警告メッセージが表示されたままです。<emphasis role="strong">ポリモーフィズム</emphasis> を使ったロジックのリファクタリングを実施していきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
07:53:29 - INFO - Inspecting Ruby code style: test/fizz_buzz_test.rb lib/fizz_buzz.rb
lib/fizz_buzz.rb:11:3: C: Metrics/CyclomaticComplexity: Cyclomatic complexity for generate is too high. [10/8]
  def generate(number) ...
  ^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:11:3: C: Metrics/PerceivedComplexity: Perceived complexity for generate is too high. [8/7]
  def generate(number) ...
  ^^^^^^^^^^^^^^^^^^^^
 2/2 files |====================================== 100 =======================================&gt;| Time: 00:00:00

2 files inspected, 2 offenses detected
...</programlisting>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E7%9A%84%E8%A4%87%E9%9B%91%E5%BA%A6">循環的複雑度</link> が高く可読性が低く複雑なコードと警告されているようです。対象となっている　<literal>FizzBuzz#generate</literal> を確認してみましょう。</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://rubocop.readthedocs.io/en/latest/cops_metrics/#metricscyclomaticcomplexity">Metrics/CyclomaticComplexity</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://rubocop.readthedocs.io/en/latest/cops_metrics/#metricsperceivedcomplexity">Metrics/PerceivedComplexity</link></simpara>
</listitem>
</itemizedlist>
<programlisting language="ruby" linenumbering="unnumbered">...
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case @type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end
...</programlisting>
<simpara>コードの不吉な臭いである <emphasis role="strong">スイッチ文</emphasis> に該当するコードのようなのでここはリファクタリングカタログに従って <emphasis role="strong">ポリモーフィズムによる条件記述の置き換え</emphasis> を適用していきましょう。比較的大きなリファクタリングなのでいくつかのステップに分けて進めていきます。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>スイッチ文</simpara>
<simpara>オブジェクト指向プログラミングのメリットして、スイッチ文が従来にくらべて少なくなるということがあります。スイッチ文は重複したコードを生み出す問題児です。コードのあちらこちらに同じようなスイッチ文が見られることがあります。これでは新たな分岐を追加したときに、すべてのスイッチ文を探して似たような変更をしていかなければなりません。オブジェクト指向ではポリモーフィズムを使い、この問題をエレガントに解決できます。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>重複したスイッチ文</simpara>
<simpara>最近はポリモーフィズムも一般的となり、15年前に比べるとswitch文が単純に赤信号というわけでもなくなりました。また、多くのプログラミング言語が、基本データ型以外をサポートする、より洗練されたswitch文を提供してきています。そこで、今後問題とするのは、重複したswitch文のみとします。switch/case文や、ネストしたif/else文の形で、コードのさまざまな箇所に同じ条件分岐ロジックが書かれていれば、それは「不吉な臭い」です。重複した条件分岐が問題なのは、新たな分岐を追加したら、すべての重複した条件分岐を探して更新指定かなけれけならないからです。ポリモーフィズムは、そうした単調な繰り返しに誘うダークフォースに対抗するための、洗練された武器です。コードベースをよりモダンにしていきましょう。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>ポリモーフィズムによる条件記述の置き換え</simpara>
<simpara>オブジェクトのタイプによって異なる振る舞いを選択する条件記述がある。</simpara>
<simpara>条件記述の各アクション部をサブクラスでオーバーライドするメソッドに移動する。元のメソッドはabstractにする。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
...
end

class FizzBuzzType01; end
class FizzBuzzType02; end
class FizzBuzzType03; end</programlisting>
<simpara>まず、タイプごとのクラスを定義します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end

  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end

...</programlisting>
<simpara>次に、タイプごとのクラスを <emphasis role="strong">インスタンス化</emphasis> する <emphasis role="strong">ファクトリメソッド</emphasis> をFizzBuzzクラスに追加します。この時点では新しいクラスとメソッドの追加だけなのでテストは壊れていないはずです（警告は出ていますが・・・）。ここでコミットしておきますがリファクタリング作業としては <link xl:href="https://ja.wikipedia.org/wiki/%E4%BB%95%E6%8E%9B%E5%93%81">仕掛</link> なのでWIP(Work In Progress)をメッセージに追加してコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): ポリモーフィズムによる条件記述の置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
FizzBuzz -&gt; FizzBuzzType01
FizzBuzz -&gt; FizzBuzzType02
FizzBuzz -&gt; FizzBuzzType03</screen>
</section>
<section xml:id="_ポリモーフィズムによる条件記述の置き換え_2">
<title>ポリモーフィズムによる条件記述の置き換え 2</title>
<simpara>続いて、各タイプクラスに <emphasis role="strong">インスタンスメソッド</emphasis> を実装します。ここでは <emphasis role="strong">case式</emphasis> の各処理をコピー&amp;ペーストしています。カット&amp;ペーストするとプロダクトコードが壊れたままリファクタリングを進めることになるのでここは慎重に進めていきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
...
end

class FizzBuzzType01; end
class FizzBuzzType02; end
class FizzBuzzType03; end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType01
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType02
  def generate(number)
    number.to_s
  end
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType03
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

    number.to_s
  end
end</programlisting>
<simpara>警告は出ますがテストは壊れていないのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): ポリモーフィズムによる条件記述の置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create()
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate()
}
class FizzBuzzType02 {
    generate()
}
class FizzBuzzType03 {
    generate()
}
FizzBuzz -&gt; FizzBuzzType01
FizzBuzz -&gt; FizzBuzzType02
FizzBuzz -&gt; FizzBuzzType03</screen>
</section>
<section xml:id="_ポリモーフィズムによる条件記述の置き換え_3">
<title>ポリモーフィズムによる条件記述の置き換え 3</title>
<simpara>これで準備は整いましたのでテストコードの <literal>setup</literal> メソッドを <emphasis role="strong">ファクトリメソッド</emphasis> の呼び出しに変更します。以下の部分は変更してはいけません。理由はわかりますか？</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(1)
      end
...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(2)
      end
...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(3)
      end
...
    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(4)
      end

      def test_例外を返す
        e = assert_raises RuntimeError do
          @fizzbuzz.generate(1)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:14:14 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 26 / 42 LOC (61.9%) covered.
Started with run options --guard --seed 37585

ERROR["test_例外を返す", #&lt;Minitest::Reporters::Suite:0x000056317940fa28 @name="数を文字列にして返す::それ以外のタイプの場合"&gt;, 0.0037079370085848495]
 test_例外を返す#数を文字列にして返す::それ以外のタイプの場合 (0.00s)
Minitest::UnexpectedError:         RuntimeError: 該当するタイプは存在しません
            /workspace/tdd_rb/lib/fizz_buzz.rb:20:in `create'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:132:in `setup'

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00685s
32 tests, 33 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara>失敗するテストがありますね、該当するコードを確認したところ例外が発生するタイミングが変わってしまったので以下のように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'それ以外のタイプの場合' do
      def setup
        @fizzbuzz = FizzBuzz.create(4)
      end

      def test_例外を返す
        e = assert_raises RuntimeError do
          @fizzbuzz.generate(1)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzz.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:18:08 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 37 / 42 LOC (88.1%) covered.
Started with run options --guard --seed 40171

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00559s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>コミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): ポリモーフィズムによる条件記述の置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzz -&gt; FizzBuzzType01
FizzBuzz -&gt; FizzBuzzType02
FizzBuzz -&gt; FizzBuzzType03</screen>
</section>
<section xml:id="_ポリモーフィズムによる条件記述の置き換え_4">
<title>ポリモーフィズムによる条件記述の置き換え 4</title>
<simpara>タイプごとにFizzBuzzを生成するクラスを用意したのでFizzBuzzクラスから呼び出せるようにしましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end
...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<simpara>まず、<emphasis role="strong">コンストラクタ</emphasis> から <emphasis role="strong">クラスメソッド</emphasis> の <emphasis role="strong">ファクトリメソッド</emphasis> を呼び出して <emphasis role="strong">インスタンス変数</emphasis> の <literal>type</literal> にタイプクラスの <emphasis role="strong">参照</emphasis> を <emphasis role="strong">代入</emphasis> します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = FizzBuzz.create(type)
  end
...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">ERROR["test_配列の14番目は文字列のFizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x000055670a343110 @name="数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.006740843993611634]
 test_配列の14番目は文字列のFizzBuzzを返す#数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
Minitest::UnexpectedError:         RuntimeError: 該当するタイプは存在しません
            /workspace/tdd_rb/lib/fizz_buzz.rb:42:in `generate'
            /workspace/tdd_rb/lib/fizz_buzz.rb:48:in `block in generate_list'
            /workspace/tdd_rb/lib/fizz_buzz.rb:48:in `each'
            /workspace/tdd_rb/lib/fizz_buzz.rb:48:in `map'
            /workspace/tdd_rb/lib/fizz_buzz.rb:48:in `generate_list'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:44:in `setup'</programlisting>
<simpara>テストが失敗して沢山エラーが表示するようになりましたが落ち着いてください。次に <emphasis role="strong">インスタンスメソッド</emphasis> <literal>FizzBuzz#generate_list</literal> 内の <literal>FizzBuzz#generate</literal> メソッド呼び出しを <emphasis role="strong">インスタンス変数</emphasis> <literal>type</literal> が参照するタイプクラスのメソッド <literal>FizzBuzzTypeXX#generate</literal> を呼び出すように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = FizzBuzz.create(type)
  end
...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| @type.generate(n) }
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">Started with run options --seed 13878


Progress: |=====================================================================================================|

Finished in 0.00960s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
05:54:49 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
lib/fizz_buzz.rb:24:3: C: Metrics/CyclomaticComplexity: Cyclomatic complexity for generate is too high. [10/8]
  def generate(number) ...
  ^^^^^^^^^^^^^^^^^^^^
lib/fizz_buzz.rb:24:3: C: Metrics/PerceivedComplexity: Perceived complexity for generate is too high. [8/7]
  def generate(number) ...
  ^^^^^^^^^^^^^^^^^^^^
 1/1 file |======================================= 100 ========================================&gt;| Time: 00:00:00

1 file inspected, 2 offenses detected</programlisting>
<simpara>再びテストが通るようになりました。始めのうちはコードを少し変更しただけでなんで動くようになったの？と思うかもしれませんがこれが <emphasis role="strong">ポリモーフィズム</emphasis> の威力です。この概念を感覚としてつかんで使いこなせるようになることがオブジェクト指向プログラミングの第一歩です。感覚は意識して手を動かしていればそのうちつかめます（多分）。</simpara>
<simpara><emphasis role="strong">ポリモーフィズムによる条件記述の置き換え</emphasis> が完了したのでWIPを外してコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor ポリモーフィズムによる条件記述の置き換え'</programlisting>
</section>
<section xml:id="_state_strategyによるタイプコードの置き換え">
<title>State/Strategyによるタイプコードの置き換え</title>
<simpara>仕上げは　<emphasis role="strong">State/Strategyによるタイプコードの置き換え</emphasis> を適用して、警告メッセージを消すとしましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>State/Strategyによるタイプコードの置き換え</simpara>
<simpara>クラスの振る舞いに影響するタイプコードがあるが、サブクラス化はできない。</simpara>
<simpara>状態オブジェクトでタイプコードを置き換える</simpara>
</blockquote>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzz *- FizzBuzzType01
FizzBuzz *- FizzBuzzType02
FizzBuzz *- FizzBuzzType03</screen>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = FizzBuzz.create(type)
  end

  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end

  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    case @type
    when 1
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
      return 'Fizz' if is_fizz
      return 'Buzz' if is_buzz

      number.to_s
    when 2
      number.to_s
    when 3
      return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

      number.to_s
    else
      raise '該当するタイプは存在しません'
    end
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| @type.generate(n) }
  end
end
...</programlisting>
<simpara>まず、<literal>FizzBuzz#generate</literal> のメソッド呼び出しを <emphasis role="strong">インスタンス変数</emphasis> <literal>type</literal> が参照するタイプクラスのメソッド <literal>FizzBuzzTypeXX#generate</literal> に <emphasis role="strong">委譲</emphasis> するように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| @type.generate(n) }
  end
end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 49543


Progress: |=====================================================================================================|

Finished in 0.00925s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
06:34:27 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 ========================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected
06:34:29 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detecte
...</programlisting>
<simpara>警告が消えました。しかもテストは壊れていないようです。実は <literal>FizzBuzz#generate</literal> メソッドはどこからも使われていないためテストも壊れることが無いのですがこれでは不要なメソッドになってしまうので <emphasis role="strong">移譲の隠蔽</emphasis> を実施して、ロジックを <emphasis role="strong">カプセル化</emphasis> します。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>委譲の隠蔽</simpara>
<simpara>オブジェクト指向について最初に教わる時、カプセル化とはフィールドを隠すことだと習うでしょう。しかし経験を積むにつれて、他にもカプセル化できるものがあることに気づきます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end
...</programlisting>
<simpara>テストもFizzBuzzインスタンス経由で実行するように修正しておきます。これですべての呼び出しが <literal>new</literal> メソッド経由となりテストコードに一貫性を取り戻すことが出来ました。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(1)
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(2)
      end
...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(3)
      end
...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzz.new(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:32:17 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 32 / 32 LOC (100.0%) covered.
Started with run options --guard --seed 63863

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00564s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:32:18 - INFO - Inspecting Ruby code style of all files
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
...</programlisting>
<simpara><emphasis role="strong">ポリモーフィズム</emphasis> の感覚がつかめないうちは <literal>FizzBuzz#generate</literal> のコードが一行になったのに既存のテストも壊れず動いていることが不思議に思うかもしれません。しかしコードとしてはFizzBuzzクラスの <literal>generate</literal> メソッドは任意のタイプクラスの <literal>generate</literal> メソッドを呼び出しているだけで処理の詳細は理解しなくても振る舞いを理解できる <emphasis role="strong">抽象化</emphasis> された読みやすいコードになりました。静的コード解析も可読性が高くシンプルなコードとみなしてくれているようです。
さて、警告メッセージもなくなり、テストも壊れていないのでコミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: State/Strategyによるタイプコードの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzz *- FizzBuzzType01
FizzBuzz *- FizzBuzzType02
FizzBuzz *- FizzBuzzType03</screen>
</section>
</section>
<section xml:id="_継承">
<title>継承</title>
<simpara>分割したタイプクラスのメソッドに重複する処理があるので <emphasis role="strong">継承</emphasis> を使ってリファクタリングしましょう。ここでは <emphasis role="strong">スーパークラスの抽出</emphasis> を適用します。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>スーパークラスの抽出</simpara>
<simpara>似通った特性を持つ２つのクラスがある。</simpara>
<simpara>スーパークラスを作成して、共通の特性を移動する。</simpara>
</blockquote>
<section xml:id="_スーパークラスの抽出">
<title>スーパークラスの抽出</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzz *- FizzBuzzType01
FizzBuzz *- FizzBuzzType02
FizzBuzz *- FizzBuzzType03</screen>
<simpara>まずは、タイプクラスのスーパークラスとなる <literal>FizzBuzzType</literal> クラスを作成して各タイプクラスに継承させます。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスベースのオブジェクト指向言語の多くはクラスの継承機能を有しています。クラスの継承とはあるクラスを元として、新しいクラスを定義することです。この時、継承元となるクラスを親クラスやスーパークラスと呼び、継承したクラスのことを子クラスやサブクラスと呼びます。</simpara>
</blockquote>
<simpara>Rubyの <emphasis role="strong">クラスの継承</emphasis> は以下のように書きます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
...
end

class FizzBuzzType; end

class FizzBuzzType01
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType; end

class FizzBuzzType01 &lt; FizzBuzzType
...
end

class FizzBuzzType02 &lt; FizzBuzzType
...
end

class FizzBuzzType03 &lt; FizzBuzzType
...
end</programlisting>
<simpara>スーパークラス <literal>FizzBuzzType</literal> を定義して各サブクラスに継承させます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">08:42:24 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 33 / 33 LOC (100.0%) covered.
Started with run options --guard --seed 43548

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00860s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:42:25 - INFO - Inspecting Ruby code style of all files
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType {
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
<simpara>次に <literal>is_fizz</literal> <literal>is_buzz</literal> 部分を共通メソッドとしてスーパークラスに定義して各タイプクラスで呼び出すように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType; end

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz
    return 'Fizz' if is_fizz
    return 'Buzz' if is_buzz

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    is_fizz = number.modulo(3).zero?
    is_buzz = number.modulo(5).zero?

    return 'FizzBuzz' if is_fizz &amp;&amp; is_buzz

    number.to_s
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  def is_fizz(number)
    number.modulo(3).zero?
  end

  def is_buzz(number)
    number.modulo(5).zero?
  end
end

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if is_fizz(number) &amp;&amp; is_buzz(number)
    return 'Fizz' if is_fizz(number)
    return 'Buzz' if is_buzz(number)

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if is_fizz(number) &amp;&amp; is_buzz(number)

    number.to_s
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">08:50:16 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 33 / 33 LOC (100.0%) covered.
Started with run options --guard --seed 45685

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01073s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:50:17 - INFO - Inspecting Ruby code style of all files
lib/fizz_buzz.rb:35:7: C: Naming/PredicateName: Rename is_fizz to fizz?.
  def is_fizz(number)
      ^^^^^^^
lib/fizz_buzz.rb:39:7: C: Naming/PredicateName: Rename is_buzz to buzz?.
  def is_buzz(number)
      ^^^^^^^
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, 2 offenses detected</programlisting>
<simpara>テストが壊れていないことが確認できたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: スーパークラスの抽出'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType {
  is_fizz(number)
  is_buzz(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
</section>
<section xml:id="_メソッド名の変更">
<title>メソッド名の変更</title>
<simpara><emphasis role="strong">スーパークラスの抽出</emphasis> を実施したところまた警告メッセージが表示されるようになりました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">08:50:19 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png lib/fizz_buzz.rb
lib/fizz_buzz.rb:35:7: C: Naming/PredicateName: Rename is_fizz to fizz?.
  def is_fizz(number)
      ^^^^^^^
lib/fizz_buzz.rb:39:7: C: Naming/PredicateName: Rename is_buzz to buzz?.
  def is_buzz(number)
      ^^^^^^^
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, 2 offenses detected</programlisting>
<simpara><link xl:href="https://rubocop.readthedocs.io/en/latest/cops_naming/#namingpredicatename">Naming/PredicateName</link> Rubyのネーミングとしてはよろしくないようなので指示に従って <emphasis role="strong">メソッド名の変更</emphasis> を実施しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  def is_fizz(number)
    number.modulo(3).zero?
  end

  def is_buzz(number)
    number.modulo(5).zero?
  end
end

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if is_fizz(number) &amp;&amp; is_buzz(number)
    return 'Fizz' if is_fizz(number)
    return 'Buzz' if is_buzz(number)

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if is_fizz(number) &amp;&amp; is_buzz(number)

    number.to_s
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if fizz?(number) &amp;&amp; buzz?(number)
    return 'Fizz' if fizz?(number)
    return 'Buzz' if buzz?(number)

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if fizz?(number) &amp;&amp; buzz?(number)

    number.to_s
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">Progress: |====================================================================================================|

Finished in 0.01144s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips
08:53:35 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected</programlisting>
<simpara>作業としては難しくないのでミスタイプしないように（まあ、ミスタイプしてもテストが教えてくれますが・・・）変更してコミットしましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッド名の変更'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    {static} create(type)
    generate(number)
    generate_list()
}
class FizzBuzzType {
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
</section>
<section xml:id="_メソッドの移動">
<title>メソッドの移動</title>
<simpara><literal>FizzBuzz</literal> クラスの <emphasis role="strong">ファクトリメソッド</emphasis> ですが <emphasis role="strong">特性の横恋慕</emphasis> の臭いがするので <emphasis role="strong">メソッドの移動</emphasis> を実施します。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>特性の横恋慕</simpara>
<simpara>オブジェクト指向には、処理および処理に必要なデータを１つにまとめてしまうという重要な考え方があります。あるメソッドが、自分のクラスより他のクラスに興味を持つような場合には、古典的な誤りを犯しています。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>メソッドの移動</simpara>
<simpara>あるクラスでメソッドが定義されているが、現在または将来において、そのクラスの特性よりも他のクラスの特性の方が、そのメソッドを使ったり、そのメソッドから使われたりすることが多い。</simpara>
<simpara>同様の本体を持つ新たなメソッドを、それを最も多用するクラスに作成する。元のメソッドは、単純な委譲とするか、またはまるごと取り除く。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list

  def initialize(type)
    @type = FizzBuzz.create(type)
  end

  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end

  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end

class FizzBuzzType
  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end
...</programlisting>
<simpara><emphasis role="strong">クラスメソッド</emphasis> <literal>FizzBuzz.create</literal> をカット&amp;ペーストして <literal>FizzBuzzType.create</literal> に移動します。
<literal>FizzBuzz</literal> の <emphasis role="strong">コンストラクタ</emphasis> で呼び出している <emphasis role="strong">クラスメソッド</emphasis> を <literal>FizzBuzzType.create</literal> に変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list

  def initialize(type)
    @type = FizzBuzzType.create(type)
  end

  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end

class FizzBuzzType
  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end

  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">08:59:27 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 33 / 33 LOC (100.0%) covered.
Started with run options --guard --seed 19583

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00688s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:59:28 - INFO - Inspecting Ruby code style of all files
 7/7 files |====================================== 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected</programlisting>
<simpara>テストが壊れていないことを確認したらコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッドの移動'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
</section>
</section>
<section xml:id="_値オブジェクト">
<title>値オブジェクト</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz -&gt; FizzBuzzType</screen>
<section xml:id="_オブジェクトによるプリミティブの置き換え">
<title>オブジェクトによるプリミティブの置き換え</title>
<simpara><literal>FizzBuzz</literal> クラスを <emphasis role="strong">インスタンス化</emphasis> するには以下のように書きます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">fizz_buzz = FizzBuzz.new(1)</programlisting>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>クラスとして定義された情報を元に具体的な値を伴ったオブジェクトを作成することをインスタンス化と呼び、生成されたオブジェクトのことをインスタンスと呼びます。</simpara>
</blockquote>
<simpara><emphasis role="strong">コンストラクタ</emphasis> の <emphasis role="strong">引数</emphasis> に渡される <literal>1</literal> は何を表しているのでしょうか？もちろんタイプですが初めてこのコードを見る人にはわからないでしょう。このような整数、浮動小数点、文字列などの基本データ（プリミティブ）型の使い方からは <emphasis role="strong">基本データ型への執着</emphasis> の臭いがします。 <emphasis role="strong">オブジェクトによるプリミティブの置き換え</emphasis> を実施してコードの意図を明確にしましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>基本データ型への執着</simpara>
<simpara>オブジェクト指向のメリットとして、基本データ型とそれより大きなクラスとの境界を取り除くということがあります。プログラミング言語の組み込み（built-in）型と区別できないような小さなクラスを自分で定義することが容易です。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>基本データ型への執着</simpara>
<simpara>興味深いことに、多くのプログラマは、対象としているドメインに役立つ、貨幣、座標、範囲などの基本的な型を導入するのを嫌がる傾向があります。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>オブジェクトによるデータ値の置き換え</simpara>
<simpara>追加のデータや振る舞いが必要なデータ項目がある。</simpara>
<simpara>そのデータ項目をオブジェクトに変える。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>オブジェクトによるプリミティブの置き換え</simpara>
<simpara>旧：オブジェクトによるデータ値の置き換え</simpara>
<simpara>旧：クラスによるタイプコードの置き換え</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = FizzBuzzType.create(type)
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end
...</programlisting>
<simpara><emphasis role="strong">コンストラクタ</emphasis> で引き渡されるタイプは整数ではなくタイプクラスの <emphasis role="strong">インスタンス</emphasis> に変更します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...

ERROR["test_1を渡したら文字列1を返す", #&lt;Minitest::Reporters::Suite:0x00005654f32602c0 @name="数を文字列にして返す::タイプ3の場合::その他の場合"&gt;, 0.00241121300496161]
 test_1を渡したら文字列1を返す#数を文字列にして返す::タイプ3の場合::その他の場合 (0.00s)
Minitest::UnexpectedError:         NoMethodError: undefined method `generate' for 3:Integer
            /workspace/tdd_rb/lib/fizz_buzz.rb:12:in `generate'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:125:in `test_1を渡したら文字列1を返す'
...</programlisting>
<simpara>テストが失敗しました。 <emphasis role="strong">コンストラクタ</emphasis> の引数を整数からタイプクラスの <emphasis role="strong">インスタンス</emphasis> に変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(1)
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(1)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(2)
      end
...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(3)
      end
...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzz.new(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end</programlisting>
<simpara>ここで注意するのは <literal>それ以外のタイプの場合</literal> ですが例外を投げなくなります。静的に型付けされた言語なら型チェックエラーになるのですがRubyは動的に型付けされる言語のため <literal>FizzBuzz#generate</literal> メソッド実行までエラーになりません。そこで例外を投げる <literal>FizzBuzzType#create</literal> メソッドに変更しておきます。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
      end
...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end
...
    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType02.new)
      end
...
    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType03.new)
      end
...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzzType.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end</programlisting>
<simpara>それ以外のタイプの場合は <emphasis role="strong">ファクトリメソッド</emphasis> 経由でないと <emphasis role="strong">例外</emphasis> を出さなくなるので注意してください。</simpara>
<programlisting language="bash" linenumbering="unnumbered">09:09:40 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 30 / 33 LOC (90.91%) covered.
Started with run options --guard --seed 17452

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00687s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>初めてコードを見る人でもテストコードを見ればコードの意図が読み取れるようになりましたのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: オブジェクトによるプリミティブの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType</screen>
</section>
<section xml:id="_マジックナンバーの置き換え">
<title>マジックナンバーの置き換え</title>
<simpara>まだプリミティグ型を使っている部分があります。ここは <emphasis role="strong">マジックナンバーの置き換え</emphasis> を実施して可読性を上げておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  def self.create(type)
    case type
    when 1
      FizzBuzzType01.new
    when 2
      FizzBuzzType02.new
    when 3
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
 end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">09:18:51 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 33 / 36 LOC (91.67%) covered.
Started with run options --guard --seed 41124

  32/32: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00909s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストは壊れていないのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: マジックナンバーの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
    generate(number)
}
class FizzBuzzType02 {
    generate(number)
}
class FizzBuzzType03 {
    generate(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType</screen>
</section>
<section xml:id="_オブジェクトによるプリミティブの置き換え_2">
<title>オブジェクトによるプリミティブの置き換え</title>
<simpara>次に <emphasis role="strong">基本データ型への執着</emphasis> の臭いがする箇所として <literal>FizzBuzz#generate</literal> メソッドが返すFizzBuzzの値が文字型である点です。文字列の代わりに <emphasis role="strong">値オブジェクト</emphasis> <literal>FizzBuzzValue</literal> クラスを定義します。</simpara>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>値の種類ごとに専用の型を用意するとコードが安定し、コードの意図が明確になります。このように、値を扱うための専用クラスを作るやり方を値オブジェクト（ValueObject）と呼びます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    @number = number
    @value = value
  end

  def to_s
    "#{@number}:#{@value}"
  end

  def ==(other)
    @number == other.number &amp;&amp; @value == other.value
  end

  alias eql? ==
end</programlisting>
<simpara>各タイプクラスの <literal>generate</literal> メソッドが文字列のプリミティブ型を返しているので <emphasis role="strong">値オブジェクト</emphasis> <literal>FizzBuzzValue</literal> を返すように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if fizz?(number) &amp;&amp; buzz?(number)
    return 'Fizz' if fizz?(number)
    return 'Buzz' if buzz?(number)

    number.to_s
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    number.to_s
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return 'FizzBuzz' if fizz?(number) &amp;&amp; buzz?(number)

    number.to_s
  end
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)
    return FizzBuzzValue.new(number, 'Fizz') if fizz?(number)
    return FizzBuzzValue.new(number, 'Buzz') if buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, number.to_s)
  end
end

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_配列の2番目は文字列のFizzを返す", #&lt;Minitest::Reporters::Suite:0x000055feccc65ab8 @name="数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.012104410998290405]
 test_配列の2番目は文字列のFizzを返す#数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
        --- expected
        +++ actual
        @@ -1 +1 @@
        -"Fizz"
        +#&lt;FizzBuzzValue:0xXXXXXX @number=3, @value="Fizz"&gt;
        /workspace/tdd_rb/test/fizz_buzz_test.rb:57:in `test_配列の2番目は文字列のFizzを返す'
...</programlisting>
<simpara>変更によりテストが失敗しました。エラー内容を見てみると文字列からオブジェクトを返しているためアサーションが失敗しているようです。ここは、<emphasis role="strong">値オブジェクト</emphasis> の <emphasis role="strong">アクセッサメソッド</emphasis> を経由して取得した値をアサーション対象に変更しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.generate(3).value
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.generate(5).value
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15).value
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1).value
        end
      end

      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first.value
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last.value
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2].value
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4].value
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14].value
        end
      end
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType02.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3).value
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5).value
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.generate(15).value
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1).value
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzz.new(FizzBuzzType03.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.generate(3).value
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.generate(5).value
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.generate(15).value
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.generate(1).value
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzzType.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">08:49:28 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 41 / 46 LOC (89.13%) covered.
Started with run options --guard --seed 25972

  32/32: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00619s
32 tests, 35 assertions, 0 failures, 0 errors, 0 skips

08:49:29 - INFO - Inspecting Ruby code style of all files
 7/7 files |======================================= 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
08:49:30 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detected</programlisting>
<simpara>テストコードをそれほど変更することなく <emphasis role="strong">値オブジェクト</emphasis> を返すリファクタリングが出来ました。コミットしておきましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: オブジェクトによるプリミティブの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue</screen>
</section>
<section xml:id="_学習用テスト">
<title>学習用テスト</title>
<simpara><emphasis role="strong">値オブジェクト</emphasis> の理解を深めるために <emphasis role="strong">学習用テスト</emphasis> を追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValue' do
    def setup
      @fizzbuzz = FizzBuzz.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    end

    def test_同じで値である
      value1 = @fizzbuzz.generate(1)
      value2 = @fizzbuzz.generate(1)

      assert value1.eql?(value2)
    end

    def test_to_stringメソッド
      value = @fizzbuzz.generate(3)

      assert_equal '3:Fizz', value.to_s
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'test: 学習用テスト'</programlisting>
</section>
</section>
<section xml:id="_ファーストクラスコレクション">
<title>ファーストクラスコレクション</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue</screen>
<section xml:id="_コレクションのカプセル化">
<title>コレクションのカプセル化</title>
<simpara><emphasis role="strong">値オブジェクト</emphasis> を扱うFizzBuzzリストですが <emphasis role="strong">コレクションのカプセル化</emphasis> を適用して <emphasis role="strong">ファーストクラスコレクション</emphasis> オブジェクトを追加しましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>コレクションのカプセル化</simpara>
<simpara>メソッドがコレクションを返している。</simpara>
<simpara>読み取り専用のビューを返して、追加と削除のメソッドを提供する。</simpara>
</blockquote>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>このように、コレクション型のデータとロジックを特別扱いにして、コレクションを１つだけ持つ専用クラスを作るやり方をコレクションオブジェクトあるいはファーストクラスコレクションと呼びます。</simpara>
</blockquote>
<simpara>まず、 <emphasis role="strong">ファーストクラスコレクション</emphasis> クラスを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzList
  attr_reader :value

  def initialize(list)
    @value = list
  end

  def to_s
    @value.to_s
  end

  def add(value)
    FizzBuzzList.new(@value + value)
  end
end</programlisting>
<simpara>FizzBuzz配列を <emphasis role="strong">ファーストクラスコレクション</emphasis> から取得するように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end
...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = (1..MAX_NUMBER).map { |n| generate(n) }
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
    @list = FizzBuzzList.new([])
  end

...
  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = @list.add((1..MAX_NUMBER).map { |n| @type.generate(n) })
  end
end</programlisting>
<simpara>なんだか紛らわしい書き方になってしましました。配列を作るのに以前の配列を元に新しい配列を作るとか回りくどいことをしないで既存の配列を使い回せばいいじゃんと思うかもしれませんが <emphasis role="strong">変更可能なデータ</emphasis> はバグの原因となる傾向があります。変更可能な <emphasis role="strong">ミュータブル</emphasis> な変数ではなく 永続的に変更されない <emphasis role="strong">イミュータブル</emphasis> な変数を使うように心がけましょう。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>変更可能なデータ</simpara>
<simpara>データの変更はしばし予期せぬ結果結果や、厄介なバグを引き起こします。他で違う値を期待していることに気づかないままに、ソフトウェアのある箇所で値を変更してしまえば、それだけで動かなくなってしまいます。これは値が変わる条件がまれにしかない場合、特に見つけにくいバグとなります。そのため、ソフトウェア開発の一つの潮流である関数型プログラミングは、データは不変であるべきで、更新時は常に元にデータ構造のコピーを返すようにし、元データには手を触れないという思想に基づいています。</simpara>
</blockquote>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>値オブジェクトと同じようにコレクションオブジェクトも、できるだけ「不変」スタイルで設計します。そのほうがプログラムが安定します。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_配列の14番目は文字列のFizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x00005561331b7940 @name="FizzBuzz::数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.011710233025951311]
 test_配列の14番目は文字列のFizzBuzzを返す#FizzBuzz::数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
Minitest::UnexpectedError:         NoMethodError: undefined method `[]' for #&lt;FizzBuzzList:0x0000556133198ba8 @value=[]&gt;
            /workspace/tdd_rb/test/fizz_buzz_test.rb:66:in `test_配列の14番目は文字列のFizzBuzzを返す'
...</programlisting>
<simpara><emphasis role="strong">ファーストクラスコレクション</emphasis> 経由で取得するようになったので <emphasis role="strong">アクセッサメソッド</emphasis> を変更する必要があります。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :list
  attr_reader :type

  def initialize(type)
    @type = type
    @list = FizzBuzzList.new([])
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100
  attr_reader :type

  def list
    @list.value
  end

  def initialize(type)
    @type = type
    @list = FizzBuzzList.new([])
  end
....</programlisting>
<programlisting language="bash" linenumbering="unnumbered">09:12:46 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 53 / 56 LOC (94.64%) covered.
Started with run options --guard --seed 61051

  34/34: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01285s
34 tests, 37 assertions, 0 failures, 0 errors, 0 skips

09:12:47 - INFO - Inspecting Ruby code style of all files
 7/7 files |======================================= 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
09:12:48 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detected</programlisting>
<simpara>テストが直ったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: コレクションのカプセル化'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue
FizzBuzzList *-- FizzBuzzValue
FizzBuzz -&gt; FizzBuzzList</screen>
</section>
<section xml:id="_学習用テスト_2">
<title>学習用テスト</title>
<simpara><emphasis role="strong">ファーストクラスコレクション</emphasis> を理解するため <emphasis role="strong">学習用テスト</emphasis> を追加しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def setup
      @fizzbuzz = FizzBuzz.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    end

    def test_新しいインスタンスが作られる
      list1 = @fizzbuzz.generate_list
      list2 = list1.add(list1.value)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: 学習用テスト'</programlisting>
</section>
</section>
<section xml:id="_オブジェクト指向設計">
<title>オブジェクト指向設計</title>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue
FizzBuzzList *-- FizzBuzzValue
FizzBuzz -&gt; FizzBuzzList</screen>
<simpara><emphasis role="strong">値オブジェクト</emphasis> 及び <emphasis role="strong">ファーストクラスコレクション</emphasis> の適用で <emphasis role="strong">基本データ型への執着</emphasis> の臭いはなくなりました。今度は設計の観点から全体を眺めてみましょう。ここで気になるのが <literal>FizzBuzz</literal> クラスです。このクラスは他のクラスと比べてやることが多いようです。このようなクラスは <emphasis role="strong">単一責任の原則</emphasis> に違反している可能性があります。そこで <emphasis role="strong">デザインパターン</emphasis> の１つである <emphasis role="strong">Commandパターン</emphasis> を使ったリファクタリングである <emphasis role="strong">メソッドオブジェクトによるメソッドの置き換え</emphasis> 適用してみようと思います。</simpara>
<blockquote>
<attribution>
Clean Architecture 達人に学ぶソフトウェアの構造と設計
</attribution>
<simpara>SRP: 単一責任の原則</simpara>
<simpara>かつて単一責任の原則(SRP)は、以下のように語られてきた。</simpara>
<literallayout class="monospaced">モジュールを変更する理由はたったひとつだけであるべきである</literallayout>
<simpara>ソフトウェアシステムに手を加えるのは、ユーザーやステークホルダーを満足させるためだ。この「ユーザーやステークホルダー」こそが、単一責任の原則（SRP）を指す「変更する理由」である。つまり、この原則は以下のように言い換えられる。</simpara>
<literallayout class="monospaced">モジュールはたったひとりのユーザーやステークホルダーに対して責任を負うべきである。</literallayout>
<simpara>残念ながら「たったひとりのユーザーやステークホルダー」という表現は適切ではない。複数のユーザーやステークホルダーがシステムを同じように変更したいと考えることもある。ここでは、変更を望む人たちをひとまとめにしたグループとして扱いたい。このグループのことをアクターと呼ぶことにしよう。
これを踏まえると、最終的な単一責任の原則（SRP）は以下のようになる。</simpara>
<literallayout class="monospaced">モジュールはたったひとつのアクターに対して責任を負うべきである。</literallayout>
<simpara>さて、ここでいう「モジュール」とは何のことだろう？端的に言えば、モジュールとはソースファイルのことである。たいていの場合は、この定義で問題ないだろう。だが、ソースファイル以外のところにコードを格納する言語や開発環境も存在する。そのような場合の「モジュール」は、いくつかの関数やデータをまとめた凝集性のあるものだと考えよう。</simpara>
<simpara>「凝集性のある」という言葉が単一責任の原則（SRP）を匂わせる。凝集性が、ひとつのアクターに対する責務を負うコードをまとめるフォースとなる。</simpara>
</blockquote>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>Commandパターン</simpara>
<simpara>処理の呼び出しが、シンプルなメソッド呼び出しよりも複雑になってきたときはどうすればよいだろうか---処理のためのオブジェクトを作成し、それを起動するようにしよう。</simpara>
</blockquote>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>メソッドオブジェクトによるメソッドの置き換え</simpara>
<simpara>長いメソッドで、「メソッドの抽出」を適用できないようなローカル変数の使い方をしている。</simpara>
<simpara>メソッド自身をオブジェクトとし、すべてのローカル変数をそのオブジェクトのフィールドとする。そうすれば、そのメソッドを同じオブジェクト中のメソッド群に分解できる。</simpara>
</blockquote>
<section xml:id="_メソッドオブジェクトによるメソッドの置き換え">
<title>メソッドオブジェクトによるメソッドの置き換え</title>
<simpara>まず、<emphasis role="strong">値オブジェクト</emphasis> の <literal>FizzBuzzValue</literal> を返す責務だけを持った <emphasis role="strong">メソッドオブジェクト</emphasis> を抽出します。Rubyのような動的言語では必要が無いのですが <emphasis role="strong">Commandパターン</emphasis> の説明のため <emphasis role="strong">インターフェイス</emphasis> にあたるスーパークラスを継承した <emphasis role="strong">メソッドオブジェクト</emphasis> を定義します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzCommand
  def execute; end
end

class FizzBuzzValueCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    @type.generate(number).value
  end
end</programlisting>
<simpara>テストコードを <literal>FizzBuzzValueCommand</literal> を呼び出すように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType01.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end

      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
          fizzbuzz.generate_list
          @result = fizzbuzz.list
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first.value
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last.value
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2].value
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4].value
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14].value
        end
      end
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType02.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType03.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzzType.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
09:56:19 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 60 / 63 LOC (95.24%) covered.
Started with run options --guard --seed 27353

  35/35: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00692s
35 tests, 39 assertions, 0 failures, 0 errors, 0 skips

09:56:20 - INFO - Inspecting Ruby code style of all files
 7/7 files |======================================= 100 =======================================&gt;| Time: 00:00:00

7 files inspected, no offenses detected
09:56:21 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/loading_background.png coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/border.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00
 ...</programlisting>
<simpara><literal>FizzBuzzValueCommand</literal> の抽出ができたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッドオブジェクトによるメソッドの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue
FizzBuzzList *-- FizzBuzzValue
FizzBuzz -&gt; FizzBuzzList
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzValueCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_メソッドオブジェクトによるメソッドの置き換え_2">
<title>メソッドオブジェクトによるメソッドの置き換え</title>
<simpara>続いて、<emphasis role="strong">ファーストクラスコレクション</emphasis> を扱う <literal>FizzBuzzList</literal> を返す責務だけを持った <emphasis role="strong">メソッドオブジェクト</emphasis> を抽出します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzListCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    FizzBuzzList.new((1..number).map { |i| @type.generate(i) }).value
  end
end</programlisting>
<simpara>テストコードを <emphasis role="strong">FizzBuzzListCommand</emphasis> 経由から実行するように変更します</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
        describe '1から100までのFizzBuzzの配列を返す' do
          def setup
            fizzbuzz = FizzBuzz.new(FizzBuzzType01.new)
            fizzbuzz.generate_list
            @result = fizzbuzz.list
          end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzzListCommand.new(FizzBuzzType01.new)
          @result = fizzbuzz.execute(100)
        end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">01:27:54 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 61 / 66 LOC (92.42%) covered.
Started with run options --guard --seed 62253

  35/35: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00652s
35 tests, 39 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストが通ったのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: メソッドオブジェクトによるメソッドの置き換え'</programlisting>
<screen>class FizzBuzz {
    MAX_NUMBER = 100
    list
    type
    generate(number)
    generate_list()
}
class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzz *- FizzBuzzType
FizzBuzzType -&gt; FizzBuzzValue
FizzBuzzList *-- FizzBuzzValue
FizzBuzz -&gt; FizzBuzzList
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzCommand *- FizzBuzzType
FizzBuzzListCommand -&gt; FizzBuzzList</screen>
</section>
<section xml:id="_デッドコードの削除">
<title>デッドコードの削除</title>
<simpara><literal>FizzBuzz</literal> クラスの責務は各 <emphasis role="strong">メソッドオブジェクト</emphasis> が実行するようになったので削除しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzz
  MAX_NUMBER = 100

  def initialize(type)
    @type = type
    @list = FizzBuzzList.new([])
  end

  def list
    @list.value
  end

  def generate(number)
    @type.generate(number)
  end

  def generate_list
    # 1から最大値までのFizzBuzz配列を1発で作る
    @list = @list.add((1..MAX_NUMBER).map { |n| @type.generate(n) })
  end
end

class FizzBuzzType
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzType
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_同じで値である", #&lt;Minitest::Reporters::Suite:0x0000562fd34f7848 @name="FizzBuzzValue"&gt;, 0.008059715997660533]
 test_同じで値である#FizzBuzzValue (0.01s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
            /workspace/tdd_rb/test/fizz_buzz_test.rb:225:in `setup'

ERROR["test_to_stringメソッド", #&lt;Minitest::Reporters::Suite:0x0000562fd37694a0 @name="FizzBuzzValue"&gt;, 0.01728590900893323]
 test_to_stringメソッド#FizzBuzzValue (0.02s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
            /workspace/tdd_rb/test/fizz_buzz_test.rb:225:in `setup'

ERROR["test_新しいインスタンスが作られる", #&lt;Minitest::Reporters::Suite:0x0000562fd39be070 @name="FizzBuzzValueList"&gt;, 0.028008958004647866]
 test_新しいインスタンスが作られる#FizzBuzzValueList (0.03s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::FizzBuzz
            /workspace/tdd_rb/test/fizz_buzz_test.rb:244:in `setup'

========================================|

Finished in 0.03539s
35 tests, 35 assertions, 0 failures, 3 errors, 0 skips
...</programlisting>
<simpara>テストが失敗しました。これは <emphasis role="strong">学習用テスト</emphasis> で <literal>FizzBuzz</literal> クラスを使っている箇所があるからですね。 <emphasis role="strong">メソッドオブジェクト</emphasis> 呼び出しに変更しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">  describe 'FizzBuzzValue' do
    def setup
      @fizzbuzz = FizzBuzz.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    end

    def test_同じで値である
      value1 = @fizzbuzz.generate(1)
      value2 = @fizzbuzz.generate(1)

      assert value1.eql?(value2)
    end

    def test_to_stringメソッド
      value = @fizzbuzz.generate(3)

      assert_equal '3:Fizz', value.to_s
    end
  end

  describe 'FizzBuzzValueList' do
    def setup
      @fizzbuzz = FizzBuzz.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    end

    def test_新しいインスタンスが作られる
      list1 = @fizzbuzz.generate_list
      list2 = list1.add(list1.value)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValue' do
    def test_同じで値である
      value1 = FizzBuzzValue.new(1, '1')
      value2 = FizzBuzzValue.new(1, '1')

      assert value1.eql?(value2)
    end

    def test_to_stringメソッド
      value = FizzBuzzValue.new(3, 'Fizz')

      assert_equal '3:Fizz', value.to_s
    end
  end

  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(100)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
01:35:22 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 50 / 56 LOC (89.29%) covered.
Started with run options --guard --seed 10411

  35/35: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00704s
35 tests, 39 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>不要なコードを残しておくとメンテナンスの時に削除していいのかわからなくなり可読性を落とし原因となります。削除できる時に削除しておきましょう。後で必要になったとしてもバージョン管理システムを使えば問題ありません。ということでコミットします。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>デッドコードの削除</simpara>
<simpara>コードが使用されなくなったら削除すべきです。そのコードが将来必要になるかもしれないなどという心配はしません。必要になったらいつでも、バージョン管理システムから再び掘り起こせるからです。</simpara>
<simpara>（中略）</simpara>
<simpara>デッドコードのコメントアウトは、かつては一般的な習慣でした。それは、バージョン管理システムが広く使用される以前の時代や、使いづらかった時代には有用でした。現在では、とても小さなコードベースでもバージョン管理システムに置けるため、もはや必要のない習慣です。</simpara>
</blockquote>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: デッドコードの削除'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_デザインパターン">
<title>デザインパターン</title>
<simpara><emphasis role="strong">メソッドオブジェクトによるメソッドの置き換え</emphasis> リファクタリングの結果として <emphasis role="strong">Commandパターン</emphasis> という <emphasis role="strong">デザインパターン</emphasis> を適用しました。実はこれまでにも <emphasis role="strong">オブジェクトによるプリミティブの置き換え</emphasis> では <emphasis role="strong">Value Objectパターン</emphasis> を <emphasis role="strong">ポリモーフィズムによる条件記述の置き換え</emphasis> では <emphasis role="strong">Factory Methodパターン</emphasis> をそして、 <emphasis role="strong">委譲の隠蔽</emphasis> の実施による <emphasis role="strong">State/Strategyによるタイプコードの置き換え</emphasis> では <emphasis role="strong">Strategyパターン</emphasis> を適用しています。</simpara>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/Command_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Command パターン</link></simpara>
<screen>interface Command {
  execute()
}
class Invoker {
}
class ConcreateCommand {
  execute()
}
class Receiver {
  Action()
}
class Client {
}
Invoker o-&gt; Command
Command &lt;|-- ConcreateCommand
Receiver &lt;- ConcreateCommand
Client -&gt; Receiver
Client -&gt; ConcreateCommand</screen>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>Value Objectパターン</simpara>
<simpara>広く共有されるものの、同一インスタンスであることはさほど重要でないオブジェクトを設計するにはどうしたらよいだろうか----オブジェクト作成時に状態を設定したら、その後決して変えないようにする。オブジェクトへの操作は必ず新しいオブジェクトを返すようにしよう。</simpara>
</blockquote>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>Factory Methodパターン</simpara>
<simpara>オブジェクト作成に柔軟性をもたせたいときは、どうすればよいだろうか---単にコンストラクタで作るのではなく、メソッドを使ってオブジェクトを作成しよう。</simpara>
</blockquote>
<simpara><link xl:href="https://ja.wikipedia.org/wiki/Strategy_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">Strategy パターン</link></simpara>
<screen>class Context {
  ContextInterface()
}
interface Strategy {
  AlgorithmInterface()
}
class ConcreateStrategyA {
  AlgorithmInterface()
}
class ConcreateStrategyB {
  AlgorithmInterface()
}
Context o- Strategy
Strategy &lt;|-- ConcreateStrategyA
Strategy &lt;|-- ConcreateStrategyB</screen>
<simpara>作成したコードはパターンと完全に一致しているわけではありませんし、Rubyのような動的言語ではもっと簡単な実現方法もありますがここでは先人の考えた設計パターンというものがありオブジェクト指向設計の <link xl:href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%87%E3%82%A3%E3%82%AA%E3%83%A0">イデオム</link> として使えること。そしてテスト駆動開発では一般的な設計アプローチとは異なる形で導かれているということくらいを頭に残しておけば結構です。どのパターンをいつ適用するかはリファクタリングを繰り返しているうちに思いつくようになってきます（多分）。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>ただ、書籍『デザインパターン』（通称Gof本）の大ヒットは、その反面、それらパターンを表現する方法の多様性を奪ってしまった。Gof本には、設計をフェーズとして扱うという暗黙の前提があるように見受けられる。つまり、リファクタリングを設計行為として捉えていない。TDDにおける設計は、デザインパターンを少しだけ違う側面から捉えなければならない。</simpara>
</blockquote>
<simpara>あと、設計の観点から今回 <emphasis role="strong">単一責任の原則</emphasis> に従って <literal>FizzBuzz</literal> クラスを <emphasis role="strong">メソッドオブジェクト</emphasis> に分割して削除しました。</simpara>
<screen>Interface FizzBuzzCommand {
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>もし、新しい処理を追加する必要が発生した場合はどうしましょうか？ <literal>FizzBuzzCommand</literal> インターフェイスを実装した <emphasis role="strong">メソッドオブジェクト</emphasis> を追加しましょう。</simpara>
<screen>Interface FizzBuzzCommand {
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzCommand &lt;|-- FizzBuzzSomethingSpecialCommand
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>もし、新しいタイプが必要になったらどうしましょうか？ <literal>FizzBuzzType</literal> クラスを継承した新しいタイプクラスを追加しましょう。</simpara>
<screen>Interface FizzBuzzCommand {
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeXX
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>このように既存のコードを変更することなく振る舞いを変更できるので <emphasis role="strong">オープン・クローズドの原則</emphasis> を満たした設計といえます。</simpara>
<blockquote>
<attribution>
Clean Architecture 達人に学ぶソフトウェアの構造と設計
</attribution>
<simpara>OCP:オープン・クローズドの原則</simpara>
<simpara>「オープン・クローズドの原則（OCP）」は、1988年にBertrand Maeerが提唱した以下のような原則だ。</simpara>
<literallayout class="monospaced">ソフトウェアの構成要素は拡張に対しては開いていて、修正に対しては閉じていなければならない。
　　　　　　　　　　　　『アジャイルソフトウェア開発の奥義　第2版』（SBクリエイティブ）より引用</literallayout>
<simpara>言い換えれば、ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべきである、ということだ。</simpara>
</blockquote>
</section>
</section>
<section xml:id="_例外">
<title>例外</title>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>ここまでは、正常系をリファクタリングして設計を改善してきました。しかし、アプリケーションは例外系も考慮する必要があります。
続いて、<emphasis role="strong">アサーションの導入</emphasis> を適用した例外系のリファクタリングに取り組むとしましょう。</simpara>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>アサーションの導入</simpara>
<simpara>前提を明示するためのすぐれたテクニックとして、アサーションを記述する方法があります。</simpara>
</blockquote>
<section xml:id="_アサーションの導入">
<title>アサーションの導入</title>
<simpara>まず、 <emphasis role="strong">メソッドオブジェクト</emphasis> の <literal>FizzBuzzValueCommand</literal> にマイナスの値が渡された場合の振る舞いをどうするか考えます。ここでは正の値のみ許可する振る舞いにしたいので以下のテストコードを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzTest &lt; Minitest::Test
...
  describe '例外ケース' do
    def test_値は正の値のみ許可する
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_値は正の値のみ許可する", #&lt;Minitest::Reporters::Suite:0x00007fadf30c45d8 @name="例外ケース"&gt;, 0.006546000000525964]
 test_値は正の値のみ許可する#例外ケース (0.01s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::Assertions
            /Users/k2works/Projects/sandbox/tdd_rb/test/fizz_buzz_test.rb:249:in `test_値は正の値のみ許可する'

  36/36: [=========================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.03159s
36 tests, 39 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara>テストを通すためアサーションモジュールを追加します。Rubyでは <emphasis role="strong">モジュール</emphasis> を使います。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>モジュールはクラスと非常によく似ていますが、以下の二点が異なります。</simpara>
<itemizedlist>
<listitem>
<simpara>モジュールはインスタンス化できない</simpara>
</listitem>
<listitem>
<simpara>本章後半可能なのは include や extend が可能なのはモジュールだけ</simpara>
</listitem>
</itemizedlist>
<simpara>それ以外のクラスメソッドや定数の定義などはクラスと同じように定義することができます。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
module Assertions
  class AssertionFailedError &lt; StandardError; end

  def assert(&amp;condition)
    raise AssertionFailedError, 'Assertion Failed' unless condition.call
  end
end

class FizzBuzzValue
...</programlisting>
<simpara>アサーションモジュールを追加してエラーはなくなりましたがテストは失敗したままです。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
 FAIL["test_値は正の値のみ許可する", #&lt;Minitest::Reporters::Suite:0x00007fdcfc0c2548 @name="例外ケース"&gt;, 0.005800000000817818]
 test_値は正の値のみ許可する#例外ケース (0.01s)
        Assertions::AssertionFailedError expected but nothing was raised.
        /Users/k2works/Projects/sandbox/tdd_rb/test/fizz_buzz_test.rb:249:in `test_値は正の値のみ許可する'

============================================================================================================|

Finished in 0.00621s
36 tests, 40 assertions, 1 failures, 0 errors, 0 skips
...</programlisting>
<simpara>追加したモジュールを <literal>FizzBuzzValue</literal> クラスをに <emphasis role="strong">Mix-in</emphasis> します。そして、<emphasis role="strong">コンストラクタ</emphasis> 実行時に数値は0以上であるアサーションを追加します。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>Rubyでの継承は一種類、単一継承しか実行できませんが、複数のクラスを継承する多重継承の代わりにMix-inというメソッドの共有方法を提供します。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    @number = number
    @value = value
  end
...
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzValue
  include Assertions
  attr_reader :number, :value

  def initialize(number, value)
    assert { number &gt;= 0 }
    @number = number
    @value = value
  end
...
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 37354


Progress: |====================================================================================================|

Finished in 0.01433s
36 tests, 40 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>アサーションが機能するようになりました、コミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: アサーションの導入'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
class Assertions {
  assert(&amp;condition)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType
FizzBuzzValue --|&gt; Assertions</screen>
<simpara>次は、<emphasis role="strong">メソッドオブジェクト</emphasis> の <literal>FizzBuzzListCommand</literal> の実行時に100件以上指定された場合の振る舞いをどうするか考えます。ここでは100までを許可する振る舞いにします。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe '例外ケース' do
    def test_値は正の値のみ許可する
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end
    end

    def test_100より多い数を許可しない
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end
    end
  end
end</programlisting>
<simpara><literal>FizzBuzzList</literal> にアサーションモジュールを <emphasis role="strong">Mix-in</emphasis> します。<emphasis role="strong">コンストラクタ</emphasis> 実行時に配列のサイズは100までというアサーションを追加します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzList
  include Assertions
  attr_reader :value

  def initialize(list)
    assert { list.count &lt;= 100 }
    @value = list
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_新しいインスタンスが作られる", #&lt;Minitest::Reporters::Suite:0x00005558ca6e8e80 @name="FizzBuzzValueList"&gt;, 0.010412617004476488]
 test_新しいインスタンスが作られる#FizzBuzzValueList (0.01s)
Minitest::UnexpectedError:         Assertions::AssertionFailedError: Assertion Failed
            /workspace/tdd_rb/lib/fizz_buzz.rb:58:in `assert'
            /workspace/tdd_rb/lib/fizz_buzz.rb:88:in `initialize'
            /workspace/tdd_rb/lib/fizz_buzz.rb:97:in `new'
            /workspace/tdd_rb/lib/fizz_buzz.rb:97:in `add'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:259:in `test_新しいインスタンスが作られる'

====================================================================================================|

Finished in 0.01238s
36 tests, 38 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara>追加したテストはパスするようになりましたが既存のテストコードでエラーが出るようになりました。該当するテストコードを見たところ100件より多い <emphasis role="strong">学習用テスト</emphasis> で <emphasis role="strong">ファーストクラスコレクション</emphasis> を作ろうとしたため <literal>AssertionFailedError</literal> を発生させたようです。テストコードを修正しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(100)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
...</programlisting>
<simpara>最初は50件作るように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(50)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 100, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
...</programlisting>
<simpara>アサーションエラーはなくなりましたが期待した値と違うと指摘されています。テストコードのアサーションを修正します。</simpara>
<programlisting language="bash" linenumbering="unnumbered"> FAIL["test_新しいインスタンスが作られる", #&lt;Minitest::Reporters::Suite:0x0000556b5137c780 @name="FizzBuzzValueList"&gt;, 0.003735148988198489]
 test_新しいインスタンスが作られる#FizzBuzzValueList (0.00s)
        Expected: 100
          Actual: 50
        /workspace/tdd_rb/test/fizz_buzz_test.rb:261:in `test_新しいインスタンスが作られる'

  36/36: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00837s
36 tests, 39 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(50)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 50, list1.value.count
      assert_equal 200, list2.value.count
    end
  end
...</programlisting>
<simpara>２つ目のアサーションに引っかかってしまいました。こちらも修正します。</simpara>
<programlisting language="bash" linenumbering="unnumbered"> FAIL["test_新しいインスタンスが作られる", #&lt;Minitest::Reporters::Suite:0x0000563a0c4fc2b0 @name="FizzBuzzValueList"&gt;, 0.005684088013367727]
 test_新しいインスタンスが作られる#FizzBuzzValueList (0.01s)
        Expected: 200
          Actual: 100
        /workspace/tdd_rb/test/fizz_buzz_test.rb:262:in `test_新しいインスタンスが作られる'

  36/36: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00809s
36 tests, 40 assertions, 1 failures, 0 errors, 0 skips</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe 'FizzBuzzValueList' do
    def test_新しいインスタンスが作られる
      command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
      array = command.execute(50)
      list1 = FizzBuzzList.new(array)
      list2 = list1.add(array)

      assert_equal 50, list1.value.count
      assert_equal 100, list2.value.count
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
01:58:57 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 61 / 64 LOC (95.31%) covered.
Started with run options --guard --seed 44956

  36/36: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00717s
36 tests, 40 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>仕様変更による反映が出来たのでコミットしましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: アサーションの導入'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
class Assertions {
  assert(&amp;condition)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType
FizzBuzzValue --|&gt; Assertions
FizzBuzzList --|&gt; Assertions</screen>
<simpara><emphasis role="strong">アサーションの導入</emphasis> とは別のアプローチとして <emphasis role="strong">例外</emphasis> を返す方法もあります。 <emphasis role="strong">例外によるエラーコードの置き換え</emphasis> を適用してアサーションモジュールを削除しましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>例外によるエラーコードの置き換え</simpara>
<simpara>エラーを示す特別なコードをメソッドがリターンしている。</simpara>
<simpara>代わりに例外を発生させる。</simpara>
</blockquote>
</section>
<section xml:id="_例外によるエラーコードの置き換え">
<title>例外によるエラーコードの置き換え</title>
<simpara>アサーションモジュールを削除してアサーション部分を <emphasis role="strong">例外</emphasis> に変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
module Assertions
  class AssertionFailedError &lt; StandardError; end

  def assert(&amp;condition)
    raise AssertionFailedError, 'Assertion Failed' unless condition.call
  end
end

class FizzBuzzValue
  include Assertions
  attr_reader :number, :value

  def initialize(number, value)
    assert { number &gt;= 0 }
    @number = number
    @value = value
  end
...
end

class FizzBuzzList
  include Assertions
  attr_reader :value

  def initialize(list)
    assert { list.count &lt;= 100 }
    @value = list
  end
...
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number &lt; 0

    @number = number
    @value = value
  end
...
end

class FizzBuzzList
  attr_reader :value

  def initialize(list)
    raise '上限は100件までです' if list.count &gt; 100

    @value = list
  end
...
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_値は正の値のみ許可する", #&lt;Minitest::Reporters::Suite:0x000055d30f0b8a50 @name="FizzBuzz::数を文字列にして返す::例外ケース"&gt;, 0.004186890990240499]
 test_値は正の値のみ許可する#FizzBuzz::数を文字列にして返す::例外ケース (0.00s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::Assertions
            /workspace/tdd_rb/test/fizz_buzz_test.rb:143:in `test_値は正の値のみ許可する'

ERROR["test_100より多い数を許可しない", #&lt;Minitest::Reporters::Suite:0x000055d30f114210 @name="FizzBuzz::数を文字列にして返す::例外ケース"&gt;, 0.008254560001660138]
 test_100より多い数を許可しない#FizzBuzz::数を文字列にして返す::例外ケース (0.01s)
Minitest::UnexpectedError:         NameError: uninitialized constant FizzBuzzTest::Assertions
            /workspace/tdd_rb/test/fizz_buzz_test.rb:151:in `test_100より多い数を許可しない'

  37/37: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01731s
37 tests, 39 assertions, 0 failures, 2 errors, 0 skips
...</programlisting>
<simpara>アサーションモジュールを削除したのでエラーが発生しています。テストコードを修正しましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe '例外ケース' do
    def test_値は正の値のみ許可する
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end
    end

    def test_100より多い数を許可しない
      assert_raises Assertions::AssertionFailedError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end
    end
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
  describe '例外ケース' do
    def test_値は正の値のみ許可する
      e = assert_raises RuntimeError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end

      assert_equal '正の値のみ有効です', e.message
    end

    def test_100より多い数を許可しない
      e = assert_raises RuntimeError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end

      assert_equal '上限は100件までです', e.message
    end
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
02:13:46 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 55 / 58 LOC (94.83%) covered.
Started with run options --guard --seed 55179

  37/37: [=================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00738s
37 tests, 43 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara>再びテストが通るようになったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor:  例外によるエラーコードの置き換え'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_アルゴリズムの置き換え">
<title>アルゴリズムの置き換え</title>
<programlisting language="bash" linenumbering="unnumbered">02:13:46 - INFO - Inspecting Ruby code style: test/fizz_buzz_test.rb lib/fizz_buzz.rb
lib/fizz_buzz.rb:58:26: C: Style/NumericPredicate: Use number.negative? instead of number &lt; 0.
    raise '正の値のみ有効です' if number &lt; 0
                         ^^^^^^^^^^
 2/2 files |====================================== 100 =======================================&gt;| Time: 00:00:00

2 files inspected, 1 offense detected</programlisting>
<simpara>テストは通りますが警告が表示されるようになりました。 <literal>Style/NumericPredicate: Use number.negative? instead of number &lt; 0.</literal> とのことなので <emphasis role="strong">アルゴリズムの置き換え</emphasis> を適用しておきましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>アルゴリズムの取り替え</simpara>
<simpara>アルゴリズムをよりわかりやすいものに置き換えたい</simpara>
<simpara>メソッドの本体を新たなアルゴリズムで置き換える。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number &lt; 0
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...

class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number.negative?
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">02:18:31 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 =======================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected</programlisting>
<simpara>警告が消えたのでコミットします。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: アルゴリズムの置き換え'</programlisting>
</section>
<section xml:id="_マジックナンバーの置き換え_2">
<title>マジックナンバーの置き換え</title>
<simpara>件数に <emphasis role="strong">リテラル</emphasis> を使っています。ここは <emphasis role="strong">マジックナンバーの置き換え</emphasis> を適用するべきですね。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>シンボリック定数によるマジックナンバーの置き換え</simpara>
<simpara>特別な意味を持った数字のリテラルがある。</simpara>
<simpara>定数を作り、それにふさわしい名前をつけて、そのリテラルを置き換える。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">...
class FizzBuzzList
  attr_reader :value

  def initialize(list)
    raise '上限は100件までです' if list.count &gt; 100

    @value = list
  end
...</programlisting>
<simpara><emphasis role="strong">式展開</emphasis> を使ってメッセージ内容も定数から参照するようにしましょう。</simpara>
<blockquote>
<attribution>
かんたんRuby
</attribution>
<simpara>式展開</simpara>
<simpara>式展開とは、「#{}」の書式で文字列中に何らかの変数や式を埋め込むことが可能な機能です。これは、ダブルクオートを使用した場合のみの機能です。</simpara>
</blockquote>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzList
  MAX_COUNT = 100
  attr_reader :value

  def initialize(list)
    raise "上限は#{MAX_COUNT}件までです" if list.count &gt; MAX_COUNT

    @value = list
  end
...</programlisting>
<simpara>テストは壊れていないようですが <literal>MAX_COUNT</literal> を変更したらテストが失敗するか確認しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzList
  MAX_COUNT = 10
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_配列の14番目は文字列のFizzBuzzを返す", #&lt;Minitest::Reporters::Suite:0x000055942ab5e230 @name="FizzBuzz::数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す"&gt;, 0.008073228993453085]
 test_配列の14番目は文字列のFizzBuzzを返す#FizzBuzz::数を文字列にして返す::タイプ1の場合::1から100までのFizzBuzzの配列を返す (0.01s)
Minitest::UnexpectedError:         RuntimeError: 上限は10件までです
            /workspace/tdd_rb/lib/fizz_buzz.rb:80:in `initialize'
            /workspace/tdd_rb/lib/fizz_buzz.rb:112:in `new'
            /workspace/tdd_rb/lib/fizz_buzz.rb:112:in `execute'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:45:in `setup'
...</programlisting>
<simpara>想定通りのエラーが発生したのでコードを元に戻してコミットしましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzList
  MAX_COUNT = 100
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 5525


Progress: |====================================================================================================|

Finished in 0.01262s
37 tests, 43 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: マジックナンバーの置き換え'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   MAX_COUNT = 100
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_特殊ケースの導入">
<title>特殊ケースの導入</title>
<simpara>最後に <emphasis role="strong">ポリモーフィズム</emphasis> の応用としてタイプクラスが未定義の場合に <emphasis role="strong">例外</emphasis> ではなく未定義のタイプクラスを返す <emphasis role="strong">特殊ケースの導入</emphasis> を適用してみましょう。</simpara>
<blockquote>
<attribution>
新装版 リファクタリング
</attribution>
<simpara>ヌルオブジェクトの導入</simpara>
<simpara>null値のチェックが繰り返し現れる。</simpara>
<simpara>そのnull値をヌルオブジェクトで置き換える。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>特殊ケースの導入</simpara>
<simpara>旧：ヌルオブジェクトの導入</simpara>
<simpara>特殊ケースの処理を要する典型的な値がnullなので、このパターンをヌルオブジェクトパターンと呼ぶことがあります、しかし、通常の特殊ケースとアプローチは同じです。いわばヌルオブジェクトは「特殊ケース」の特殊ケースです。</simpara>
</blockquote>
<simpara>まず、それ以外のタイプの場合の振る舞いを変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'それ以外のタイプの場合' do
      def test_例外を返す
        e = assert_raises RuntimeError do
          FizzBuzzType.create(4)
        end

        assert_equal '該当するタイプは存在しません', e.message
      end
    end
  end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
   describe 'それ以外のタイプの場合' do
      def test_未定義のタイプを返す
        fizzbuzz = FizzBuzzType.create(4)

        assert_equal '未定義', fizzbuzz.to_s
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
ERROR["test_未定義のタイプを返す", #&lt;Minitest::Reporters::Suite:0x00005593e21297d0 @name="数を文字列にして返す::それ以外のタイプの場合"&gt;, 0.0065623498521745205]
 test_未定義のタイプを返す#数を文字列にして返す::それ以外のタイプの場合 (0.01s)
Minitest::UnexpectedError:         RuntimeError: 該当するタイプは存在しません
            /workspace/tdd_rb/lib/fizz_buzz.rb:17:in `create'
            /workspace/tdd_rb/test/fizz_buzz_test.rb:131:in `test_未定義のタイプを返す'

  37/37: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00780s
37 tests, 41 assertions, 0 failures, 1 errors, 0 skips
...</programlisting>
<simpara>現時点では <emphasis role="strong">例外</emphasis> を投げるので未定義タイプ <literal>FizzBuzzTypeNotDefined</literal> を作成して <emphasis role="strong">ファクトリメソッド</emphasis> を変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      raise '該当するタイプは存在しません'
    end
  end

  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end

class FizzBuzzType01 &lt; FizzBuzzType
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      FizzBuzzTypeNotDefined.new
    end
  end
...
class FizzBuzzTypeNotDefined &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, '')
  end

  def to_s
    '未定義'
  end
end

class FizzBuzzValue
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
Started with run options --seed 33939


Progress: |=====================================================================================================|

Finished in 0.01193s
37 tests, 42 assertions, 0 failures, 0 errors, 0 skips
06:46:48 - INFO - Inspecting Ruby code style: lib/fizz_buzz.rb
 1/1 file |======================================= 100 ========================================&gt;| Time: 00:00:00

1 file inspected, no offenses detected
06:46:49 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png
 0/0 files |======================================= 100 =======================================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
...</programlisting>
<simpara>テストが通るようになりました。 <emphasis role="strong">メソッドオブジェクト</emphasis> から実行された場合の振る舞いも明記しておきましょう。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
    describe 'それ以外のタイプの場合' do
      def test_未定義のタイプを返す
        fizzbuzz = FizzBuzzType.create(4)

        assert_equal '未定義', fizzbuzz.to_s
      end

      def test_空の文字列を返す
        type = FizzBuzzType.create(4)
        command = FizzBuzzValueCommand.new(type)

        assert_equal '', command.execute(3)
      end
    end
  end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
06:48:54 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 62 / 65 LOC (95.38%) covered.
Started with run options --guard --seed 18202

  38/38: [==================================================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00747s
38 tests, 43 assertions, 0 failures, 0 errors, 0 skips
...</programlisting>
<simpara><literal>FizzBuzzTypeNotDefined</literal> オブジェクトは <emphasis role="strong">Null Objectパターン</emphasis> を適用したものです。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>Null Objectパターン</simpara>
<simpara>特殊な状況をオブジェクトで表現するにはどうすればよいだろうか---その特殊な状況を表現するオブジェクトを作り、通常のオブジェクトと同じプロトコル（メソッド群）を実装しよう。</simpara>
</blockquote>
<simpara><emphasis role="strong">オープン・クローズドの原則</emphasis> に従って未定義のタイプである <emphasis role="strong">Null Object</emphasis> を安全に追加することができたのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: 特殊ケースの導入'</programlisting>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzTypeNotDefined {
   generate(number)
   to_s()
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   MAX_COUNT = 100
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
</section>
<section xml:id="_モジュール分割">
<title>モジュール分割</title>
<screen>class FizzBuzzType {
    TYPE_01 = 1
    TYPE_02 = 2
    TYPE_03 = 3
    {static} create(type)
    fizz?(number)
    buzz?(number)
}
class FizzBuzzType01 {
   generate(number)
}
class FizzBuzzType02 {
   generate(number)
}
class FizzBuzzType03 {
   generate(number)
}
class FizzBuzzTypeNotDefined {
   generate(number)
   to_s()
}
class FizzBuzzValue {
   number
   value
   to_s()
   eql?(other)
}
class FizzBuzzList {
   MAX_COUNT = 100
   value
   to_s()
   add(value)
}
Interface FizzBuzzCommand {
  execute()
}
class FizzBuzzValueCommand {
  type
  execute(number)
}
class FizzBuzzListCommand {
  type
  execute(number)
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
<simpara>クラスモジュールの抽出によってアプリケーションの構造が <emphasis role="strong">抽象化</emphasis> された結果、視覚的に把握できるようになりました。ここでアプリケーションをを実行してみましょう。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
Traceback (most recent call last):
main.rb:5:in `&lt;main&gt;': uninitialized constant FizzBuzz (NameError)
Did you mean?  FizzBuzzType</programlisting>
<simpara>エラーが出ています、これはアプリケーションの構成が変わったためです。クライアントプログラムをアプリケーションの変更に合わせて修正します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './lib/fizz_buzz.rb'

puts FizzBuzz.generate_list</programlisting>
<programlisting language="bash" linenumbering="unnumbered"># frozen_string_literal: true

require './lib/fizz_buzz.rb'

command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
command.execute(100).each { |i| puts i.value }</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ ruby main.rb
1
2
Fizz
4
Buzz
...
Fizz</programlisting>
<simpara>クライアントプログラムが直ったのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'fix: プリントする'</programlisting>
<section xml:id="_ドメインモデル">
<title>ドメインモデル</title>
<simpara><literal>fizz_buzz.rb</literal> ファイル内のクラスモジュールをファイルとして分割していきます。まずは <emphasis role="strong">ドメインオブジェクト</emphasis> を抽出して <emphasis role="strong">ドメインモデル</emphasis> として整理しましょう。既存のテストを壊さないように１つづつコピー&amp;ペーストしていきます。</simpara>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>関連する業務データと業務ロジックを１つにまとめたこのようなオブジェクトをドメインオブジェクトと呼びます。</simpara>
<simpara>「ドメイン」とは、対象領域とか問題領域という意味です。業務アプリケーションの場合、そのアプリケーションが対象となる業務活動全体がドメインです。業務活動という問題領域（ドメイン）で扱うデータと業務ロジックを、オブジェクトとして表現したものドメインオブジェクトです。ドメインオブジェクトは、業務データと業務ロジックを密接に関係づけます。</simpara>
</blockquote>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>このように業務アプリケーションの対象領域（ドメイン）をオブジェクトのモデルとして整理したものをドメインモデルと呼びます。</simpara>
</blockquote>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
      domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
               -- fizz_buzz_type_not_defined.rb
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<simpara><emphasis role="strong">値オブジェクトクラス</emphasis> と <emphasis role="strong">タイプクラス</emphasis> を <literal>domain</literal> フォルダ以下に配置します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number.negative?

    @number = number
    @value = value
  end

  def to_s
    "#{@number}:#{@value}"
  end

  def ==(other)
    @number == other.number &amp;&amp; @value == other.value
  end

  alias eql? ==
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzList
  MAX_COUNT = 100
  attr_reader :value

  def initialize(list)
    raise "上限は#{MAX_COUNT}件までです" if list.count &gt; MAX_COUNT

    @value = list
  end

  def to_s
    @value.to_s
  end

  def add(value)
    FizzBuzzList.new(@value + value)
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      FizzBuzzTypeNotDefined.new
    end
  end

  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)
    return FizzBuzzValue.new(number, 'Fizz') if fizz?(number)
    return FizzBuzzValue.new(number, 'Buzz') if buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzTypeNotDefined &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, '')
  end

  def to_s
    '未定義'
  end
end</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
07:29:03 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png lib/domain/type/fizz_buzz_type_not_defined.rb lib/domain/type/fizz_buzz_type_03.rb lib/domain/type/fizz_buzz_type_02.rb lib/domain/type/fizz_buzz_type_01.rb lib/domain/type/fizz_buzz_type.rb lib/domain/model/fizz_buzz_list.rb lib/domain/model/fizz_buzz_value.rb
lib/domain/type/fizz_buzz_type_not_defined.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzTypeNotDefined &lt; FizzBuzzType
^^^^^
lib/domain/type/fizz_buzz_type_03.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzType03 &lt; FizzBuzzType
^^^^^
lib/domain/type/fizz_buzz_type_02.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzType02 &lt; FizzBuzzType
^^^^^
lib/domain/type/fizz_buzz_type_01.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzType01 &lt; FizzBuzzType
^^^^^
lib/domain/type/fizz_buzz_type.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzType
^^^^^
lib/domain/model/fizz_buzz_list.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzList
^^^^^
lib/domain/model/fizz_buzz_value.rb:3:1: C: Style/Documentation: Missing top-level class documentation comment.
class FizzBuzzValue
^^^^^
 7/7 files |======================== 100 =========================&gt;| Time: 00:00:00

7 files inspected, 7 offenses detected
...</programlisting>
<simpara>テストは壊れていないようですが警告が出るようになりました。まだ仕掛ですが一旦コミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): モジュール分割'</programlisting>
<screen>package "Domain" {
  package "Model" {
    class FizzBuzzValue {
    }
    class FizzBuzzList {
    }
  }
  package "Type" {
    class FizzBuzzType {
    }
    class FizzBuzzType01 {
    }
    class FizzBuzzType02 {
    }
    class FizzBuzzType03 {
    }
    class FizzBuzzTypeNotDefined {
    }
  }
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue</screen>
</section>
<section xml:id="_アプリケーション">
<title>アプリケーション</title>
<simpara>続いて <emphasis role="strong">アプリケーション層</emphasis> の分割を行います。</simpara>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>データクラスと機能クラスを分ける手続き型の設計では、アプリケーション層のクラスに業務ロジックの詳細を記述します。</simpara>
</blockquote>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
      domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<simpara>ここでは <emphasis role="strong">ドメインオブジェクト</emphasis> を操作する <emphasis role="strong">メソッドオブジェクト</emphasis> を <literal>application</literal> フォルダ以下に配置します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzCommand
  def execute; end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzValueCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    @type.generate(number).value
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzListCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    FizzBuzzList.new((1..number).map { |i| @type.generate(i) }).value
  end
end</programlisting>
<simpara>テストは壊れていないのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): モジュール分割'</programlisting>
<screen>package "Application" {
  class FizzBuzzCommand {
  }
  class FizzBuzzValueCommand {
  }
  class FizzBuzzListCommand {
  }
}
package "Domain" {
  package "Model" {
    class FizzBuzzValue {
    }
    class FizzBuzzList {
    }
  }
  package "Type" {
    class FizzBuzzType {
    }
    class FizzBuzzType01 {
    }
    class FizzBuzzType02 {
    }
    class FizzBuzzType03 {
    }
    class FizzBuzzTypeNotDefined {
    }
  }
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
<section xml:id="_テスト">
<title>テスト</title>
<simpara>アプリケーションのメイン部分は分割できました。続いてテストも分割しましょう。</simpara>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
       -- fizz_buzz_test.rb</literallayout>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
      application/
           |
           -- fizz_buzz_value_command_test.rb
           -- fizz_buzz_list_command_test.rb
      domain/
           |
           model/
                 |
                 -- fizz_buzz_value_test.rb
                 -- fizz_buzz_list_test.rb
      |
       -- learning_test.rb</literallayout>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzValueCommandTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType01.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType02.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType03.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def test_未定義のタイプを返す
        fizzbuzz = FizzBuzzType.create(4)

        assert_equal '未定義', fizzbuzz.to_s
      end

      def test_空の文字列を返す
        type = FizzBuzzType.create(4)
        command = FizzBuzzValueCommand.new(type)

        assert_equal '', command.execute(3)
      end
    end
  end

  describe '例外ケース' do
    def test_値は正の値のみ許可する
      e = assert_raises RuntimeError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end

      assert_equal '正の値のみ有効です', e.message
    end
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzListCommandTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzzListCommand.new(FizzBuzzType01.new)
          @result = fizzbuzz.execute(100)
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first.value
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last.value
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2].value
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4].value
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14].value
        end
      end
    end
  end

  describe '例外ケース' do
    def test_100より多い数を許可しない
      e = assert_raises RuntimeError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end

      assert_equal '上限は100件までです', e.message
    end
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzValueTest &lt; Minitest::Test
  def test_同じで値である
    value1 = FizzBuzzValue.new(1, '1')
    value2 = FizzBuzzValue.new(1, '1')

    assert value1.eql?(value2)
  end

  def test_to_stringメソッド
    value = FizzBuzzValue.new(3, 'Fizz')

    assert_equal '3:Fizz', value.to_s
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzListTest &lt; Minitest::Test
  def test_新しいインスタンスが作られる
    command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    array = command.execute(50)
    list1 = FizzBuzzList.new(array)
    list2 = list1.add(array)

    assert_equal 50, list1.value.count
    assert_equal 100, list2.value.count
  end
end</programlisting>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

class LearningTest &lt; Minitest::Test
  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_selectメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_find_allメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&amp;:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_mapメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_collectメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_findメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&amp;:size)
      assert_equal 'apple', result
    end

    def test_detectメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&amp;:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      result1 = %w[2 4 13 3 1 10].sort
      result2 = %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
      result3 = %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }

      assert_equal %w[1 10 13 2 3 4], result1
      assert_equal %w[1 2 3 4 10 13], result2
      assert_equal %w[13 10 4 3 2 1], result3
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item &lt; 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item &lt; 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_injectメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_reduceメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
end</programlisting>
<simpara>ファイル分割でテストは壊れていないようですが警告がたくさん出てきました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
test/learning_test.rb:70:14: C: Naming/AsciiIdentifiers: Use only ascii symbols in identifiers.
    def test_ブロック内の条件式が真である間までの要素を返す
             ^^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:75:9: C: Naming/MethodName: Use snake_case for method names.
    def test_ブロック内の条件式が真である以降の要素を返す
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:75:14: C: Naming/AsciiIdentifiers: Use only ascii symbols in identifiers.
    def test_ブロック内の条件式が真である以降の要素を返す
             ^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:80:9: C: Naming/MethodName: Use snake_case for method names.
    def test_injectメソッドで畳み込み演算を行う
        ^^^^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:80:20: C: Naming/AsciiIdentifiers: Use only ascii symbols in identifiers.
    def test_injectメソッドで畳み込み演算を行う
                   ^^^^^^^^^^^^^^
test/learning_test.rb:85:9: C: Naming/MethodName: Use snake_case for method names.
    def test_reduceメソッドで畳み込み演算を行う
        ^^^^^^^^^^^^^^^^^^^^^^^^^
test/learning_test.rb:85:20: C: Naming/AsciiIdentifiers: Use only ascii symbols in identifiers.
    def test_reduceメソッドで畳み込み演算を行う
                   ^^^^^^^^^^^^^^
 15/15 files |======================= 100 ========================&gt;| Time: 00:00:00

15 files inspected, 87 offenses detected
...</programlisting>
<simpara>これらはテストコードに関する警告がほとんどなので <literal>.rubocop.yml</literal> を編集してチェック対象から外しておきましょう。</simpara>
<programlisting language="yml" linenumbering="unnumbered">inherit_from: .rubocop_todo.yml

Naming/AsciiIdentifiers:
  Exclude:
    - 'test/**/*'

Naming/MethodName:
  EnforcedStyle: snake_case
  Exclude:
    - 'test/**/*'

Metrics/BlockLength:
  Max: 62
  Exclude:
    - 'test/**/*'

Documentation:
  Enabled: false</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:21:55 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 144 / 215 LOC (66.98%) covered.
Started with run options --guard --seed 55977

  70/70: [=====================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.01518s
70 tests, 79 assertions, 0 failures, 0 errors, 0 skips

08:21:56 - INFO - Inspecting Ruby code style of all files
/workspace/tdd_rb/.rubocop.yml: Warning: no department given for Documentation.
 22/22 files |======================= 100 ========================&gt;| Time: 00:00:00

22 files inspected, no offenses detected
08:21:58 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png
/workspace/tdd_rb/.rubocop.yml: Warning: no department given for Documentation.
 0/0 files |======================== 100 =========================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
...</programlisting>
<simpara>警告は消えました、仕上げに <literal>fizz_buzz_test.rb</literal> ファイルを削除します。</simpara>
<programlisting language="bash" linenumbering="unnumbered">...
08:24:12 - INFO - Running: all tests
Coverage report generated for MiniTest, Unit Tests to /workspace/tdd_rb/coverage. 135 / 201 LOC (67.16%) covered.
Started with run options --guard --seed 40104

  32/32: [=====================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00601s
32 tests, 36 assertions, 0 failures, 0 errors, 0 skips

08:24:13 - INFO - Inspecting Ruby code style of all files
/workspace/tdd_rb/.rubocop.yml: Warning: no department given for Documentation.
 21/21 files |======================= 100 ========================&gt;| Time: 00:00:00

21 files inspected, no offenses detected
08:24:14 - INFO - Inspecting Ruby code style: coverage/assets/0.10.2/colorbox/controls.png coverage/assets/0.10.2/colorbox/border.png coverage/assets/0.10.2/colorbox/loading.gif coverage/assets/0.10.2/colorbox/loading_background.png
/workspace/tdd_rb/.rubocop.yml: Warning: no department given for Documentation.
 0/0 files |======================== 100 =========================&gt;| Time: 00:00:00

0 files inspected, no offenses detected
...</programlisting>
<simpara>テストの分割も完了したのでコミットしておきます。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor(WIP): モジュール分割'</programlisting>
</section>
<section xml:id="_エントリーポイント">
<title>エントリーポイント</title>
<simpara>仕上げはクラスモジュールのエントリーポイント作成とテストヘルパーの追加です。</simpara>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
      application/
           |
           -- fizz_buzz_value_command_test.rb
           -- fizz_buzz_list_command._test.rb
      domain/
           |
           model/
                 |
                 -- fizz_buzz_value_test.rb
                 -- fizz_buzz_list_test.rb
      |
       -- learning_test.rb</literallayout>
<literallayout class="monospaced">/main.rb
  |--lib/
      |
     application/
           |
           -- fizz_buzz_command.rb
           -- fizz_buzz_value_command.rb
           -- fizz_buzz_list_command.rb
     domain/
           |
           model/
               |
               -- fizz_buzz_value.rb
               -- fizz_buzz_list.rb
           type/
               |
               -- fizz_buzz_type.rb
               -- fizz_buzz_type_01.rb
               -- fizz_buzz_type_02.rb
               -- fizz_buzz_type_03.rb
       -- fizz_buzz.rb
  |--test/
      |
      application/
           |
           -- fizz_buzz_value_command_test.rb
           -- fizz_buzz_list_command._test.rb
      domain/
           |
           model/
                 |
                 -- fizz_buzz_value_test.rb
                 -- fizz_buzz_list_test.rb
      |
       -- learning_test.rb
       -- test_helper.rb</literallayout>
<simpara><literal>fizz_buzz.rb</literal> ファイルの内容をクラスモジュール読み込みに変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require './lib/application/fizz_buzz_command.rb'
require './lib/application/fizz_buzz_value_command.rb'
require './lib/application/fizz_buzz_list_command.rb'
require './lib/domain/model/fizz_buzz_value.rb'
require './lib/domain/model/fizz_buzz_list.rb'
require './lib/domain/type/fizz_buzz_type.rb'
require './lib/domain/type/fizz_buzz_type_01.rb'
require './lib/domain/type/fizz_buzz_type_02.rb'
require './lib/domain/type/fizz_buzz_type_03.rb'
require './lib/domain/type/fizz_buzz_type_not_defined.rb'</programlisting>
<programlisting language="bash" linenumbering="unnumbered">...
08:34:32 - INFO - Running: all tests
Coverage report generated for MiniTest to /workspace/tdd_rb/coverage. 119 / 211 LOC (56.4%) covered.
Started with run options --guard --seed 18696

  32/32: [=====================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00561s
32 tests, 36 assertions, 0 failures, 0 errors, 0 skips
....</programlisting>
<simpara>コードカバレッジがうまく機能していないようなので、<literal>test_helper.rb</literal> を追加して共通部分を各テストファイルから読み込むように変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">require 'simplecov'
SimpleCov.start
require 'minitest/reporters'
Minitest::Reporters.use!
require 'minitest/autorun'
require './lib/fizz_buzz'

...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

...</programlisting>
<simpara>テストタスクを実行したところ動作しなくなりました。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ rake test</programlisting>
<simpara>テスト対象をテストディレクトリ内のすべてのテストコードに変更します。</simpara>
<programlisting language="ruby" linenumbering="unnumbered">...
Rake::TestTask.new do |test|
  test.test_files = Dir['./test/fizz_buzz_test.rb']
  test.verbose = true
end
...</programlisting>
<programlisting language="ruby" linenumbering="unnumbered">...
Rake::TestTask.new do |test|
  test.test_files = Dir['./test/**/*_test.rb']
  test.verbose = true
end
...</programlisting>
<programlisting language="bash" linenumbering="unnumbered">$ rake test
Started with run options --seed 46929

  32/32: [=====================================] 100% Time: 00:00:00, Time: 00:00:00

Finished in 0.00800s
32 tests, 36 assertions, 0 failures, 0 errors, 0 skips</programlisting>
<simpara>テストも壊れていないし警告も出ていません。モジュール分割完了です。</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git add .
$ git commit -m 'refactor: モジュール分割'</programlisting>
<screen>package "lib" {
  package "Application" {
    class FizzBuzzCommand {
    }
    class FizzBuzzValueCommand {
    }
    class FizzBuzzListCommand {
    }
  }
  package "Domain" {
    package "Model" {
      class FizzBuzzValue {
      }
      class FizzBuzzList {
      }
    }
    package "Type" {
      class FizzBuzzType {
      }
      class FizzBuzzType01 {
      }
      class FizzBuzzType02 {
      }
      class FizzBuzzType03 {
      }
      class FizzBuzzTypeNotDefined {
      }
    }
  }
}
package "test" {
  class FizzBuzzValueCommandTest {
  }
  class FizzBuzzListCommandTest {
  }
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
</section>
</section>
<section xml:id="_ふりかえり">
<title>ふりかえり</title>
<simpara>今回、 <emphasis role="strong">オブジェクト指向プログラム</emphasis> から <emphasis role="strong">オブジェクト指向設計</emphasis> そして <emphasis role="strong">モジュール分割</emphasis> を <emphasis role="strong">テスト駆動開発</emphasis> を通じて実践しました。各トピックを振り返ってみましょう。</simpara>
<section xml:id="_オブジェクト指向プログラム_2">
<title>オブジェクト指向プログラム</title>
<simpara>エピソード1で作成したプログラムの追加仕様を <emphasis role="strong">テスト駆動開発</emphasis> で実装しました。 次に <emphasis role="strong">手続き型コード</emphasis> との比較から <emphasis role="strong">オブジェクト指向プログラム</emphasis> を構成する <emphasis role="strong">カプセル化</emphasis> <emphasis role="strong">ポリモフィズム</emphasis> <emphasis role="strong">継承</emphasis> という概念をコードベースの <emphasis role="strong">リファクタリング</emphasis> を通じて解説しました。</simpara>
<simpara>具体的には <emphasis role="strong">フィールドのカプセル</emphasis> から <emphasis role="strong">setterの削除</emphasis> を適用することにより <emphasis role="strong">カプセル化</emphasis> を実現しました。続いて、 <emphasis role="strong">ポリモーフィズムによる条件記述の置き換え</emphasis> から <emphasis role="strong">State/Strategyによるタイプコードの置き換え</emphasis> を適用することにより <emphasis role="strong">ポリモーフィズム</emphasis> の効果を体験しました。そして、 <emphasis role="strong">スーパークラスの抽出</emphasis> から <emphasis role="strong">メソッド名の変更</emphasis> <emphasis role="strong">メソッドの移動</emphasis> の適用を通して <emphasis role="strong">継承</emphasis> の使い方を体験しました。さらに <emphasis role="strong">値オブジェクト</emphasis> と <emphasis role="strong">ファーストクラス</emphasis> というオブジェクト指向プログラミングに必要なツールの使い方も学習しました。</simpara>
</section>
<section xml:id="_オブジェクト指向設計_2">
<title>オブジェクト指向設計</title>
<simpara>次に設計の観点から <emphasis role="strong">単一責任の原則</emphasis> に違反している <literal>FizzBuzz</literal> クラスを <emphasis role="strong">デザインパターン</emphasis> の1つである <emphasis role="strong">Commandパターン</emphasis> を使ったリファクタリングである <emphasis role="strong">メソッドオブジェクトによるメソッドの置き換え</emphasis> を適用してクラスの責務を分割しました。オブジェクト指向設計のイデオムである <emphasis role="strong">デザインパターン</emphasis> として <emphasis role="strong">Commandパターン</emphasis> 以外に <emphasis role="strong">Value Objectパターン</emphasis> <emphasis role="strong">Factory Methodパターン</emphasis> <emphasis role="strong">Strategyパターン</emphasis> を <emphasis role="strong">リファクタリング</emphasis> を適用する過程ですでに実現していたことを説明しました。そして、<emphasis role="strong">オープン・クローズドの原則</emphasis> を満たすコードに <emphasis role="strong">リファクタリング</emphasis> されたことで既存のコードを変更することなく振る舞いを変更できるようになりました。</simpara>
<simpara>加えて、正常系の設計を改善した後 <emphasis role="strong">アサーションの導入</emphasis> <emphasis role="strong">例外によるエラーコードの置き換え</emphasis> といった例外系の <emphasis role="strong">リファクタリング</emphasis> を適用しました。最後に <emphasis role="strong">ポリモーフィズム</emphasis> の応用として <emphasis role="strong">特殊ケースの導入</emphasis> の適用による <emphasis role="strong">Null Objectパターン</emphasis> を使った <emphasis role="strong">オープン・クローズドの原則</emphasis> に従った安全なコードの追加方法を解説しました。</simpara>
</section>
<section xml:id="_モジュールの分割">
<title>モジュールの分割</title>
<simpara>仕上げに、<emphasis role="strong">モノリシック</emphasis> なファイルから個別のクラスモジュールへの分割を <emphasis role="strong">ドメインオブジェクト</emphasis> の抽出を通して <emphasis role="strong">ドメインモデル</emphasis> へと整理することにより <emphasis role="strong">モジュール分割</emphasis> を実現しました。最終的にプログラムからアプリケーションへと体裁を整えることが出来ました。以下が最終的なモジュール構造とコードです。</simpara>
<screen>package "lib" {
  package "Application" {
    class FizzBuzzCommand {
    }
    class FizzBuzzValueCommand {
    }
    class FizzBuzzListCommand {
    }
  }
  package "Domain" {
    package "Model" {
      class FizzBuzzValue {
      }
      class FizzBuzzList {
      }
    }
    package "Type" {
      class FizzBuzzType {
      }
      class FizzBuzzType01 {
      }
      class FizzBuzzType02 {
      }
      class FizzBuzzType03 {
      }
      class FizzBuzzTypeNotDefined {
      }
    }
  }
}
package "test" {
  class FizzBuzzValueCommandTest {
  }
  class FizzBuzzListCommandTest {
  }
}
FizzBuzzType &lt;|-- FizzBuzzType01
FizzBuzzType &lt;|-- FizzBuzzType02
FizzBuzzType &lt;|-- FizzBuzzType03
FizzBuzzType &lt;|-- FizzBuzzTypeNotDefined
FizzBuzzType01 --&gt; FizzBuzzValue
FizzBuzzType02 --&gt; FizzBuzzValue
FizzBuzzType03 --&gt; FizzBuzzValue
FizzBuzzTypeNotDefined --&gt; FizzBuzzValue
FizzBuzzList *- FizzBuzzValue
FizzBuzzCommand &lt;|-- FizzBuzzValueCommand
FizzBuzzCommand &lt;|-- FizzBuzzListCommand
FizzBuzzListCommand --&gt; FizzBuzzList
FizzBuzzCommand *- FizzBuzzType</screen>
<itemizedlist>
<listitem>
<simpara>Application</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>/main.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './lib/fizz_buzz.rb'

command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
command.execute(100).each { |i| puts i.value }</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/application/fizz_buzz_command.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzCommand
  def execute; end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/application/fizz_buzz_value_command.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzValueCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    @type.generate(number).value
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/application/fizz_buzz_list_command.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzListCommand &lt; FizzBuzzCommand
  def initialize(type)
    @type = type
  end

  def execute(number)
    FizzBuzzList.new((1..number).map { |i| @type.generate(i) }).value
  end
end</programlisting>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Domain</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>/lib/domain/model/fizz_buzz_value.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzValue
  attr_reader :number, :value

  def initialize(number, value)
    raise '正の値のみ有効です' if number.negative?

    @number = number
    @value = value
  end

  def to_s
    "#{@number}:#{@value}"
  end

  def ==(other)
    @number == other.number &amp;&amp; @value == other.value
  end

  alias eql? ==
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/model/fizz_buzz_list.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzList
  MAX_COUNT = 100
  attr_reader :value

  def initialize(list)
    raise "上限は#{MAX_COUNT}件までです" if list.count &gt; MAX_COUNT

    @value = list
  end

  def to_s
    @value.to_s
  end

  def add(value)
    FizzBuzzList.new(@value + value)
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType
  TYPE_01 = 1
  TYPE_02 = 2
  TYPE_03 = 3

  def self.create(type)
    case type
    when FizzBuzzType::TYPE_01
      FizzBuzzType01.new
    when FizzBuzzType::TYPE_02
      FizzBuzzType02.new
    when FizzBuzzType::TYPE_03
      FizzBuzzType03.new
    else
      FizzBuzzTypeNotDefined.new
    end
  end

  def fizz?(number)
    number.modulo(3).zero?
  end

  def buzz?(number)
    number.modulo(5).zero?
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type_01.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType01 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)
    return FizzBuzzValue.new(number, 'Fizz') if fizz?(number)
    return FizzBuzzValue.new(number, 'Buzz') if buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type_02.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType02 &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type_03.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzType03 &lt; FizzBuzzType
  def generate(number)
    return FizzBuzzValue.new(number, 'FizzBuzz') if fizz?(number) &amp;&amp; buzz?(number)

    FizzBuzzValue.new(number, number.to_s)
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/lib/domain/type/fizz_buzz_type_not_defined.b</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

class FizzBuzzTypeNotDefined &lt; FizzBuzzType
  def generate(number)
    FizzBuzzValue.new(number, '')
  end

  def to_s
    '未定義'
  end
end</programlisting>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Test</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>/test/application/fizz_buzz_value_command_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzValueCommandTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType01.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列Fizzを返す
          assert_equal 'Fizz', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列Buzzを返す
          assert_equal 'Buzz', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ2の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType02.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列15を返す
          assert_equal '15', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'タイプ3の場合' do
      def setup
        @fizzbuzz = FizzBuzzValueCommand.new(FizzBuzzType03.new)
      end

      describe '三の倍数の場合' do
        def test_3を渡したら文字列3を返す
          assert_equal '3', @fizzbuzz.execute(3)
        end
      end

      describe '五の倍数の場合' do
        def test_5を渡したら文字列5を返す
          assert_equal '5', @fizzbuzz.execute(5)
        end
      end

      describe '三と五の倍数の場合' do
        def test_15を渡したら文字列FizzBuzzを返す
          assert_equal 'FizzBuzz', @fizzbuzz.execute(15)
        end
      end

      describe 'その他の場合' do
        def test_1を渡したら文字列1を返す
          assert_equal '1', @fizzbuzz.execute(1)
        end
      end
    end

    describe 'それ以外のタイプの場合' do
      def test_未定義のタイプを返す
        fizzbuzz = FizzBuzzType.create(4)

        assert_equal '未定義', fizzbuzz.to_s
      end

      def test_空の文字列を返す
        type = FizzBuzzType.create(4)
        command = FizzBuzzValueCommand.new(type)

        assert_equal '', command.execute(3)
      end
    end
  end

  describe '例外ケース' do
    def test_値は正の値のみ許可する
      e = assert_raises RuntimeError do
        FizzBuzzValueCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(-1)
      end

      assert_equal '正の値のみ有効です', e.message
    end
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/application/fizz_buzz_list_command_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzListCommandTest &lt; Minitest::Test
  describe '数を文字列にして返す' do
    describe 'タイプ1の場合' do
      describe '1から100までのFizzBuzzの配列を返す' do
        def setup
          fizzbuzz = FizzBuzzListCommand.new(FizzBuzzType01.new)
          @result = fizzbuzz.execute(100)
        end

        def test_配列の初めは文字列の1を返す
          assert_equal '1', @result.first.value
        end

        def test_配列の最後は文字列のBuzzを返す
          assert_equal 'Buzz', @result.last.value
        end

        def test_配列の2番目は文字列のFizzを返す
          assert_equal 'Fizz', @result[2].value
        end

        def test_配列の4番目は文字列のBuzzを返す
          assert_equal 'Buzz', @result[4].value
        end

        def test_配列の14番目は文字列のFizzBuzzを返す
          assert_equal 'FizzBuzz', @result[14].value
        end
      end
    end
  end

  describe '例外ケース' do
    def test_100より多い数を許可しない
      e = assert_raises RuntimeError do
        FizzBuzzListCommand.new(
          FizzBuzzType.create(FizzBuzzType::TYPE_01)
        ).execute(101)
      end

      assert_equal '上限は100件までです', e.message
    end
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/domain/model/fizz_buzz_value_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzValueTest &lt; Minitest::Test
  def test_同じで値である
    value1 = FizzBuzzValue.new(1, '1')
    value2 = FizzBuzzValue.new(1, '1')

    assert value1.eql?(value2)
  end

  def test_to_stringメソッド
    value = FizzBuzzValue.new(3, 'Fizz')

    assert_equal '3:Fizz', value.to_s
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/domain/model/fizz_buzz_list_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class FizzBuzzListTest &lt; Minitest::Test
  def test_新しいインスタンスが作られる
    command = FizzBuzzListCommand.new(FizzBuzzType.create(FizzBuzzType::TYPE_01))
    array = command.execute(50)
    list1 = FizzBuzzList.new(array)
    list2 = list1.add(array)

    assert_equal 50, list1.value.count
    assert_equal 100, list2.value.count
  end
end</programlisting>
</para>
</formalpara>
<formalpara>
<title>/test/learning_test.rb</title>
<para>
<programlisting language="ruby" linenumbering="unnumbered"># frozen_string_literal: true

require './test/test_helper'
require 'minitest/autorun'
require './lib/fizz_buzz'

class LearningTest &lt; Minitest::Test
  describe '配列や繰り返し処理を理解する' do
    def test_繰り返し処理
      $stdout = StringIO.new
      [1, 2, 3].each { |i| p i * i }
      output = $stdout.string

      assert_equal "1\n" + "4\n" + "9\n", output
    end

    def test_selectメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].select(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_find_allメソッドで特定の条件を満たす要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].find_all(&amp;:integer?)
      assert_equal [2, 4], result
    end

    def test_特定の条件を満たさない要素だけを配列に入れて返す
      result = [1.1, 2, 3.3, 4].reject(&amp;:integer?)
      assert_equal [1.1, 3.3], result
    end

    def test_mapメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].map(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_collectメソッドで新しい要素の配列を返す
      result = %w[apple orange pineapple strawberry].collect(&amp;:size)
      assert_equal [5, 6, 9, 10], result
    end

    def test_findメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].find(&amp;:size)
      assert_equal 'apple', result
    end

    def test_detectメソッドで配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry].detect(&amp;:size)
      assert_equal 'apple', result
    end

    def test_指定した評価式で並び変えた配列を返す
      result1 = %w[2 4 13 3 1 10].sort
      result2 = %w[2 4 13 3 1 10].sort { |a, b| a.to_i &lt;=&gt; b.to_i }
      result3 = %w[2 4 13 3 1 10].sort { |b, a| a.to_i &lt;=&gt; b.to_i }

      assert_equal %w[1 10 13 2 3 4], result1
      assert_equal %w[1 2 3 4 10 13], result2
      assert_equal %w[13 10 4 3 2 1], result3
    end

    def test_配列の中から条件に一致する要素を取得する
      result = %w[apple orange pineapple strawberry apricot].grep(/^a/)
      assert_equal %w[apple apricot], result
    end

    def test_ブロック内の条件式が真である間までの要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9].take_while { |item| item &lt; 6 }
      assert_equal [1, 2, 3, 4, 5], result
    end

    def test_ブロック内の条件式が真である以降の要素を返す
      result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].drop_while { |item| item &lt; 6 }
      assert_equal [6, 7, 8, 9, 10], result
    end

    def test_injectメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].inject(0) { |total, n| total + n }
      assert_equal 15, result
    end

    def test_reduceメソッドで畳み込み演算を行う
      result = [1, 2, 3, 4, 5].reduce { |total, n| total + n }
      assert_equal 15, result
    end
  end
end</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_良い設計">
<title>良い設計</title>
<simpara>エピソード1では <emphasis role="strong">良いコード</emphasis> について考えました。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TDDは「より良いコードを書けば、よりうまくいく」という素朴で奇妙な仮設によって成り立っている</simpara>
</blockquote>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>「動作するきれいなコード」。RonJeffriesのこの簡潔な言葉が、テスト駆動開発(TDD)のゴールだ。動作するきれいなコードはあらゆる意味で価値がある。</simpara>
</blockquote>
<blockquote>
<attribution>
リファクタリング(第2版)
</attribution>
<simpara>良いコードかどうかは、変更がどれだけ容易なのかで決まる。</simpara>
</blockquote>
<blockquote>
<attribution>
リーダブルコード
</attribution>
<simpara>コードは理解しやすくなければいけない。</simpara>
</blockquote>
<simpara>本エピソードでは <emphasis role="strong">テスト駆動開発</emphasis> による <emphasis role="strong">オブジェクト指向プログラミング</emphasis> の <emphasis role="strong">リファクタリング</emphasis> を経てコードベースを改善してきました。そして <emphasis role="strong">オブジェクト指向設計</emphasis> により <emphasis role="strong">良いコード</emphasis> のプログラムを <emphasis role="strong">良い設計</emphasis> のアプリケーションへと進化させることができました。</simpara>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>どこに何が書いてあるかをわかりやすくし、変更の影響を狭い範囲に閉じ込め、安定して動作する部品を柔軟に組み合わせながらソフトウェアを構築する技法がオブジェクト指向設計です。</simpara>
</blockquote>
<blockquote>
<attribution>
現場で役立つシステム設計の原則
</attribution>
<simpara>設計の良し悪しは、ソフトウェアを変更するときにはっきりします。</simpara>
<simpara>構造が入り組んだわかりづらいプログラムは内容の理解に時間がかかります。重複したコードをあちこちで修正する作業が増え、変更の副作用に悩まされます。</simpara>
<simpara>一方、うまく設計されたプログラムは変更が楽で安全です。変更すべき箇所がかんたんにわかり、変更するコード量が少なく、変更の影響を狭い範囲に限定できます。</simpara>
<simpara>プログラムの修正に３日かかるか、それとも半日で済むか。その違いを生むのが「設計」なのです。</simpara>
</blockquote>
<simpara>では、いつ設計をしていたのでしょうか？ わかりますよね、このエピソードの始まりから終わりまで常に設計をしていたのです。</simpara>
<blockquote>
<attribution>
テスト駆動開発
</attribution>
<simpara>TDDは分析技法であり、設計技法であり、実際には開発のすべてのアクティビティを構造化する技法なのだ。</simpara>
</blockquote>
</section>
</section>
</section>
</article>